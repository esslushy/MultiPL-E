{"name": "HumanEval_136_largest_smallest_integers", "language": "fs", "prompt": "//Create a function that returns a tuple (a, b), where 'a' is\n// the largest of negative integers, and 'b' is the smallest\n// of positive integers in a list.\n// If there is no negative or positive integers, return them as None.\n// Examples:\n// largest_smallest_integers([2, 4, 1, 3, 5, 7]) == (None, 1)\n// largest_smallest_integers([]) == (None, None)\n// largest_smallest_integers([0]) == (None, None)\nlet largest_smallest_integers (lst: int list):  int option * int option  = \n", "tests": "let test() = \n  let candidate = largest_smallest_integers\n  assert (candidate [2; 4; 1; 3; 5; 7] = (None, 1))\n  assert (candidate [2; 4; 1; 3; 5; 7; 0] = (None, 1))\n  assert (candidate [1; 3; 2; 4; 5; 6; -2] = (-2, 1))\n  assert (candidate [4; 5; 3; 6; 2; 7; -7] = (-7, 2))\n  assert (candidate [7; 3; 8; 4; 9; 2; 5; -9] = (-9, 2))\n  assert (candidate [] = (None, None))\n  assert (candidate [0] = (None, None))\n  assert (candidate [-1; -3; -5; -6] = (-1, None))\n  assert (candidate [-1; -3; -5; -6; 0] = (-1, None))\n  assert (candidate [-6; -4; -4; -3; 1] = (-3, 1))\n  assert (candidate [-6; -4; -4; -3; -100; 1] = (-3, 1))\n  0\n\ntest()", "completions": ["    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | [x; y] -> Some (x, y), None\n    | [x; y; z] -> Some (x, y, z), None\n    | _ -> failwith \"unexpected list\"", "    match lst with\n    | [] -> None, None\n    | _ -> \n        let rec largest_smallest_integers_rec acc lst = \n            match lst with\n            | [] -> acc\n            | x :: xs -> largest_smallest_integers_rec (x :: acc) xs\n        largest_smallest_integers_rec [] lst", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | x::xs ->\n        let rec loop i =\n            if i < 0 then None\n            elif i = 0 then Some x\n            else loop (i-1)\n        loop (List.length xs)", "    let rec largest_smallest_integers' acc lst = \n        match lst with \n        | [] -> acc, None\n        | x::xs -> \n            if x > 0 then largest_smallest_integers' (Some x) xs\n            else largest_smallest_integers' (None, Some x) xs\n    largest_smallest_integers' None lst", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | x::xs ->\n        let max_x = List.max xs\n        let min_x = List.min xs\n        if max_x <= 0 then\n            None, None\n        else\n            Some (max_x, min_x), Some (max_x - 1, min_x - 1)", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | x::xs ->\n        let max_x = max x\n        let min_x = min x\n        let max_y = max y\n        let min_y = min y\n        if max_x < min_x || max_y < min_y then None, None\n        else\n            let max_x = max x\n            let min_x = min x\n            let max_y = max y\n            let min_y = min y\n            if max_x < min_x || max_y < min_y then None, None\n            else\n                let max_x = max x\n                let min_x = min x\n                let max_y = max y\n                let min_y = min y\n                if max_x < min_x || max_y < min_y then None, None\n                else\n                    let max_x = max x\n                    let min_x = min x\n                    let max_y = max y\n                    let min_y = min y\n                    if max_x < min_x || max_y < min_y then None, None\n                    else\n                        let max_x = max x\n                        let min_x = min x\n                        let max_y = max y\n                        let min_y = min y\n                        if max_x < min_x || max_y < min_y then None, None\n                        else\n                            let max_x = max x\n                            let min_x = min x\n                            let max_y = max y\n                            let min_y = min y\n                            if max_x < min_x || max_y < min_y then None, None\n                            else\n                                let max_x = max x\n                                let min_x = min x\n                                let max_y = max y\n                                let min_y = min y\n                                if max_x < min_x || max_y < min_y then None, None\n                                else\n                                    let max_x = max x\n                                    let min_x = min x\n                                    let max_y = max y\n                                    let min_y = min y\n                                    if max_x < min_x || max_", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | x::xs -> \n        let min_x = min x\n        let max_x = max x\n        let min_y = min y\n        let max_y = max y\n        if min_x < 0 || max_x > max_y then None, None\n        else\n            let min_y = min y\n            let max_y = max y\n            if min_y < 0 || max_y > max_x then None, None\n            else\n                let min_x = min x\n                let max_x = max x\n                if min_x < 0 || max_x > max_y then None, None\n                else\n                    let min_y = min y\n                    let max_y = max y\n                    if min_y < 0 || max_y > max_x then None, None\n                    else\n                        let min_x = min x\n                        let max_x = max x\n                        if min_x < 0 || max_x > max_y then None, None\n                        else\n                            let min_y = min y\n                            let max_y = max y\n                            if min_y < 0 || max_y > max_x then None, None\n                            else\n                                let min_x = min x\n                                let max_x = max x\n                                if min_x < 0 || max_x > max_y then None, None\n                                else\n                                    let min_y = min y\n                                    let max_y = max y\n                                    if min_y < 0 || max_y > max_x then None, None\n                                    else\n                                        let min_x = min x\n                                        let max_x = max x\n                                        if min_x < 0 || max_x > max_y then None, None\n                                        else\n                                            let min_y = min y\n                                            let max_y = max y\n                                            if min_y < 0 || max_y > max_x then None, None\n                                            else\n                                                let min_x = min x\n                                                let max_x = max x\n                                                if min_x < 0 || max_x > max_y then None,", "    let rec largest_smallest_integers' acc lst =\n        match lst with\n        | [] -> acc\n        | x::xs ->\n            match largest_smallest_integers' (Some x) xs with\n            | Some x', Some y' -> largest_smallest_integers' (Some y') xs\n            | Some x', None -> largest_smallest_integers' (Some x') xs\n            | None, Some y' -> largest_smallest_integers' (Some y') xs\n            | None, None -> largest_smallest_integers' None xs\n    largest_smallest_integers' None lst", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | x::xs ->\n        let rec loop acc xs =\n            match xs with\n            | [] -> acc\n            | x::xs ->\n                let y = x - xs.[0]\n                if y > 0 then loop (x::acc) xs else acc\n        loop [] xs", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | [x;y] -> Some (x, y), None\n    | _ -> failwith \"unexpected list\"", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | x::xs ->\n        let rec loop acc xs =\n            match xs with\n            | [] -> acc\n            | [x] -> loop (x::acc) xs\n            | x::xs -> loop (x::acc) xs\n        loop [] xs", "    let rec largest_smallest_integers_rec (lst: int list) : (int * int) option * int option = \n        match lst with\n        | [] -> None, None\n        | x::xs -> \n            match largest_smallest_integers_rec xs with\n            | None, None -> None, None\n            | Some(a,b), Some(c,d) -> Some(a,b), Some(c,d)\n    largest_smallest_integers_rec lst", "    let rec largest_smallest_integers' acc lst = \n        match lst with\n        | [] -> acc, None\n        | x::xs -> \n            let acc' = largest_smallest_integers' (Some x) xs\n            if acc' <> None then Some acc'\n            else largest_smallest_integers' acc xs\n    largest_smallest_integers' None lst", "    let rec largest_smallest_integers' (lst: int list) = \n        match lst with \n        | [] -> None, None\n        | x::xs -> \n            let x' = x - 1\n            if x' < 0 then largest_smallest_integers' xs\n            elif x' > 0 then largest_smallest_integers' xs\n            else largest_smallest_integers' xs\n    largest_smallest_integers' lst", "    let rec largest_smallest_integers' (lst: int list) = \n        match lst with\n        | [] -> None, None\n        | x::xs ->\n            let x' = abs x\n            if x' < 0 then largest_smallest_integers' xs\n            else largest_smallest_integers' xs\n    largest_smallest_integers' lst", "    let rec largest_smallest_integers' acc lst = \n        match lst with\n        | [] -> acc\n        | x::xs -> \n            let x' = x - 1\n            if x' < 0 then largest_smallest_integers' (Some x') xs\n            elif x' > 0 then largest_smallest_integers' (Some x') xs\n            else largest_smallest_integers' (None) xs\n    largest_smallest_integers' None lst", "    let rec largest_smallest_integers' (lst: int list) = \n        match lst with\n        | [] -> None, None\n        | x::xs -> \n            match largest_smallest_integers' xs with\n            | Some(a,b), Some(c,d) -> Some(a,b), Some(c,d)\n            | Some(a,b), None -> Some(a,b), None\n            | None, Some(c,d) -> Some(c,d), None\n            | None, None -> None, None\n    largest_smallest_integers' lst", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | x::xs -> \n        let rec loop acc = function\n            | [] -> acc\n            | x::xs -> \n                let acc = loop (x::acc) xs\n                if acc = None then None else loop acc xs\n        loop None xs", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | x::xs ->\n        let xs = List.rev xs\n        let rec loop acc xs =\n            match xs with\n            | [] -> acc\n            | x::xs ->\n                match x with\n                | x when x < 0 -> loop (x::acc) xs\n                | x when x > 0 -> loop (x::acc) xs\n                | _ -> acc\n        loop [] xs", "    match lst with\n    | [] -> None, None\n    | [x] -> Some x, None\n    | [x; y] -> Some x, Some y\n    | _ -> failwith \"invalid list\""], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}