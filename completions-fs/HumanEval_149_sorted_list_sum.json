{"name": "HumanEval_149_sorted_list_sum", "language": "fs", "prompt": "//Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order,\n// The list is always a list of strings and never an array of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n// assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlet sorted_list_sum (lst: string list): string list  = \n", "tests": "let test() = \n  let candidate = sorted_list_sum\n  assert (candidate [\"aa\"; \"a\"; \"aaa\"] = [\"aa\"])\n  assert (candidate [\"school\"; \"AI\"; \"asdf\"; \"b\"] = [\"AI\"; \"asdf\"; \"school\"])\n  assert (candidate [\"d\"; \"b\"; \"c\"; \"a\"] = [])\n  assert (candidate [\"d\"; \"dcba\"; \"abcd\"; \"a\"] = [\"abcd\"; \"dcba\"])\n  assert (candidate [\"AI\"; \"ai\"; \"au\"] = [\"AI\"; \"ai\"; \"au\"])\n  assert (candidate [\"a\"; \"b\"; \"b\"; \"c\"; \"c\"; \"a\"] = [])\n  assert (candidate [\"aaaa\"; \"bbbb\"; \"dd\"; \"cc\"] = [\"cc\"; \"dd\"; \"aaaa\"; \"bbbb\"])\n  0\n\ntest()", "completions": ["    let rec loop acc (lst: string list) = \n        match lst with\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] lst", "    let rec sort_list (lst: string list) = \n        match lst with\n        | [] -> []\n        | x::xs -> \n            let xs = sort_list xs\n            let ys = sort_list xs\n            if xs.Length <> ys.Length then\n                let temp = xs\n                xs <- ys\n                ys <- temp\n            xs@ys\n    sort_list lst", "    let rec loop acc (lst: string list) =\n        match lst with\n        | [] -> acc\n        | hd::tl -> loop (acc + hd) tl\n    loop \"\" lst", "    let rec loop acc (lst: string list) = \n        match lst with\n        | [] -> acc\n        | hd::tl -> loop (hd::acc) tl\n    loop [] lst", "    let rec sort_list (lst: string list) = \n        match lst with\n        | [] -> []\n        | head::tail ->\n            let new_head = head.ToLower()\n            if new_head = \"a\" then\n                sort_list tail\n            else\n                let new_tail = tail |> List.map (fun x -> x.ToLower()) |> List.sort\n                sort_list new_tail\n    sort_list lst", "    let rec sort_list (lst: string list) = \n        match lst with\n        | [] -> []\n        | hd::tl -> \n            let new_hd = hd.ToLower()\n            if new_hd = \"a\" then sort_list tl\n            elif new_hd = \"aa\" then sort_list tl\n            elif new_hd = \"ab\" then sort_list tl\n            else sort_list (hd::tl)\n    sort_list lst", "    let rec sort_list (lst: string list) =\n        match lst with\n        | [] -> []\n        | x::xs ->\n            let xs = x::xs\n            let ys = sort_list xs\n            if List.length ys > List.length xs then\n                yield xs\n                yield! sort_list ys\n            else\n                yield xs\n                yield! sort_list ys\n    sort_list lst", "    let rec sort_list (lst: string list) = \n        match lst with \n        | [] -> []\n        | hd::tl -> \n            let new_hd = hd + \" \" + (sort_list tl)\n            [hd; new_hd]\n    sort_list lst", "    let rec sort_list acc lst = \n        match lst with\n        | [] -> acc\n        | hd::tl -> \n            let new_acc = hd::acc\n            sort_list new_acc tl\n    sort_list [] lst", "    let rec loop acc lst = \n        match lst with \n        | [] -> acc\n        | x::xs -> \n            match x with \n            | 'a' -> loop (acc + x) xs\n            | 'b' -> loop (acc + x) xs\n            | 'c' -> loop (acc + x) xs\n            | 'd' -> loop (acc + x) xs\n            | _ -> loop acc xs\n    loop 0 lst", "    let rec loop acc (lst: string list) =\n        match lst with\n        | [] -> acc\n        | x::xs -> loop (acc + x) xs\n    loop \"\" lst", "    let rec loop acc lst = \n        match lst with\n        | [] -> acc\n        | hd::tl -> loop (acc + hd) tl\n    loop \"\" lst", "    let rec sort_list (lst: string list) = \n        match lst with \n        | [] -> []\n        | x::xs -> \n            let new_lst = x::lst\n            sort_list new_lst\n    sort_list lst", "    let rec sort_list (lst: string list) = \n        match lst with\n        | [] -> []\n        | x::xs -> \n            let xs = x::xs\n            let xs = sort_list xs\n            let xs = sort_list xs\n            xs\n    sort_list lst", "    let rec sort_list (lst: string list) = \n        match lst with \n        | [] -> []\n        | h::t -> \n            let new_lst = h::lst\n            sort_list new_lst\n    sort_list lst", "    let rec loop acc lst = \n        match lst with\n        | [] -> acc\n        | hd::tl -> loop (acc + hd) tl\n    loop \"\" lst", "    let rec loop acc lst = \n        match lst with \n        | [] -> acc\n        | hd::tl -> loop (hd::acc) tl\n    loop [] lst", "    let rec loop acc lst =\n        match lst with\n        | [] -> acc\n        | h::t -> loop (acc + h) t\n    loop \"\" lst", "    let rec loop acc lst = \n        match lst with \n        | [] -> acc\n        | x::xs -> loop (acc + x) xs\n    loop 0 lst", "    let rec sort_list (lst: string list) = \n        match lst with \n        | [] -> []\n        | head::tail -> \n            let new_head = head.ToLower()\n            if new_head = \"a\" then \n                sort_list tail\n            elif new_head = \"aa\" then \n                sort_list tail\n            elif new_head = \"ab\" then \n                sort_list tail\n            elif new_head = \"cd\" then \n                sort_list tail\n            else \n                sort_list (head::tail)\n    sort_list lst"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}