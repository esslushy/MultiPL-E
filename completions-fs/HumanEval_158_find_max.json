{"name": "HumanEval_158_find_max", "language": "fs", "prompt": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n", "tests": "let test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()", "completions": ["    let rec find_max_rec (words: string list) (acc: string) = \n        match words with\n        | [] -> acc\n        | head::tail ->\n            if acc.Length > 0 then\n                let max_acc = find_max_rec tail acc\n                if head.Length > max_acc.Length then\n                    acc + head\n                else\n                    acc + head + \" \" + find_max_rec tail acc\n            else\n                acc + head\n    find_max_rec words \"\"", "    let rec find_max_rec (acc: string) (words: string list) = \n        match words with\n        | [] -> acc\n        | w::ws -> \n            let acc = w::acc\n            let rec find_max_rec_rec acc ws = \n                match ws with\n                | [] -> acc\n                | w::ws -> \n                    let acc = w::acc\n                    find_max_rec_rec acc ws\n            find_max_rec_rec acc ws\n    find_max_rec \"\" words", "    let rec find_max_rec (words: string list) = \n        match words with\n        | [] -> \"\"\n        | x::xs -> \n            let max_char = List.max xs\n            if max_char = x then \n                find_max_rec xs\n            else\n                let new_max_char = max_char + 1\n                if new_max_char = x then \n                    find_max_rec xs\n                else\n                    find_max_rec (List.skip max_char xs)\n    find_max_rec words", "    let rec find_max_rec (acc: string) (acc_max: string) (words: string list) = \n        match words with \n        | [] -> acc\n        | word::rest -> \n            let new_acc = acc + word\n            if acc_max.Length = 0 then new_acc\n            else find_max_rec new_acc acc_max rest\n    find_max_rec \"\" \"\" words", "    let rec find_max (words: string list) = \n        match words with\n        | [] -> \"\"\n        | head::tail ->\n            let max_char = List.max(head.ToCharArray())\n            if max_char <> head.Length then\n                find_max tail\n            else\n                head.Substring(0, max_char)\n    find_max words", "    let rec find_max_rec (words: string list) (acc: string) = \n        match words with\n        | [] -> acc\n        | x::xs -> \n            let acc' = x.ToCharArray() |> Array.max\n            if acc' = x then find_max_rec xs acc'\n            else find_max_rec xs (acc' + x.ToCharArray())\n    find_max_rec words \"\"", "    let mutable max = 0\n    for word in words do\n        let mutable i = 0\n        while i < word.Length do\n            if word.[i] = word.[max] then\n                max <- i\n            i <- i + 1\n    max", "    let rec find_max_rec (words: string list) (acc: string) =\n        match words with\n        | [] -> acc\n        | head::tail ->\n            if head.Length > acc.Length then\n                find_max_rec tail (acc.Substring(0, acc.Length-head.Length))\n            else\n                find_max_rec tail (acc.Substring(0, acc.Length-head.Length)) + head\n    find_max_rec words \"\"", "    let rec find_max_rec (words: string list) (acc: string) = \n        match words with \n        | [] -> acc\n        | word::rest -> \n            if acc.Length > 0 then \n                let max_acc = acc.[0]\n                let max_acc_len = acc.Length\n                if max_acc_len > max_acc.Length then\n                    let max_acc_len = max_acc_len\n                    let max_acc = acc.[0]\n                    let max_acc_len = max_acc_len\n                    if max_acc_len > max_acc.Length then\n                        let max_acc_len = max_acc_len\n                        let max_acc = acc.[0]\n                        let max_acc_len = max_acc_len\n                        if max_acc_len > max_acc.Length then\n                            let max_acc_len = max_acc_len\n                            let max_acc = acc.[0]\n                            let max_acc_len = max_acc_len\n                            if max_acc_len > max_acc.Length then\n                                let max_acc_len = max_acc_len\n                                let max_acc = acc.[0]\n                                let max_acc_len = max_acc_len\n                                if max_acc_len > max_acc.Length then\n                                    let max_acc_len = max_acc_len\n                                    let max_acc = acc.[0]\n                                    let max_acc_len = max_acc_len\n                                    if max_acc_len > max_acc.Length then\n                                        let max_acc_len = max_acc_len\n                                        let max_acc = acc.[0]\n                                        let max_acc_len = max_acc_len\n                                        if max_acc_len > max_acc.Length then\n                                            let max_acc_len = max_acc_len\n                                            let max_acc = acc.[0]\n                                            let max_acc_len = max_acc_len\n                                            if max_acc_len > max_acc.Length then\n                                                let max_acc_len = max_acc_len\n                                                let max_acc = acc.[0]\n                                                let max_", "    let rec find_max_rec (words: string list) (acc: string) = \n        match words with\n        | [] -> acc\n        | x::xs -> \n            let acc' = x.ToCharArray() |> Array.max\n            if acc' = acc then acc'\n            else find_max_rec xs (acc' + \" \")\n    find_max_rec words \"\"", "    let rec find_max_rec (acc: string) (acc_len: int) (words: string list): string =\n        match words with\n        | [] -> acc\n        | h::t ->\n            if acc_len = 0 then\n                acc\n            else\n                let acc' = h::acc\n                find_max_rec acc' (acc_len-1) t\n    find_max_rec \"\" 0 words", "    let rec find_max_rec (words: string list) (acc: string) = \n        match words with\n        | [] -> acc\n        | x::xs -> \n            let max_acc = x\n            let rec find_max_rec_rec acc = \n                match acc with\n                | \"\" -> acc\n                | x::xs -> \n                    let max_acc = x\n                    if x.Length > max_acc.Length then\n                        find_max_rec_rec (x::acc) (x.Substring(0, max_acc.Length))\n                    else\n                        find_max_rec_rec (x::acc) (x.Substring(max_acc.Length))\n            find_max_rec_rec acc\n    find_max_rec words \"\"", "    let rec find_max (words: string list) = \n        match words with\n        | [] -> \"\"\n        | head::tail -> \n            let max_char = List.max words\n            let max_char_str = List.map (fun word -> word.ToString()) words\n            if head.Length = max_char then\n                max_char_str\n            else\n                find_max tail\n    find_max words", "    let rec find_max_rec (acc: string) (words: string list) = \n        match words with\n        | [] -> acc\n        | word :: rest -> \n            if acc.Length > word.Length then \n                find_max_rec acc rest\n            else\n                acc + word\n    find_max_rec \"\" words", "    let mutable max = 0\n    for word in words do\n        let mutable i = 0\n        while i < word.Length do\n            if word.[i] = word.[i-1] then\n                i <- i + 1\n            else\n                max <- max + 1\n                i <- i - 1\n    max", "    let rec find_max_rec (acc: string) (acc_len: int) (words: string list): string = \n        match words with\n        | [] -> acc\n        | head::tail ->\n            let new_acc = head.ToCharArray()\n            if new_acc.Length > acc_len then\n                find_max_rec acc_len (new_acc.Length - 1) tail\n            else\n                find_max_rec acc_len (new_acc.Length + 1) tail\n    find_max_rec \"\" 0 words", "    let mutable max_index = 0\n    let mutable max_value = \"\"\n    for word in words do\n        if (max_index = -1) then\n            max_index <- max_index + 1\n        if (max_value = word) then\n            max_value <- word\n        else\n            max_index <- max_index + 1\n    max_value", "    let rec find_max (words: string list) = \n        match words with\n        | [] -> \"\"\n        | head::tail -> \n            let max_num = List.max(List.map (fun word -> List.length word) words)\n            if max_num = List.length words then\n                head\n            else\n                find_max tail\n    find_max words", "    let rec find_max (words: string list): string = \n        match words with\n        | [] -> \"\"\n        | word::rest -> \n            if word.Length > 0 then \n                let max_char = word.Length\n                let max_index = word.IndexOf(max_char)\n                if max_index < 0 then \n                    word\n                else\n                    let rest_index = rest.IndexOf(word, max_index)\n                    if rest_index < 0 then \n                        word\n                    else\n                        let rest_index = rest.IndexOf(word, max_index)\n                        if rest_index < 0 then \n                            word\n                        else\n                            let rest_index = rest.IndexOf(word, max_index)\n                            if rest_index < 0 then \n                                word\n                            else\n                                let rest_index = rest.IndexOf(word, max_index)\n                                if rest_index < 0 then \n                                    word\n                                else\n                                    let rest_index = rest.IndexOf(word, max_index)\n                                    if rest_index < 0 then \n                                        word\n                                    else\n                                        let rest_index = rest.IndexOf(word, max_index)\n                                        if rest_index < 0 then \n                                            word\n                                        else\n                                            let rest_index = rest.IndexOf(word, max_index)\n                                            if rest_index < 0 then \n                                                word\n                                            else\n                                                let rest_index = rest.IndexOf(word, max_index)\n                                                if rest_index < 0 then \n                                                    word\n                                                else\n                                                    let rest_index = rest.IndexOf(word, max_index)\n                                                    if rest_index < 0 then \n                                                        word\n                                                    else\n                                                        let rest_index = rest.IndexOf(word, max_index)\n                                                        if rest_index < 0 then \n                                                            word\n                                                        else\n                                                            let rest_index = rest.IndexOf(word, max_index)\n                                                            if rest_index < 0 then \n                                                                word\n                                                            else\n                                                                let rest_index = rest.IndexOf(word, max_index)\n                               ", "    let mutable max = 0\n    let mutable i = 0\n    while i < words.Length do\n        let word = words.[i]\n        if word.Length > max then\n            max <- word.Length\n        i <- i + 1\n    max"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}