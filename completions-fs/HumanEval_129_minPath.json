{"name": "HumanEval_129_minPath", "language": "fs", "prompt": "//Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered lists of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered list of the values on the cells that the minimum path go through.\n// Examples:\n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [1, 2, 1]\n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n// Output: [1]\nlet minPath (grid: int list list) (k: int): int list  = \n", "tests": "let test() = \n  let candidate = minPath\n  assert (candidate [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] 3 = [1; 2; 1])\n  assert (candidate [[5; 9; 3]; [4; 1; 6]; [7; 8; 2]] 1 = [1])\n  assert (candidate [[1; 2; 3; 4]; [5; 6; 7; 8]; [9; 10; 11; 12]; [13; 14; 15; 16]] 4 = [1; 2; 1; 2])\n  assert (candidate [[6; 4; 13; 10]; [5; 7; 12; 1]; [3; 16; 11; 15]; [8; 14; 9; 2]] 7 = [1; 10; 1; 10; 1; 10; 1])\n  assert (candidate [[8; 14; 9; 2]; [6; 4; 13; 15]; [5; 7; 1; 12]; [3; 10; 11; 16]] 5 = [1; 7; 1; 7; 1])\n  assert (candidate [[11; 8; 7; 2]; [5; 16; 14; 4]; [9; 3; 15; 6]; [12; 13; 10; 1]] 9 = [1; 6; 1; 6; 1; 6; 1; 6; 1])\n  assert (candidate [[12; 13; 10; 1]; [9; 3; 15; 6]; [5; 16; 14; 4]; [11; 8; 7; 2]] 12 = [1; 6; 1; 6; 1; 6; 1; 6; 1; 6; 1; 6])\n  assert (candidate [[2; 7; 4]; [3; 1; 5]; [6; 8; 9]] 8 = [1; 3; 1; 3; 1; 3; 1; 3])\n  assert (candidate [[6; 1; 5]; [3; 8; 9]; [2; 7; 4]] 8 = [1; 5; 1; 5; 1; 5; 1; 5])\n  assert (candidate [[1; 2]; [3; 4]] 10 = [1; 2; 1; 2; 1; 2; 1; 2; 1; 2])\n  assert (candidate [[1; 3]; [3; 2]] 10 = [1; 3; 1; 3; 1; 3; 1; 3; 1; 3])\n  0\n\ntest()", "completions": ["    let rec go (grid: int list list) (k: int): int list = \n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let newGrid = List.map (fun y -> go xs (k-1)) xs\n            go newGrid (k-1)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list list = \n        match grid with\n        | [] -> []\n        | hd::tl -> \n            let rec go' (hd: int list) (k: int): int list list = \n                match hd with\n                | [] -> []\n                | hd::tl -> \n                    let rec go'' (hd: int list) (k: int): int list list = \n                        match hd with\n                        | [] -> []\n                        | hd::tl -> \n                            let rec go'' (hd: int list) (k: int): int list list = \n                                match hd with\n                                | [] -> []\n                                | hd::tl -> \n                                    let rec go''' (hd: int list) (k: int): int list list = \n                                        match hd with\n                                        | [] -> []\n                                        | hd::tl -> \n                                            let rec go''' (hd: int list) (k: int): int list list = \n                                                match hd with\n                                                | [] -> []\n                                                | hd::tl -> \n                                                    let rec go''' (hd: int list) (k: int): int list list = \n                                                        match hd with\n                                                        | [] -> []\n                                                        | hd::tl -> \n                                                            let rec go''' (hd: int list) (k: int): int list list = \n                                                                match hd with\n                                                                | [] -> []\n                                                                | hd::tl -> \n                                                                    let rec go''' (hd: int list) (k: int): int list list = \n                                                                        match hd with\n                                                                        | [] -> []\n                                                                        | hd::tl -> \n                                                                            let rec go''' (hd: int list) (k: int): int list list = \n                                                                                match hd with\n                                                                                | [] -> []\n                                                                                | hd::tl -> \n                                                                                    let rec go''' (hd: int list) (k: int): int list list = \n                                                                                        match hd with\n", "    let rec go (grid: int list list) (k: int): int list = \n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let newGrid = go xs (k-1)\n            if k = 1 then \n                newGrid\n            else\n                go newGrid (k-1)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list list = \n        match grid with\n        | [] -> []\n        | hd::tl -> \n            let min_k = min k hd\n            let new_grid = go tl min_k\n            go new_grid (k-1)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list list = \n        match grid with\n        | [] -> []\n        | hd::tl ->\n            let min = hd |> List.min\n            go tl (k-1)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list list = \n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let newGrid = List.map (fun y -> List.map (fun x -> x) xs) xs\n            go newGrid (k-1)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list = \n        match grid with\n        | [] -> []\n        | (x::xs)::xs' -> \n            let min = List.min xs'\n            let newGrid = List.map (fun y -> (min, y)) xs\n            go newGrid (k-1)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list =\n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let newGrid = go xs (k-1)\n            let newGrid = go newGrid (k-1)\n            (min::newGrid)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list list = \n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let newGrid = go xs (k-1)\n            let newGrid = List.map (fun x -> x - min) newGrid\n            go newGrid k\n    go grid k", "    let rec go (grid: int list list) (k: int): int list = \n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let newGrid = go xs (k-1)\n            let newGrid = go newGrid (k-1)\n            go newGrid (k-1)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list =\n        match grid with\n        | [] -> []\n        | (x::xs)::xs' ->\n            let min = min (minPath xs k) (minPath xs' k)\n            go xs' k\n    go grid k", "    let rec go (k: int) (grid: int list list) = \n        match grid with\n        | [] -> []\n        | hd::tl -> \n            if k = 1 then \n                [ hd ]\n            else\n                go (k-1) tl\n    go k grid", "    let rec go (grid: int list list) (k: int): int list list = \n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let newGrid = List.map (fun y -> List.map (fun x -> x + y) xs) xs\n            go newGrid (k - 1)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list = \n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let max = List.max xs\n            if k < min then go xs (k-1)\n            elif k > max then go xs (k-1)\n            else go (x::xs) (k-1)\n    go grid k", "    let rec go (grid: int list list) (k: int): int list =\n        match grid with\n        | [] -> []\n        | hd::tl ->\n            let min_k = min k hd\n            let min_grid = List.map (fun x -> x, go tl (min_k + 1)) hd\n            go min_grid k\n    go grid k", "    let rec go (grid: int list list) (k: int): int list list = \n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let newGrid = List.map (fun y -> List.map (fun x -> if x = min then y else x) xs) xs\n            go newGrid k\n    go grid k", "    let rec go (lst: int list list) (k: int): int list list = \n        match lst with\n        | [] -> []\n        | hd::tl -> \n            let rec go' (lst: int list list) (k: int): int list list = \n                match lst with\n                | [] -> []\n                | hd::tl -> \n                    let newLst = go' tl (k-1)\n                    go' newLst (k-1)\n            go' tl k\n    go grid k", "    let rec go (grid: int list list) (k: int): int list =\n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs ->\n            let min = List.min xs\n            let rec go' (grid: int list list) (k: int): int list =\n                match grid with\n                | [] -> []\n                | [x] -> [x]\n                | x::xs ->\n                    let min = List.min xs\n                    let rec go'' (grid: int list list) (k: int): int list =\n                        match grid with\n                        | [] -> []\n                        | [x] -> [x]\n                        | x::xs ->\n                            let min = List.min xs\n                            let rec go'' (grid: int list list) (k: int): int list =\n                                match grid with\n                                | [] -> []\n                                | [x] -> [x]\n                                | x::xs ->\n                                    let min = List.min xs\n                                    let rec go'' (grid: int list list) (k: int): int list =\n                                        match grid with\n                                        | [] -> []\n                                        | [x] -> [x]\n                                        | x::xs ->\n                                            let min = List.min xs\n                                            let rec go'' (grid: int list list) (k: int): int list =\n                                                match grid with\n                                                | [] -> []\n                                                | [x] -> [x]\n                                                | x::xs ->\n                                                    let min = List.min xs\n                                                    let rec go'' (grid: int list list) (k: int): int list =\n                                                        match grid with\n                                                        | [] -> []\n                                                        | [x] -> [x]\n                                                        | x::xs ->\n                                                            let min = List.min xs\n                                                            let rec go'' (grid: int list list) (k: int): int list =\n                                                                match grid with\n                                                                | [] -> []\n                                                                | [x] -> [x]\n                                                                | x::xs ->\n                                                                    let min = List.min xs\n                                                                    let rec", "    let rec go (grid: int list list) (k: int): int list = \n        match grid with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            let min = List.min xs\n            let newGrid = go xs (k-1)\n            go newGrid (k-1)\n    go grid k", "    let rec minPath' (grid: int list list) (k: int): int list = \n        match grid with\n        | [] -> []\n        | (x::xs)::xs' -> \n            let min = min x xs'\n            if k = min then minPath' xs' k\n            else minPath' xs' (k-1)\n    minPath' grid k"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}