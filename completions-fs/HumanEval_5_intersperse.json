{"name": "HumanEval_5_intersperse", "language": "fs", "prompt": "//Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n// >>> intersperse([], 4)\n// []\n// >>> intersperse([1, 2, 3], 4)\n// [1, 4, 2, 4, 3]\nlet intersperse (numbers: int list) (delimeter: int): int list  = \n", "tests": "let test() = \n  let candidate = intersperse\n  assert (candidate [] 7 = [])\n  assert (candidate [5; 6; 3; 2] 8 = [5; 8; 6; 8; 3; 8; 2])\n  assert (candidate [2; 2; 2] 2 = [2; 2; 2; 2; 2])\n  0\n\ntest()", "completions": ["    let rec intersperse' (numbers: int list) (delimeter: int) : int list = \n        match numbers with \n        | [] -> [delimeter]\n        | head::tail -> \n            let tail' = intersperse' tail delimeter\n            if head < tail' then intersperse' tail' (delimeter + head)\n            else tail'\n    intersperse' numbers delimeter", "    let rec intersperse' (numbers: int list) (delimeter: int) : int list = \n        match numbers with \n        | [] -> [delimeter]\n        | head :: tail -> \n            let tail' = intersperse' tail delimeter\n            if head < tail' then intersperse' tail' head\n            else head :: tail'\n    intersperse' numbers delimeter", "    let rec intersperse' (numbers: int list) (delimeter: int) : int list = \n        match numbers with\n        | [] -> [delimeter]\n        | head::tail -> \n            let newHead = head + delimeter\n            intersperse' tail newHead\n    intersperse' numbers delimeter", "    let rec loop i = \n        if i < numbers.Length then\n            let next = numbers.[i]\n            let rest = numbers.[i+1..]\n            loop (i+1)\n            (next::rest)\n        else\n            []\n    loop 0", "    let rec intersperse' (numbers: int list) (delimeter: int) = \n        match numbers with \n        | [] -> []\n        | head :: tail -> \n            let newHead = head + delimeter\n            intersperse' tail (newHead - 1)\n    intersperse' numbers delimeter", "    let rec intersperse' (numbers: int list) (delimeter: int) =\n        match numbers with\n        | [] -> [delimeter]\n        | head::tail ->\n            let tail' = intersperse' tail delimeter\n            let tail'' = intersperse' tail head\n            tail' @ tail''\n    intersperse' numbers delimeter", "    let rec intersperse' (numbers: int list) (delimeter: int) (acc: int list) =\n        match numbers with\n        | [] -> acc\n        | head :: tail ->\n            if head = delimeter then intersperse' tail (delimeter + 1) acc\n            else intersperse' tail (delimeter + 1) (head :: acc)\n    intersperse' numbers delimeter []", "    let rec intersperse' (numbers: int list) (delimeter: int) =\n        match numbers with\n        | [] -> [delimeter]\n        | head::tail ->\n            let tail' = intersperse' tail delimeter\n            if head = tail' then\n                tail'\n            else\n                intersperse' tail' (delimeter + head)\n    intersperse' numbers delimeter", "    let rec loop i =\n        match numbers with\n        | [] -> []\n        | head :: tail ->\n            if i = 0 then\n                head :: tail\n            else\n                loop (i - 1)\n    loop 0", "    let rec intersperse' (numbers: int list) (delimeter: int) : int list = \n        match numbers with\n        | [] -> []\n        | head :: tail -> \n            let newHead = head + delimeter\n            if newHead <> head then intersperse' tail (delimeter - 1)\n            else head :: intersperse' tail (delimeter - 1)\n    intersperse' numbers delimeter", "    let rec loop i = \n        match numbers with\n        | [] -> []\n        | h :: t -> \n            if i = 0 then \n                [h]\n            else \n                loop (i - 1)\n    loop 0", "    let rec intersperse' (numbers: int list) (delimeter: int): int list = \n        match numbers with\n        | [] -> [delimeter]\n        | head :: tail -> \n            let newHead = head + delimeter\n            intersperse' tail newHead\n    intersperse' numbers delimeter", "    let rec loop i = \n        match numbers with \n        | [] -> []\n        | head :: tail -> \n            let newHead = head + delimeter\n            if i < tail.Length then loop (i + 1)\n            else newHead :: loop (i + 1)\n    loop 0", "    let rec intersperse' (numbers: int list) (delimeter: int) : int list =\n        match numbers with\n        | [] -> [delimeter]\n        | head :: tail ->\n            let tail' = intersperse' tail delimeter\n            let tail'' = intersperse' tail head\n            tail' @ tail''\n    intersperse' numbers delimeter", "    let rec intersperse' (numbers: int list) (delimeter: int) : int list =\n        match numbers with\n        | [] -> []\n        | head :: tail ->\n            let newHead = head + delimeter\n            if newHead = head then\n                intersperse' tail (delimeter - 1)\n            else\n                intersperse' tail (delimeter - 1)\n    intersperse' numbers delimeter", "    let rec loop i = \n        match numbers with \n        | [] -> []\n        | head :: tail -> \n            if i = 0 then \n                [head]\n            else \n                loop (i - 1)\n                [head]\n    loop 0", "    let rec intersperse' (numbers: int list) (delimeter: int) : int list = \n        match numbers with\n        | [] -> [delimeter]\n        | head :: tail -> \n            let newHead = head + delimeter\n            intersperse' tail newHead\n    intersperse' numbers delimeter", "    let rec loop (numbers: int list) (acc: int list) = \n        match numbers with \n        | [] -> acc\n        | x::xs -> \n            let next = loop xs (acc@[x])\n            loop xs (acc@[x])\n    loop numbers []", "    let rec intersperse' (numbers: int list) (delimeter: int) : int list = \n        match numbers with \n        | [] -> [delimeter]\n        | head :: tail -> \n            let tail' = intersperse' tail delimeter\n            let tail'' = intersperse' tail delimeter\n            (head :: tail') @ tail''\n    intersperse' numbers delimeter", "    let rec loop i = \n        if i = 0 then numbers\n        else loop (i - 1)\n    loop 0"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}