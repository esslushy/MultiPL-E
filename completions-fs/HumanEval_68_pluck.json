{"name": "HumanEval_68_pluck", "language": "fs", "prompt": "//\"Given an array representing a branch of a tree that has non-negative integer nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked node should be the node with the smallest even value.\n// If multiple nodes with the same smallest even value are found return the node that has smallest index.\n// The plucked node should be returned in a list, [ smalest_value, its index ],\n// If there are no even values or the given array is empty, return [].\n// Example 1:\n// Input: [4,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n// Input: [1,2,3]\n// Output: [2, 1]\n// Explanation: 2 has the smallest even value, and 2 has the smallest index. \n// Example 3:\n// Input: []\n// Output: []\n// Example 4:\n// Input: [5, 0, 3, 0, 4, 2]\n// Output: [0, 1]\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so we will choose the first zero, which has the smallest index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nlet pluck (arr: int list): int list  = \n", "tests": "let test() = \n  let candidate = pluck\n  assert (candidate [4; 2; 3] = [2; 1])\n  assert (candidate [1; 2; 3] = [2; 1])\n  assert (candidate [] = [])\n  assert (candidate [5; 0; 3; 0; 4; 2] = [0; 1])\n  assert (candidate [1; 2; 3; 0; 5; 3] = [0; 3])\n  assert (candidate [5; 4; 8; 4; 8] = [4; 1])\n  assert (candidate [7; 6; 7; 1] = [6; 1])\n  assert (candidate [7; 9; 7; 1] = [])\n  0\n\ntest()", "completions": ["    let rec loop (nodes: int list) (node: int) = \n        match nodes with\n        | [] -> []\n        | [n] -> [n]\n        | n :: nodes -> \n            if n = node then loop nodes (n+1)\n            else loop (n::nodes) node\n    loop [] 0", "    let rec loop (arr: int list) = \n        match arr with\n        | [] -> []\n        | [x] -> [x]\n        | x::xs -> \n            if x % 2 = 0 then loop xs\n            else loop xs\n    loop arr", "    let rec loop (arr: int list) = \n        match arr with\n        | [] -> []\n        | x::xs -> \n            if x % 2 = 0 then \n                loop xs\n            else \n                loop xs\n    loop arr", "    let rec loop (arr: int list) = \n        match arr with\n        | [] -> []\n        | h::t -> \n            if h = 0 then \n                loop t\n            else \n                loop (h::t)\n    loop arr", "    let rec loop (arr: int list) (node: int) =\n        match arr with\n        | [] -> [node]\n        | x::xs ->\n            if node = x then\n                loop xs (node+1)\n            else\n                loop xs (node+1)\n    loop arr 0", "    let rec loop i = \n        if i < arr.length then \n            let value = arr.[i]\n            if value <> 0 then \n                loop (i+1)\n            else \n                arr.[i]\n        else \n            arr.[0]\n    loop 0", "    let rec loop (arr: int list) (node: int) = \n        if node < 0 then \n            [node]\n        else\n            let newNode = node + 1\n            if newNode < 0 then \n                [newNode]\n            else\n                let newList = arr.[newNode] :: arr.[node] :: arr.[newNode-1] :: arr.[newNode-2] :: arr.[newNode-3] :: arr.[newNode-4] :: arr.[newNode-5] :: arr.[newNode-6] :: arr.[newNode-7] :: arr.[newNode-8] :: arr.[newNode-9] :: arr.[newNode-10] :: arr.[newNode-11] :: arr.[newNode-12] :: arr.[newNode-13] :: arr.[newNode-14] :: arr.[newNode-15] :: arr.[newNode-16] :: arr.[newNode-17] :: arr.[newNode-18] :: arr.[newNode-19] :: arr.[newNode-20] :: arr.[newNode-21] :: arr.[newNode-22] :: arr.[newNode-23] :: arr.[newNode-24] :: arr.[newNode-25] :: arr.[newNode-26] :: arr.[newNode-27] :: arr.[newNode-28] :: arr.[newNode-29] :: arr.[newNode-30] :: arr.[newNode-31] :: arr.[newNode-32] :: arr.[newNode-33] :: arr.[newNode-34] :: arr.[newNode-35] :: arr.[newNode-36] :: arr.[newNode-37] :: arr.[newNode-38] :: arr.[newNode-39] :: arr.[newNode-40] :: arr.[newNode-41] :: arr.[newNode-42] :: arr.[newNode-43] :: arr.[newNode-44] :: arr.[newNode-45] :: arr.[newNode-46] :: arr.[newNode-47] :: arr.[newNode-48] :: arr.[newNode-49] :: arr.[newNode-50] :: arr.[newNode-51] :: arr.[newNode-52] :: arr.[newNode-53] :: arr.[newNode-54] :: arr.[new", "    let rec loop (arr: int list) =\n        match arr with\n        | [] -> []\n        | hd::tl ->\n            match hd with\n            | 0 -> tl\n            | _ -> loop tl\n    loop arr", "    let rec loop (nodes: int list) (node: int) =\n        match nodes with\n        | [] -> [node]\n        | head::tail ->\n            if head = node then\n                loop tail (node+1)\n            else\n                loop tail (node+1)\n    loop arr 0", "    let rec loop (arr: int list) = \n        match arr with\n        | [] -> []\n        | hd::tl -> \n            let new_arr = \n                if hd = 0 then \n                    [0]\n                else\n                    let new_arr = \n                        if hd % 2 = 0 then \n                            [hd/2]\n                        else\n                            [hd/2]\n                    loop new_arr\n            loop tl\n    loop arr", "    let rec loop (arr: int list) = \n        match arr with\n        | [] -> []\n        | h::t -> \n            if h % 2 = 0 then \n                loop t\n            else \n                loop (h::t)\n    loop arr", "    let rec loop (arr: int list) (node: int) = \n        if node = 0 then \n            [node]\n        else \n            let new_node = node - 1\n            if new_node >= 0 then \n                loop arr new_node\n            else \n                [node]\n    loop arr 0", "    let rec loop (arr: int list) = \n        match arr with \n        | [] -> []\n        | h::t -> \n            if h = 0 then loop t\n            else loop (h::t)\n    loop arr", "    let rec loop (arr: int list) = \n        match arr with\n        | [] -> []\n        | hd::tl -> \n            if hd = 0 then \n                loop tl\n            else \n                let min_value = List.min arr\n                let min_index = List.findIndex (fun x -> x = min_value) arr\n                let new_arr = List.take min_index tl\n                loop new_arr\n    loop arr", "    let rec loop (arr: int list) =\n        match arr with\n        | [] -> []\n        | hd::tl ->\n            let new_arr = List.append hd (List.rev tl)\n            loop new_arr\n    loop arr", "    let rec loop (arr: int list) = \n        match arr with\n        | [] -> []\n        | hd::tl -> \n            let new_hd = hd + 1\n            let new_tl = loop tl\n            (hd::new_tl)\n    loop arr", "    let rec loop (arr: int list) = \n        match arr with\n        | [] -> []\n        | hd::tl -> \n            let new_arr = \n                if hd = 0 then \n                    [0]\n                else \n                    [hd]\n            loop new_arr\n    loop arr", "    let rec loop (nodes: int list) (node: int): int list = \n        if nodes.length = 0 then \n            [node]\n        else\n            let node_value = nodes.[0]\n            let node_index = nodes.[0] - 1\n            let node_next = loop nodes (node_index + 1)\n            let node_next_value = nodes.[node_next]\n            let node_next_index = nodes.[node_next] - 1\n            let node_next_next = loop nodes (node_next_index + 1)\n            let node_next_next_value = nodes.[node_next_next]\n            let node_next_next_index = nodes.[node_next_next] - 1\n            let node_next_next_next = loop nodes (node_next_next_index + 1)\n            let node_next_next_next_value = nodes.[node_next_next_next]\n            let node_next_next_next_index = nodes.[node_next_next_next] - 1\n            let node_next_next_next_next = loop nodes (node_next_next_next_index + 1)\n            let node_next_next_next_next_value = nodes.[node_next_next_next_next]\n            let node_next_next_next_next_index = nodes.[node_next_next_next_next] - 1\n            let node_next_next_next_next_next = loop nodes (node_next_next_next_next_index + 1)\n            let node_next_next_next_next_next_value = nodes.[node_next_next_next_next_next]\n            let node_next_next_next_next_next_index = nodes.[node_next_next_next_next_next] - 1\n            let node_next_next_next_next_next_next = loop nodes (node_next_next_next_next_next_index + 1)\n            let node_next_next_next_next_next_next_value = nodes.[node_next_next_next_next_next_next]\n            let node_next_next_next_next_next_next_next =", "    let rec loop i = \n        if i < arr.length then \n            let v = arr.[i]\n            if v <> 0 then \n                loop (i+1)\n            else \n                arr.[i]\n        else \n            arr.[0]\n    loop 0", "    let rec loop (arr: int list) = \n        match arr with\n        | [] -> []\n        | hd::tl -> \n            if hd = 0 then \n                loop tl\n            else \n                let l = loop tl\n                if hd % 2 = 0 then \n                    l@[hd/2]\n                else\n                    l\n    loop arr"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}