{"name": "HumanEval_129_minPath", "language": "fs", "prompt": "//Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once on the cells of the grid.\n// You have to find the minimum path of length k in the grid. You can start\n// from any cell, and in each step you can move to any of the neighbor cells,\n// in other words, you can go to cells which share an edge with you current\n// cell.\n// Please note that a path of length k means visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off the grid.\n// A path A (of length k) is considered less than a path B (of length k) if\n// after making the ordered lists of the values on the cells that A and B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically less\n// than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j] = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered list of the values on the cells that the minimum path go through.\n// Examples:\n// Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n// Output: [1, 2, 1]\n// Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n// Output: [1]\nlet minPath grid k = \n", "tests": "let test() = \n  let candidate = minPath\n  assert (candidate [[1; 2; 3]; [4; 5; 6]; [7; 8; 9]] 3 = [1; 2; 1])\n  assert (candidate [[5; 9; 3]; [4; 1; 6]; [7; 8; 2]] 1 = [1])\n  assert (candidate [[1; 2; 3; 4]; [5; 6; 7; 8]; [9; 10; 11; 12]; [13; 14; 15; 16]] 4 = [1; 2; 1; 2])\n  assert (candidate [[6; 4; 13; 10]; [5; 7; 12; 1]; [3; 16; 11; 15]; [8; 14; 9; 2]] 7 = [1; 10; 1; 10; 1; 10; 1])\n  assert (candidate [[8; 14; 9; 2]; [6; 4; 13; 15]; [5; 7; 1; 12]; [3; 10; 11; 16]] 5 = [1; 7; 1; 7; 1])\n  assert (candidate [[11; 8; 7; 2]; [5; 16; 14; 4]; [9; 3; 15; 6]; [12; 13; 10; 1]] 9 = [1; 6; 1; 6; 1; 6; 1; 6; 1])\n  assert (candidate [[12; 13; 10; 1]; [9; 3; 15; 6]; [5; 16; 14; 4]; [11; 8; 7; 2]] 12 = [1; 6; 1; 6; 1; 6; 1; 6; 1; 6; 1; 6])\n  assert (candidate [[2; 7; 4]; [3; 1; 5]; [6; 8; 9]] 8 = [1; 3; 1; 3; 1; 3; 1; 3])\n  assert (candidate [[6; 1; 5]; [3; 8; 9]; [2; 7; 4]] 8 = [1; 5; 1; 5; 1; 5; 1; 5])\n  assert (candidate [[1; 2]; [3; 4]] 10 = [1; 2; 1; 2; 1; 2; 1; 2; 1; 2])\n  assert (candidate [[1; 3]; [3; 2]] 10 = [1; 3; 1; 3; 1; 3; 1; 3; 1; 3])\n  0\n\ntest()", "completions": ["{\n    [1]: [1],\n    [2]: [2],\n    [3]: [3],\n    [4]: [4],\n    [5]: [5],\n    [6]: [6],\n    [7]: [7],\n    [8]: [8],\n    [9]: [9]\n}", "{\n    [1]: [1],\n    [2]: [2],\n    [3]: [3],\n    [4]: [4],\n    [5]: [5],\n    [6]: [6],\n    [7]: [7],\n    [8]: [8],\n    [9]: [9]\n}", "{\n  [1]: [1,2,3],\n  [2]: [4,5,6],\n  [3]: [7,8,9]\n}", "{\n    lst_A: [1, 2, 3],\n    lst_B: [4, 5, 6],\n    lst_A[1]: [7, 8, 9],\n    lst_B[1]: [4, 1, 6]\n}", "    [ [1,2,3], [4,5,6], [7,8,9] ]\nlet lst_A = minPath(grid, k)\nlet lst_B = minPath(grid, k)\nlet lst_C = minPath(grid, k)", "[ [1,2,3], [4,5,6], [7,8,9] ]", "{\n    [1]: [1, 2, 3],\n    [2]: [4, 5, 6],\n    [3]: [7, 8, 9]\n}", "    [ [1,2,3], [4,5,6], [7,8,9] ]", "    [ [1,2,3], [4,5,6], [7,8,9] ]\nlet lst_A = minPath(grid, k)\nlet lst_B = minPath(grid, k)\nlet lst_C = minPath(grid, k)", "{\n  lst_A: [1, 2, 1],\n  lst_B: [1, 2, 1]\n}", "{\n  [1]: [1],\n  [2]: [2],\n  [3]: [3],\n  [4]: [4],\n  [5]: [5],\n  [6]: [6],\n  [7]: [7],\n  [8]: [8],\n  [9]: [9]\n}", "[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n]", "{\n    [1]: [1],\n    [2]: [2],\n    [3]: [3],\n    [4]: [4],\n    [5]: [5],\n    [6]: [6],\n    [7]: [7],\n    [8]: [8],\n    [9]: [9]\n}", "{\n  [1]: [1, 2, 3],\n  [2]: [4, 5, 6],\n  [3]: [7, 8, 9]\n}", "    [ [1,2,3], [4,5,6], [7,8,9] ]", "{\n    [1]: [1],\n    [2]: [2],\n    [3]: [3],\n    [4]: [4],\n    [5]: [5],\n    [6]: [6],\n    [7]: [7],\n    [8]: [8],\n    [9]: [9]\n}", "    [ [1,2,3], [4,5,6], [7,8,9] ]", "{\n  [1]: [1, 2, 3],\n  [2]: [4, 5, 6],\n  [3]: [7, 8, 9]\n}", "{\n    [1]: [1],\n    [2]: [2],\n    [3]: [3],\n    [4]: [4],\n    [5]: [5],\n    [6]: [6],\n    [7]: [7],\n    [8]: [8],\n    [9]: [9]\n}", "    [ [1,2,3], [4,5,6], [7,8,9] ]\nlet lst_A = minPath(grid, k)\nlet lst_B = minPath(grid, k)\nlet lst_C = minPath(grid, k)"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}