{"name": "HumanEval_126_is_sorted", "language": "fs", "prompt": "//Given a list of numbers, return whether or not they are sorted\n// in ascending order. If list has more than 1 duplicate of the same\n// number, return False. Assume no negative numbers and only integers.\n// Examples\n// is_sorted([5]) \u00e2\u017e\u017e True\n// is_sorted([1, 2, 3, 4, 5]) \u00e2\u017e\u017e True\n// is_sorted([1, 3, 2, 4, 5]) \u00e2\u017e\u017e False\n// is_sorted([1, 2, 3, 4, 5, 6]) \u00e2\u017e\u017e True\n// is_sorted([1, 2, 3, 4, 5, 6, 7]) \u00e2\u017e\u017e True\n// is_sorted([1, 3, 2, 4, 5, 6, 7]) \u00e2\u017e\u017e False\n// is_sorted([1, 2, 2, 3, 3, 4]) \u00e2\u017e\u017e True\n// is_sorted([1, 2, 2, 2, 3, 4]) \u00e2\u017e\u017e False\nlet is_sorted lst = \n", "tests": "let test() = \n  let candidate = is_sorted\n  assert (candidate [5] = true)\n  assert (candidate [1; 2; 3; 4; 5] = true)\n  assert (candidate [1; 3; 2; 4; 5] = false)\n  assert (candidate [1; 2; 3; 4; 5; 6] = true)\n  assert (candidate [1; 2; 3; 4; 5; 6; 7] = true)\n  assert (candidate [1; 3; 2; 4; 5; 6; 7] = false)\n  assert (candidate [] = true)\n  assert (candidate [1] = true)\n  assert (candidate [3; 2; 1] = false)\n  assert (candidate [1; 2; 2; 2; 3; 4] = false)\n  assert (candidate [1; 2; 3; 3; 3; 4] = false)\n  assert (candidate [1; 2; 2; 3; 3; 4] = true)\n  assert (candidate [1; 2; 3; 4] = true)\n  0\n\ntest()", "completions": ["    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x::xs ->\n            if x = lst then acc\n            else is_sorted_rec (x::acc) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x :: xs ->\n            if x = xs.[0] then acc\n            else is_sorted_rec (acc @ [x]) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec lst = \n        match lst with\n        | [] -> false\n        | x::xs -> \n            match x with\n            | x when x = x -> true\n            | _ -> is_sorted_rec xs\n    is_sorted_rec lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x :: xs -> \n            match x with\n            | x when x = xs.[0] -> is_sorted_rec (acc @ [x]) xs\n            | x -> is_sorted_rec (acc @ [x]) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x::xs ->\n            if x = lst then acc\n            else is_sorted_rec (x::acc) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x::xs -> is_sorted_rec (acc @ [x]) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x :: xs -> \n            if x = xs.[0] then acc\n            else is_sorted_rec (acc @ [x]) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x::xs -> \n            if x = lst then acc\n            else is_sorted_rec (x::acc) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec lst = \n        match lst with\n        | [] -> false\n        | x::xs -> is_sorted_rec xs && is_sorted_rec xs\n    is_sorted_rec lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x :: xs ->\n            match x with\n            | x when x = xs.[0] -> is_sorted_rec (acc + 1) xs\n            | _ -> acc\n    is_sorted_rec 0 lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x::xs -> \n            if x = lst then acc\n            else is_sorted_rec (x::acc) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x :: xs -> \n            if x = xs.[0] then acc\n            else is_sorted_rec (acc @ [x]) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x::xs ->\n            if x = lst then acc\n            else is_sorted_rec (x::acc) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x :: xs -> if x = xs.[0] then is_sorted_rec (acc @ [x]) xs else acc\n    is_sorted_rec [] lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x :: xs ->\n            if x = xs.[0] then acc\n            else is_sorted_rec (acc @ [x]) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec lst = \n        match lst with\n        | [] -> false\n        | x::xs -> \n            if x = xs.[0] then is_sorted_rec xs\n            else is_sorted_rec xs\n    is_sorted_rec lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x::xs -> \n            if x = lst then acc\n            else is_sorted_rec (x::acc) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec lst = \n        match lst with\n        | [] -> false\n        | x::xs -> \n            if x = xs.[0] then is_sorted_rec xs\n            else is_sorted_rec xs\n    is_sorted_rec lst", "    let rec is_sorted_rec acc = function\n        | [] -> acc\n        | x::xs -> \n            if x = lst then acc\n            else is_sorted_rec (x::acc) xs\n    is_sorted_rec [] lst", "    let rec is_sorted_rec lst = \n        match lst with\n        | [] -> false\n        | x::xs -> \n            if x = xs.[0] then true\n            else is_sorted_rec xs\n    is_sorted_rec lst"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}