{"name": "HumanEval_9_rolling_max", "language": "fs", "prompt": "//From a given list of integers, generate a list of rolling maximum element found until given moment\n// in the sequence.\n// >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n// [1, 2, 3, 3, 3, 4, 4]\nlet rolling_max numbers = \n", "tests": "let test() = \n  let candidate = rolling_max\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4] = [1; 2; 3; 4])\n  assert (candidate [4; 3; 2; 1] = [4; 4; 4; 4])\n  assert (candidate [3; 2; 3; 100; 3] = [3; 3; 3; 100; 100])\n  0\n\ntest()", "completions": ["    let rec loop n = \n        if n = 0 then []\n        else \n            let max = List.max numbers\n            let new_numbers = List.take n numbers\n            let new_numbers = List.rev new_numbers\n            loop (n-1)\n    loop (numbers |> List.length)", "    let rec loop n = \n        seq {\n            if n = 0 then \n                yield []\n            else\n                let max = List.max numbers\n                yield [max]\n                yield! loop (n-1)\n        }\n    loop (List.length numbers)", "    let rec loop n = \n        if n = 0 then []\n        else \n            let max_elem = numbers |> List.max\n            let max_elem_list = numbers |> List.map (fun elem -> elem - max_elem)\n            let max_elem_list = List.rev max_elem_list\n            loop (n - 1)\n    loop numbers", "    let max_elements = List.length numbers\n    let rec loop (numbers:int list) =\n        match numbers with\n        | [] -> []\n        | head::tail ->\n            let new_max = List.max numbers\n            let new_numbers = List.tail numbers\n            loop new_numbers\n    loop numbers", "    let rec loop n = \n        if n = 0 then []\n        else \n            let max_n = List.max numbers\n            let max_n' = List.max numbers\n            if max_n = max_n' then loop (n - 1)\n            else loop (n - 1)\n    loop numbers", "    let rec loop n =\n        seq {\n            if n = 0 then\n                yield []\n            else\n                yield numbers |> List.rev |> List.take n\n                yield! loop (n - 1)\n        }\n    loop 0", "    let max = numbers |> List.max\n    let rec loop n = \n        if n <= max then n else loop (n - 1)\n    loop max", "    let rec loop n = \n        if n = 0 then []\n        else \n            let max_element = numbers |> List.max\n            let new_numbers = numbers |> List.skip (n-1)\n            loop (n-1) @ (numbers |> List.take max_element)\n    loop 0", "    let rec loop n = \n        if n = 0 then []\n        else \n            let max = numbers |> List.maxBy (fun x -> x - n)\n            let next = loop (n - 1)\n            next @ [max]\n    loop 0", "    let rec loop n = \n        seq {\n            if n = 0 then \n                yield []\n            else\n                let max = Seq.max numbers\n                yield [max]\n                yield! loop (n-1)\n        }\n    loop numbers", "    let rec loop (numbers: int list) = \n        match numbers with\n        | [] -> []\n        | head :: tail ->\n            if head > numbers.[0] then\n                let new_numbers = List.rev numbers\n                loop new_numbers\n            else\n                loop (numbers @ [head])\n    loop numbers", "    let rec loop (numbers:int list) = \n        match numbers with\n        | [] -> []\n        | x::xs -> \n            let new_numbers = \n                match x with\n                | 1 -> numbers\n                | 2 -> numbers\n                | 3 -> numbers\n                | 4 -> numbers\n                | _ -> numbers\n            loop new_numbers\n    loop numbers", "    let rec loop (numbers:int list) =\n        match numbers with\n        | [] -> []\n        | x::xs ->\n            let max_element = List.max xs\n            let new_numbers = List.map (fun y -> y + max_element) xs\n            loop new_numbers\n    loop numbers", "    let rec loop n = \n        if n = 0 then []\n        else \n            let max = List.max numbers\n            let new_numbers = List.tail numbers\n            let new_numbers = List.map (fun x -> x - max) new_numbers\n            loop (n - 1)\n    loop 0", "    let rec loop (numbers:int list) =\n        match numbers with\n        | [] -> []\n        | head::tail ->\n            let max = head\n            let new_numbers = tail |> List.map (fun n -> n + 1)\n            loop new_numbers\n    loop numbers", "    let rec loop n = \n        if n = 0 then []\n        else \n            let max_elements = List.max numbers\n            let new_numbers = List.take max_elements numbers\n            loop new_numbers\n    loop numbers", "    let rec loop n = \n        seq {\n            if n = 0 then\n                yield []\n            else\n                yield numbers\n                yield! loop (n-1)\n        }\n    loop (numbers.Length-1)", "    let rec loop (numbers:int list) =\n        match numbers with\n        | [] -> []\n        | x::xs ->\n            let max = List.max xs\n            let new_numbers = List.map (fun y -> y + max) xs\n            loop new_numbers\n    loop numbers", "    let rec loop n = \n        seq {\n            if n = 0 then\n                yield []\n            else\n                yield numbers |> Seq.take n\n                yield! loop (n - 1)\n        }\n    loop 0", "    let rec loop n = \n        if n = 0 then []\n        else \n            let max = List.max numbers\n            let new_numbers = List.take n numbers\n            loop (max + 1)\n    loop (List.length numbers)"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}