{"name": "HumanEval_119_match_parens", "language": "fs", "prompt": "//You are given a list of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nlet match_parens lst = \n", "tests": "let test() = \n  let candidate = match_parens\n  assert (candidate [\"()(\"; \")\"] = \"Yes\")\n  assert (candidate [\")\"; \")\"] = \"No\")\n  assert (candidate [\"(()(())\"; \"())())\"] = \"No\")\n  assert (candidate [\")())\"; \"(()()(\"] = \"Yes\")\n  assert (candidate [\"(())))\"; \"(()())((\"] = \"Yes\")\n  assert (candidate [\"()\"; \"())\"] = \"No\")\n  assert (candidate [\"(()(\"; \"()))()\"] = \"Yes\")\n  assert (candidate [\"((((\"; \"((())\"] = \"No\")\n  assert (candidate [\")(()\"; \"(()(\"] = \"No\")\n  assert (candidate [\")(\"; \")(\"] = \"No\")\n  assert (candidate [\"(\"; \")\"] = \"Yes\")\n  assert (candidate [\")\"; \"(\"] = \"Yes\")\n  0\n\ntest()", "completions": ["    let rec match_parens' acc = function\n        | [] -> acc\n        | (x::xs) -> match_parens' (x::acc) xs\n    match_parens' [] lst", "    let rec match_parens' lst = \n        match lst with\n        | [] -> 'No'\n        | head::tail -> match_parens' tail\n    match_parens' lst", "    let rec match_parens' acc = function\n        | [] -> acc\n        | (x::xs) -> match_parens' (x::acc) xs\n    match_parens' [] lst", "    let rec match_parens_rec acc lst =\n        match lst with\n        | [] -> acc\n        | (x::xs) -> match_parens_rec (x::acc) xs\n    match_parens_rec [] lst", "    let rec match_parens' lst = \n        match lst with\n        | [] -> 'No'\n        | head::tail -> match_parens' tail\n    match_parens' lst", "    let rec match_parens' acc lst = \n        match lst with\n        | [] -> acc\n        | (x::xs) -> match_parens' (x::acc) xs\n    match_parens' [] lst", "    match lst with\n    | [] -> \"No\"\n    | x::xs -> match x with\n                | '(' -> \"Yes\"\n                | ')' -> \"No\"\n                | _ -> \"No\"", "    let rec loop acc = function\n        | [] -> acc\n        | (x::xs) -> \n            if x = '(' then loop (x::acc) xs\n            else loop (x::acc) xs\n    loop [] lst", "    let rec match_parens' acc lst = \n        match lst with\n        | [] -> acc\n        | (x::xs) -> match_parens' (x::acc) xs\n    match_parens' [] lst", "    let rec match_parens_rec acc lst = \n        match lst with\n        | [] -> acc\n        | (x, y)::tail -> match_parens_rec (x::acc) tail\n    match_parens_rec [] lst", "    let rec match_parens' acc lst = \n        match lst with\n        | [] -> acc\n        | (p1, p2)::tl -> match_parens' (p1::acc) tl\n    match_parens' [] lst", "    let rec loop acc = function\n        | [] -> acc\n        | (x::xs) ->\n            match x with\n            | '(' -> loop (acc + \"(\" + x + \")\" :: acc) xs\n            | ')' -> loop (acc + \")\" xs\n            | _ -> acc\n    loop \"\" lst", "    let rec match_parens' lst = \n        match lst with\n        | [] -> 'No'\n        | (x::xs) -> \n            match_parens' xs\n    match_parens' lst", "    let rec match_parens' acc lst =\n        match lst with\n        | [] -> acc\n        | (x::xs) -> match_parens' (x::acc) xs\n    match_parens' [] lst", "    let rec match_parens_rec acc lst = \n        match lst with\n        | [] -> acc\n        | (x, y) :: tail -> match_parens_rec (x :: acc) tail\n    match_parens_rec [] lst", "    let rec match_parens' acc lst = \n        match lst with\n        | [] -> acc\n        | (x::xs) -> match_parens' (x::acc) xs\n    match_parens' [] lst", "    match lst with\n    | [] -> \"No\"\n    | (x::xs) ->\n        match x with\n        | '(' -> \"Yes\"\n        | ')' -> \"No\"\n        | _ -> \"No\"", "    let rec loop acc = function\n        | [] -> acc\n        | (x::xs) ->\n            if x = '(' then loop (acc + \"(\" + xs) xs\n            elif x = ')' then loop (acc + \")\" xs) xs\n            else loop (acc + xs) xs\n    loop \"\" lst", "    let rec match_parens_rec acc lst =\n        match lst with\n        | [] -> acc\n        | (x::xs) -> match_parens_rec (acc + x) xs\n    match_parens_rec 0 lst with\n    | 'Yes' -> true\n    | 'No' -> false\n    | _ -> false", "    let rec match_parens' acc lst =\n        match lst with\n        | [] -> acc\n        | (x::xs) -> match_parens' (x::acc) xs\n    match_parens' [] lst"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}