{"name": "HumanEval_98_count_upper", "language": "fs", "prompt": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n", "tests": "let test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()", "completions": ["    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if Char.IsUpper s.[i] then\n            count <- count + 1\n    count", "    let mutable i = 0\n    let mutable count = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n        count <- count + 1\n    count", "    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if Char.IsUpper s.[i] then\n            count <- count + 1\n    count", "    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if Char.IsUpper s.[i] then\n            count <- count + 1\n    count", "    let rec count_upper_i s = \n        match s with\n        | 'a' -> 1\n        | 'b' -> 1\n        | 'c' -> 1\n        | 'd' -> 1\n        | 'e' -> 1\n        | 'f' -> 1\n        | 'g' -> 1\n        | 'h' -> 1\n        | 'i' -> 1\n        | 'j' -> 1\n        | 'k' -> 1\n        | 'l' -> 1\n        | 'm' -> 1\n        | 'n' -> 1\n        | 'o' -> 1\n        | 'p' -> 1\n        | 'q' -> 1\n        | 'r' -> 1\n        | 's' -> 1\n        | 't' -> 1\n        | 'u' -> 1\n        | 'v' -> 1\n        | 'w' -> 1\n        | 'x' -> 1\n        | 'y' -> 1\n        | 'z' -> 1\n        | _ -> 0\n    count_upper_i s", "    let mutable i = 0\n    let mutable count = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n        count <- count + 1\n    count", "    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if s.[i] = 'A' || s.[i] = 'E' || s.[i] = 'I' || s.[i] = 'O' || s.[i] = 'U' || s.[i] = 'Y' || s.[i] = 'Z' || s.[i] = 'a' || s.[i] = 'e' || s.[i] = 'i' || s.[i] = 'o' || s.[i] = 'u' || s.[i] = 'y' || s.[i] = 'z' || s.[i] = 'A' || s.[i] = 'E' || s.[i] = 'I' || s.[i] = 'O' || s.[i] = 'U' || s.[i] = 'Y' || s.[i] = 'Z' || s.[i] = 'a' || s.[i] = 'e' || s.[i] = 'i' || s.[i] = 'o' || s.[i] = 'u' || s.[i] = 'y' || s.[i] = 'z' then\n            count <- count + 1\n    count", "    let rec count_upper_i s = \n        match s with\n        | 'A' -> 1\n        | 'B' -> 1\n        | 'C' -> 1\n        | 'D' -> 1\n        | 'E' -> 1\n        | 'F' -> 1\n        | 'G' -> 1\n        | 'H' -> 1\n        | 'I' -> 1\n        | 'J' -> 1\n        | 'K' -> 1\n        | 'L' -> 1\n        | 'M' -> 1\n        | 'N' -> 1\n        | 'O' -> 1\n        | 'P' -> 1\n        | 'Q' -> 1\n        | 'R' -> 1\n        | 'S' -> 1\n        | 'T' -> 1\n        | 'U' -> 1\n        | 'V' -> 1\n        | 'W' -> 1\n        | 'X' -> 1\n        | 'Y' -> 1\n        | 'Z' -> 1\n        | _ -> 0\n    count_upper_i s", "    let rec count_upper_i acc = \n        match s with\n        | 'a' -> acc + 1\n        | 'b' -> acc + 1\n        | 'c' -> acc + 1\n        | 'd' -> acc + 1\n        | 'e' -> acc + 1\n        | 'f' -> acc + 1\n        | 'g' -> acc + 1\n        | 'h' -> acc + 1\n        | 'i' -> acc + 1\n        | 'j' -> acc + 1\n        | 'k' -> acc + 1\n        | 'l' -> acc + 1\n        | 'm' -> acc + 1\n        | 'n' -> acc + 1\n        | 'o' -> acc + 1\n        | 'p' -> acc + 1\n        | 'q' -> acc + 1\n        | 'r' -> acc + 1\n        | 's' -> acc + 1\n        | 't' -> acc + 1\n        | 'u' -> acc + 1\n        | 'v' -> acc + 1\n        | 'w' -> acc + 1\n        | 'x' -> acc + 1\n        | 'y' -> acc + 1\n        | 'z' -> acc + 1\n        | _ -> acc\n    count_upper_i 0", "    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if Char.IsUpper s.[i] then\n            count <- count + 1\n    count", "    let rec count_upper_i i =\n        if i = s.Length then 0\n        else count_upper_i (i + 1)\n    count_upper_i 0", "    let rec count_upper_i acc = \n        match s with\n        | 'a' -> acc + 1\n        | 'b' -> acc + 1\n        | 'c' -> acc + 1\n        | 'd' -> acc + 1\n        | 'e' -> acc + 1\n        | 'f' -> acc + 1\n        | 'g' -> acc + 1\n        | 'h' -> acc + 1\n        | 'i' -> acc + 1\n        | 'j' -> acc + 1\n        | 'k' -> acc + 1\n        | 'l' -> acc + 1\n        | 'm' -> acc + 1\n        | 'n' -> acc + 1\n        | 'o' -> acc + 1\n        | 'p' -> acc + 1\n        | 'q' -> acc + 1\n        | 'r' -> acc + 1\n        | 's' -> acc + 1\n        | 't' -> acc + 1\n        | 'u' -> acc + 1\n        | 'v' -> acc + 1\n        | 'w' -> acc + 1\n        | 'x' -> acc + 1\n        | 'y' -> acc + 1\n        | 'z' -> acc + 1\n        | _ -> acc\n    count_upper_i 0", "    let mutable i = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n    i", "    let mutable i = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n    i", "    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if s.[i] = 'A' || s.[i] = 'B' || s.[i] = 'C' || s.[i] = 'D' || s.[i] = 'E' || s.[i] = 'F' || s.[i] = 'G' || s.[i] = 'H' || s.[i] = 'I' || s.[i] = 'J' || s.[i] = 'K' || s.[i] = 'L' || s.[i] = 'M' || s.[i] = 'N' || s.[i] = 'O' || s.[i] = 'P' || s.[i] = 'Q' || s.[i] = 'R' || s.[i] = 'S' || s.[i] = 'T' || s.[i] = 'U' || s.[i] = 'V' || s.[i] = 'W' || s.[i] = 'X' || s.[i] = 'Y' || s.[i] = 'Z' then\n            count <- count + 1\n    count", "    let mutable i = 0\n    let mutable count = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n        count <- count + 1\n    count", "    let rec count_upper_i acc i = \n        if i = 0 then acc\n        else count_upper_i (acc + 1) (i - 1)\n    count_upper_i 0 s", "    let rec count_upper_i s =\n        match s with\n        | 'a' -> 1\n        | 'b' -> 1\n        | 'c' -> 1\n        | 'd' -> 1\n        | 'e' -> 1\n        | 'f' -> 1\n        | 'g' -> 1\n        | 'h' -> 1\n        | 'i' -> 1\n        | 'j' -> 1\n        | 'k' -> 1\n        | 'l' -> 1\n        | 'm' -> 1\n        | 'n' -> 1\n        | 'o' -> 1\n        | 'p' -> 1\n        | 'q' -> 1\n        | 'r' -> 1\n        | 's' -> 1\n        | 't' -> 1\n        | 'u' -> 1\n        | 'v' -> 1\n        | 'w' -> 1\n        | 'x' -> 1\n        | 'y' -> 1\n        | 'z' -> 1\n        | _ -> 0\n    count_upper_i s", "    let rec count_upper_i s i = \n        if i = 0 then 0\n        else count_upper_i s (i-1)\n    count_upper_i s 0", "    let rec count_upper_i i =\n        if i = s.Length then 0\n        else count_upper_i (i+1)\n    count_upper_i 0"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}