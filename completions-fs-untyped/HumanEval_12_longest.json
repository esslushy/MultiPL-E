{"name": "HumanEval_12_longest", "language": "fs", "prompt": "//Out of list of strings, return the longest one. Return the first one in case of multiple\n// strings of the same length. Return None in case the input list is empty.\n// >>> longest([])\n// >>> longest(['a', 'b', 'c'])\n// 'a'\n// >>> longest(['a', 'bb', 'ccc'])\n// 'ccc'\nlet longest strings = \n", "tests": "let test() = \n  let candidate = longest\n  assert (candidate [] = None)\n  assert (candidate [\"x\"; \"y\"; \"z\"] = \"x\")\n  assert (candidate [\"x\"; \"yyy\"; \"zzzz\"; \"www\"; \"kkkk\"; \"abc\"] = \"zzzz\")\n  0\n\ntest()", "completions": ["    let rec loop (acc:string list) (acc2:string list) =\n        match acc, acc2 with\n        | [], [] -> acc\n        | _, [] -> acc2\n        | _, _ -> loop (acc@acc2) (acc@acc2)\n    loop [] []", "    let rec loop acc = function\n        | [] -> Some acc\n        | x::xs -> \n            match loop (x::acc) xs with\n            | Some y -> Some (y::acc)\n            | None -> None\n    loop [] strings", "    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] strings", "    let rec longest' strings = \n        match strings with \n        | [] -> None\n        | head :: tail -> \n            if head.Length > longest' tail then\n                longest' tail\n            else\n                longest' (head :: longest')\n    longest' strings", "    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] strings", "    let rec longest' strings =\n        match strings with\n        | [] -> None\n        | x::xs ->\n            match longest' xs with\n            | None -> longest' xs\n            | Some y -> Some (y, x)\n    longest' strings", "    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> \n            match x with\n            | 'a' -> loop (acc + x) xs\n            | 'b' -> loop (acc + x) xs\n            | 'c' -> loop (acc + x) xs\n            | _ -> loop (acc + x) xs\n    loop 0 strings", "    let rec loop acc = function\n        | [] -> acc\n        | x::xs ->\n            match x with\n            | 'a' -> loop (acc + x) xs\n            | 'b' -> loop (acc + x) xs\n            | 'c' -> loop (acc + x) xs\n            | _ -> loop (acc + x) xs\n    loop \"\" strings", "    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] strings", "    let rec loop acc = function\n        | [] -> acc\n        | x :: xs -> \n            if List.length xs > List.length acc then\n                loop (x :: acc) xs\n            else\n                loop (x :: acc) xs\n    loop [] strings", "    let rec longest' (strings: string list) = \n        match strings with \n        | [] -> None\n        | head :: tail -> \n            if head.Length > longest' tail then\n                head\n            else\n                longest' tail\n    longest' strings", "    let rec longest' (strings:string list) =\n        match strings with\n        | [] -> None\n        | head::tail ->\n            if head.Length > 0 then\n                let head' = head.Trim()\n                if head'.Length > 0 then\n                    let tail' = tail |> List.map (fun s -> s.Trim())\n                    if head'.Length > 0 && head'.Length <> tail'.Length then\n                        let head'' = head'.Trim()\n                        if head''.Length > 0 then\n                            if head''.Length <> tail'.Length then\n                                longest' tail'\n                            else\n                                longest' tail'\n                        else\n                            if head''.Length <> tail'.Length then\n                                longest' tail'\n                            else\n                                longest' tail'\n                    else\n                        if head'.Length <> tail'.Length then\n                            longest' tail'\n                        else\n                            longest' tail'\n                else\n                    longest' tail\n            else\n                longest' tail\n    longest' strings", "    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] strings", "    let rec loop acc = function\n        | [] -> acc\n        | x :: xs -> \n            match x with\n            | 'a' -> loop (acc + \"a\") xs\n            | 'b' -> loop (acc + \"b\") xs\n            | 'c' -> loop (acc + \"c\") xs\n            | _ -> loop (acc + x.ToString()) xs\n    loop \"\" strings", "    let rec longest (strings: string list) =\n        match strings with\n        | [] -> None\n        | head::tail ->\n            match head with\n            | ' ' -> longest tail\n            | '\\t' -> longest tail\n            | '\\n' -> longest tail\n            | '\\r' -> longest tail\n            | '\\r' -> longest tail\n            | _ -> longest tail\n    \n    longest strings", "    let rec longest (strings: string list) =\n        match strings with\n        | [] -> None\n        | head :: tail ->\n            if head.Length > 0 then\n                if head.Length = 1 then\n                    Some(head)\n                else\n                    let first = head.Substring(0, 1)\n                    let second = head.Substring(1)\n                    if first = second then\n                        longest tail\n                    else\n                        longest (first :: tail)\n            else\n                longest tail\n    longest strings", "    let rec loop acc = function\n        | [] -> acc\n        | x :: xs -> loop (x :: acc) xs\n    loop [] strings", "    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] strings", "    let rec longest (strings: string list) =\n        match strings with\n        | [] -> None\n        | head::tail ->\n            let len = head.Length\n            if len > 0 then\n                let first = head.[0]\n                if first = ' ' then\n                    let rest = longest tail\n                    if rest = None then None else Some(first, rest)\n                else\n                    let rest = longest tail\n                    if rest = None then None else Some(first, rest)\n            else\n                None\n    longest strings", "    let rec loop acc = function\n        | [] -> Some acc\n        | x::xs -> \n            match x with\n            | 'a' -> loop (acc + \"a\") xs\n            | 'b' -> loop (acc + \"b\") xs\n            | 'c' -> loop (acc + \"c\") xs\n            | _ -> loop (acc + x.ToString()) xs\n    loop \"\" strings"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}