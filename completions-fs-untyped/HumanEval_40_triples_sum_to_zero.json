{"name": "HumanEval_40_triples_sum_to_zero", "language": "fs", "prompt": "//triples_sum_to_zero takes a list of integers as an input.\n// it returns True if there are three distinct elements in the list that\n// sum to zero, and False otherwise.\n// >>> triples_sum_to_zero([1, 3, 5, 0])\n// False\n// >>> triples_sum_to_zero([1, 3, -2, 1])\n// True\n// >>> triples_sum_to_zero([1, 2, 3, 7])\n// False\n// >>> triples_sum_to_zero([2, 4, -5, 3, 9, 7])\n// True\n// >>> triples_sum_to_zero([1])\n// False\nlet triples_sum_to_zero l = \n", "tests": "let test() = \n  let candidate = triples_sum_to_zero\n  assert (candidate [1; 3; 5; 0] = false)\n  assert (candidate [1; 3; 5; -1] = false)\n  assert (candidate [1; 3; -2; 1] = true)\n  assert (candidate [1; 2; 3; 7] = false)\n  assert (candidate [1; 2; 5; 7] = false)\n  assert (candidate [2; 4; -5; 3; 9; 7] = true)\n  assert (candidate [1] = false)\n  assert (candidate [1; 3; 5; -100] = false)\n  assert (candidate [100; 3; 5; -100] = false)\n  0\n\ntest()", "completions": ["    let rec sum_to_zero_rec acc l = \n        match l with \n        | [] -> acc\n        | x::xs -> sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_rec acc = \n        match l with \n        | [] -> acc\n        | (x, y)::xs -> \n            if x = y then acc\n            else sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec loop acc = function\n        | [] -> acc\n        | (x, y)::xs -> loop (acc + x + y) xs\n    loop 0 l", "    let rec sum_to_zero_rec acc = \n        match l with\n        | [] -> acc\n        | x::xs -> \n            let acc' = acc + x\n            sum_to_zero_rec acc'\n    sum_to_zero_rec 0", "    let rec sum_to_zero_rec acc = function\n        | [] -> acc\n        | x :: xs -> sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_rec acc = function\n        | [] -> acc\n        | x::xs -> sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_rec acc = function\n        | [] -> acc\n        | x :: xs -> sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_rec acc l = \n        match l with \n        | [] -> acc\n        | hd::tl -> sum_to_zero_rec (acc + hd) tl\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_rec acc = function\n        | [] -> acc\n        | x::xs -> sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_rec acc l = \n        match l with \n        | [] -> acc\n        | x::xs -> \n            if x = 0 then sum_to_zero_rec acc xs\n            else sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_rec acc = function\n        | [] -> acc\n        | x :: xs -> sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec loop acc = \n        match l with\n        | [] -> acc\n        | x::xs -> \n            if x = 0 then loop (acc + 1)\n            else loop (acc + x)\n    loop 0", "    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> loop (acc + x) xs\n    loop 0 l", "    let rec sum_to_zero_rec acc =\n        match l with\n        | [] -> acc\n        | (x, y) :: t -> sum_to_zero_rec (acc + x + y) t\n    sum_to_zero_rec 0 l", "    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> loop (acc + x) xs\n    loop 0 l", "    let rec sum_to_zero_rec acc =\n        match l with\n        | [] -> acc\n        | x::xs ->\n            match x with\n            | x when x = 0 -> acc\n            | x -> sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_rec acc =\n        match l with\n        | [] -> acc\n        | x::xs -> sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_rec acc l = \n        match l with \n        | [] -> acc\n        | x::xs -> sum_to_zero_rec (acc + x) xs\n    sum_to_zero_rec 0 l", "    let rec sum_to_zero_loop acc l =\n        match l with\n        | [] -> acc\n        | x::xs -> sum_to_zero_loop (acc + x) xs\n    sum_to_zero_loop 0 l", "    let rec loop acc = function\n        | [] -> acc\n        | x :: xs -> loop (acc + x) xs\n    loop 0 l"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}