{"name": "HumanEval_149_sorted_list_sum", "language": "fs", "prompt": "//Write a function that accepts a list of strings as a parameter,\n// deletes the strings that have odd lengths from it,\n// and returns the resulted list with a sorted order,\n// The list is always a list of strings and never an array of numbers,\n// and it may contain duplicates.\n// The order of the list should be ascending by length of each word, and you\n// should return the list sorted by that rule.\n// If two words have the same length, sort the list alphabetically.\n// The function should return a list of strings in sorted order.\n// You may assume that all words will have the same length.\n// For example:\n// assert list_sort([\"aa\", \"a\", \"aaa\"]) => [\"aa\"]\n// assert list_sort([\"ab\", \"a\", \"aaa\", \"cd\"]) => [\"ab\", \"cd\"]\nlet sorted_list_sum (lst: string list): string list  = \n", "tests": "let test() = \n  let candidate = sorted_list_sum\n  assert (candidate [\"aa\"; \"a\"; \"aaa\"] = [\"aa\"])\n  assert (candidate [\"school\"; \"AI\"; \"asdf\"; \"b\"] = [\"AI\"; \"asdf\"; \"school\"])\n  assert (candidate [\"d\"; \"b\"; \"c\"; \"a\"] = [])\n  assert (candidate [\"d\"; \"dcba\"; \"abcd\"; \"a\"] = [\"abcd\"; \"dcba\"])\n  assert (candidate [\"AI\"; \"ai\"; \"au\"] = [\"AI\"; \"ai\"; \"au\"])\n  assert (candidate [\"a\"; \"b\"; \"b\"; \"c\"; \"c\"; \"a\"] = [])\n  assert (candidate [\"aaaa\"; \"bbbb\"; \"dd\"; \"cc\"] = [\"cc\"; \"dd\"; \"aaaa\"; \"bbbb\"])\n  0\n\ntest()", "completions": ["  lst.map(str => str.length % 2 == 1 ? str : str.substring(0, str.length / 2));", "  lst.map(s => s.length % 2 ? s : s.slice(0, s.length / 2))", "  lst.map(s => s.length).reduce((a, b) => a + b);", "  lst.sort().reverse().map(s => s.toLowerCase()).join('');", "  lst.map(str => str.length % 2 == 0 ? str : str.substring(0, str.length / 2));", "  lst.sort().map(s => s.toLowerCase());", "  lst.sort().reverse().map((x: string) => x).map(x => x.toUpperCase()).join('');", "  lst.sort().reverse().map(str => str + \" \" + str).join(\" \");", "  lst.map(str => str.length % 2 == 1 ? str : str.substring(0, str.length / 2));", "  lst.sort().map(s => s.toLowerCase());", "  lst.sort().reverse().map(s => s.toLowerCase()).map(s => s.toUpperCase());", "  lst.sort();", "  lst.sort().reverse().map(s => s + s).reverse().map(s => s).reverse().map(s => s);", "  lst.sort().map(s => s.toUpperCase()).reverse().map(s => s);", "  lst.sort();", "  lst.sort().map(s => s.toUpperCase()).reverse().map(s => s.toUpperCase());", "  lst.sort();", "  lst.sort().reverse().map(s => s.toLowerCase());", "  lst.map(s => s.length % 2 == 1 ? s : s.slice(0, s.length / 2))", "  lst.map(s => s.toLowerCase()).sort().reverse();"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}