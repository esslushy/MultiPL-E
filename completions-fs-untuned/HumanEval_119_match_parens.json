{"name": "HumanEval_119_match_parens", "language": "fs", "prompt": "//You are given a list of two strings, both strings consist of open\n// parentheses '(' or close parentheses ')' only.\n// Your job is to check if it is possible to concatenate the two strings in\n// some order, that the resulting string will be good.\n// A string S is considered to be good if and only if all parentheses in S\n// are balanced. For example: the string '(())()' is good, while the string\n// '())' is not.\n// Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n// Examples:\n// match_parens(['()(', ')']) == 'Yes'\n// match_parens([')', ')']) == 'No'\nlet match_parens (lst: string list): string  = \n", "tests": "let test() = \n  let candidate = match_parens\n  assert (candidate [\"()(\"; \")\"] = \"Yes\")\n  assert (candidate [\")\"; \")\"] = \"No\")\n  assert (candidate [\"(()(())\"; \"())())\"] = \"No\")\n  assert (candidate [\")())\"; \"(()()(\"] = \"Yes\")\n  assert (candidate [\"(())))\"; \"(()())((\"] = \"Yes\")\n  assert (candidate [\"()\"; \"())\"] = \"No\")\n  assert (candidate [\"(()(\"; \"()))()\"] = \"Yes\")\n  assert (candidate [\"((((\"; \"((())\"] = \"No\")\n  assert (candidate [\")(()\"; \"(()(\"] = \"No\")\n  assert (candidate [\")(\"; \")(\"] = \"No\")\n  assert (candidate [\"(\"; \")\"] = \"Yes\")\n  assert (candidate [\")\"; \"(\"] = \"Yes\")\n  0\n\ntest()", "completions": ["    lst.map(s => s.replace(/\\(/g, '(')).replace(/\\)/g, ')')", "    lst.map(s => s.replace(/\\(/g, '()').replace(/\\)/g, ')')\n    .filter(s => s.length > 1)\n    .join('');", "    lst.map(s => s.replace(/\\(/g, '())').replace(/\\)/g, ')')", "  lst.map(s => s.replace(/\\(/g, '())').replace(/\\)/g, ')')", "  lst.map(s => s.replace(/\\(/g, '(')).replace(/\\)/g, ')')", "  lst.map(s => s.replace(/\\(/g, '(')).replace(/\\)/g, ')')\nlet is_good_string: boolean = match_parens(lst)", "    lst.map(s => s.replace(/\\(/g, '(')).replace(/\\)/g, ')')\n    .map(s => s.replace(/\\)/g, ')')\n    .filter(s => s.length > 1)\n    .reduce((a, b) => a + b, '')\n    .join('')", "    lst.map(s => s.replace(/\\(/, '').replace(/\\)/, ''))", "    lst.map(s => s.replace(/\\(/g, '(')).replace(/\\)/g, ')')", "  lst.map(s => s.replace(/\\(/, '').replace(/\\)/, ''))", "  lst.map(p => p.replace(/\\(/g, '(')).replace(/\\)/g, ')')", "  lst.map(s => s.replace(/\\(/g, '(')).replace(/\\)/g, ')')\n  .filter(s => s.length > 1)\n  .map(s => s.substring(1))\n  .join('')", "    lst.map(s => s.replace(/\\(/g, '(')).replace(/\\)/g, ')')\n    .map(s => s.replace(/\\(/g, '(')).replace(/\\)/g, ')')\n    .join('')", "  lst.map((s: string) => s.replace(/\\(/g, '(')).replace(/\\)/g, ')')", "  lst.map((s: string) => s.replace(/\\(/g, '((').replace(/\\)/g, ')'))\n  .map((s: string) => s.replace(/\\)/g, ')'))", "    lst.map(s => s.match(/^\\(/))\n    .filter(s => s.length > 1)\n    .map(s => s.substring(1, s.length - 1))\n    .join('');", "  lst.map(str => str.replace(/\\(/g, '(')).replace(/\\)/g, ')')", "  lst.map(s => s.replace(/\\(/g, '((')).map(s => s.replace(/\\)/g, ')'))", "  lst.map((s: string) => s.replace(/\\(/g, '((').replace(/\\)/g, ')')).join(' ')", "  lst.map(s => s.replace(/\\(/g, '()')).map(s => s.replace(/\\)/g, ')')"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}