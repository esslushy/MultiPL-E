{"name": "HumanEval_158_find_max", "language": "fs", "prompt": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n", "tests": "let test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()", "completions": ["  words.find(word => word.length > 1)", "  words.reduce((max, word) => max + word.length, 0)", "    words.find_max(\n        (word: string) => word.length > 1\n    );", "  words.find_max(\n    (word: string) => word.length,\n    (word: string) => word.length\n  )", "  words.find(word => word.length > 1)", "  words.find(word => word.length > 1);", "    words.find(word => word.length > 1)", "  words.find(word => word.length > 1)", "  words.find(word => word.length > 1);", "  words.find_max(\n    (word: string) => word.length,\n    (word: string) => word.length\n  );", "  words.map(word => word.toLowerCase()).reduce((max, word) => max + word.length);", "  words.find(word => word.length > 1)\n  .map(word => word.toLowerCase())\n  .reduce((max, word) => max + word.length)", "  words.reduce((max, word) => max + word.length, 0);", "  words.find(word => word.length > 1);", "  words.find(word => word.length > 1)", "  words.reduce((max, word) => max + word.length, 0)", "    find_max(words.split(\" \"));", "  words.find(word => word.length > 1)", "  words.find(word => word.length > 1);", "  words.find(word => word.length > 1)"], "stop_tokens": ["\n(*", "\n//", "\ntype", "\n\n"]}