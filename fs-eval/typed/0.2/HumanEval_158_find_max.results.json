{
  "name": "HumanEval_158_find_max",
  "language": "fs",
  "prompt": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n",
  "tests": "let test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (words: string list) (acc: string) = \n        match words with\n        | [] -> acc\n        | head::tail ->\n            if acc.Length > 0 then\n                let max_acc = find_max_rec tail acc\n                if head.Length > max_acc.Length then\n                    acc + head\n                else\n                    acc + head + \" \" + find_max_rec tail acc\n            else\n                acc + head\n    find_max_rec words \"\"\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (acc: string) (words: string list) = \n        match words with\n        | [] -> acc\n        | w::ws -> \n            let acc = w::acc\n            let rec find_max_rec_rec acc ws = \n                match ws with\n                | [] -> acc\n                | w::ws -> \n                    let acc = w::acc\n                    find_max_rec_rec acc ws\n            find_max_rec_rec acc ws\n    find_max_rec \"\" words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvty7oh4l.fsx(13,26): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (words: string list) = \n        match words with\n        | [] -> \"\"\n        | x::xs -> \n            let max_char = List.max xs\n            if max_char = x then \n                find_max_rec xs\n            else\n                let new_max_char = max_char + 1\n                if new_max_char = x then \n                    find_max_rec xs\n                else\n                    find_max_rec (List.skip max_char xs)\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphrvhcfbe.fsx(17,47): error FS0001: The type 'int' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (acc: string) (acc_max: string) (words: string list) = \n        match words with \n        | [] -> acc\n        | word::rest -> \n            let new_acc = acc + word\n            if acc_max.Length = 0 then new_acc\n            else find_max_rec new_acc acc_max rest\n    find_max_rec \"\" \"\" words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max (words: string list) = \n        match words with\n        | [] -> \"\"\n        | head::tail ->\n            let max_char = List.max(head.ToCharArray())\n            if max_char <> head.Length then\n                find_max tail\n            else\n                head.Substring(0, max_char)\n    find_max words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzhy3bhfj.fsx(13,37): error FS0193: Type constraint mismatch. The type \n    'char[]'    \nis not compatible with type\n    ''a list'    \n\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (words: string list) (acc: string) = \n        match words with\n        | [] -> acc\n        | x::xs -> \n            let acc' = x.ToCharArray() |> Array.max\n            if acc' = x then find_max_rec xs acc'\n            else find_max_rec xs (acc' + x.ToCharArray())\n    find_max_rec words \"\"\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphw0uums2.fsx(14,23): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let mutable max = 0\n    for word in words do\n        let mutable i = 0\n        while i < word.Length do\n            if word.[i] = word.[max] then\n                max <- i\n            i <- i + 1\n    max\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpl4eluy3k.fsx(16,5): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (words: string list) (acc: string) =\n        match words with\n        | [] -> acc\n        | head::tail ->\n            if head.Length > acc.Length then\n                find_max_rec tail (acc.Substring(0, acc.Length-head.Length))\n            else\n                find_max_rec tail (acc.Substring(0, acc.Length-head.Length)) + head\n    find_max_rec words \"\"\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476801,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (words: string list) (acc: string) = \n        match words with \n        | [] -> acc\n        | word::rest -> \n            if acc.Length > 0 then \n                let max_acc = acc.[0]\n                let max_acc_len = acc.Length\n                if max_acc_len > max_acc.Length then\n                    let max_acc_len = max_acc_len\n                    let max_acc = acc.[0]\n                    let max_acc_len = max_acc_len\n                    if max_acc_len > max_acc.Length then\n                        let max_acc_len = max_acc_len\n                        let max_acc = acc.[0]\n                        let max_acc_len = max_acc_len\n                        if max_acc_len > max_acc.Length then\n                            let max_acc_len = max_acc_len\n                            let max_acc = acc.[0]\n                            let max_acc_len = max_acc_len\n                            if max_acc_len > max_acc.Length then\n                                let max_acc_len = max_acc_len\n                                let max_acc = acc.[0]\n                                let max_acc_len = max_acc_len\n                                if max_acc_len > max_acc.Length then\n                                    let max_acc_len = max_acc_len\n                                    let max_acc = acc.[0]\n                                    let max_acc_len = max_acc_len\n                                    if max_acc_len > max_acc.Length then\n                                        let max_acc_len = max_acc_len\n                                        let max_acc = acc.[0]\n                                        let max_acc_len = max_acc_len\n                                        if max_acc_len > max_acc.Length then\n                                            let max_acc_len = max_acc_len\n                                            let max_acc = acc.[0]\n                                            let max_acc_len = max_acc_len\n                                            if max_acc_len > max_acc.Length then\n                                                let max_acc_len = max_acc_len\n                                                let max_acc = acc.[0]\n                                                let max_\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2c8pc2ws.fsx(48,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (words: string list) (acc: string) = \n        match words with\n        | [] -> acc\n        | x::xs -> \n            let acc' = x.ToCharArray() |> Array.max\n            if acc' = acc then acc'\n            else find_max_rec xs (acc' + \" \")\n    find_max_rec words \"\"\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpb5w8ig3i.fsx(14,23): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (acc: string) (acc_len: int) (words: string list): string =\n        match words with\n        | [] -> acc\n        | h::t ->\n            if acc_len = 0 then\n                acc\n            else\n                let acc' = h::acc\n                find_max_rec acc' (acc_len-1) t\n    find_max_rec \"\" 0 words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpiufjinri.fsx(16,31): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (words: string list) (acc: string) = \n        match words with\n        | [] -> acc\n        | x::xs -> \n            let max_acc = x\n            let rec find_max_rec_rec acc = \n                match acc with\n                | \"\" -> acc\n                | x::xs -> \n                    let max_acc = x\n                    if x.Length > max_acc.Length then\n                        find_max_rec_rec (x::acc) (x.Substring(0, max_acc.Length))\n                    else\n                        find_max_rec_rec (x::acc) (x.Substring(max_acc.Length))\n            find_max_rec_rec acc\n    find_max_rec words \"\"\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy3fhfbmo.fsx(17,19): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max (words: string list) = \n        match words with\n        | [] -> \"\"\n        | head::tail -> \n            let max_char = List.max words\n            let max_char_str = List.map (fun word -> word.ToString()) words\n            if head.Length = max_char then\n                max_char_str\n            else\n                find_max tail\n    find_max words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpadrd10nt.fsx(15,30): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (acc: string) (words: string list) = \n        match words with\n        | [] -> acc\n        | word :: rest -> \n            if acc.Length > word.Length then \n                find_max_rec acc rest\n            else\n                acc + word\n    find_max_rec \"\" words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let mutable max = 0\n    for word in words do\n        let mutable i = 0\n        while i < word.Length do\n            if word.[i] = word.[i-1] then\n                i <- i + 1\n            else\n                max <- max + 1\n                i <- i - 1\n    max\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1v8doc7a.fsx(18,5): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max_rec (acc: string) (acc_len: int) (words: string list): string = \n        match words with\n        | [] -> acc\n        | head::tail ->\n            let new_acc = head.ToCharArray()\n            if new_acc.Length > acc_len then\n                find_max_rec acc_len (new_acc.Length - 1) tail\n            else\n                find_max_rec acc_len (new_acc.Length + 1) tail\n    find_max_rec \"\" 0 words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7n50sx0x.fsx(15,30): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let mutable max_index = 0\n    let mutable max_value = \"\"\n    for word in words do\n        if (max_index = -1) then\n            max_index <- max_index + 1\n        if (max_value = word) then\n            max_value <- word\n        else\n            max_index <- max_index + 1\n    max_value\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max (words: string list) = \n        match words with\n        | [] -> \"\"\n        | head::tail -> \n            let max_num = List.max(List.map (fun word -> List.length word) words)\n            if max_num = List.length words then\n                head\n            else\n                find_max tail\n    find_max words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3oliex00.fsx(13,76): error FS0001: The type ''a list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let rec find_max (words: string list): string = \n        match words with\n        | [] -> \"\"\n        | word::rest -> \n            if word.Length > 0 then \n                let max_char = word.Length\n                let max_index = word.IndexOf(max_char)\n                if max_index < 0 then \n                    word\n                else\n                    let rest_index = rest.IndexOf(word, max_index)\n                    if rest_index < 0 then \n                        word\n                    else\n                        let rest_index = rest.IndexOf(word, max_index)\n                        if rest_index < 0 then \n                            word\n                        else\n                            let rest_index = rest.IndexOf(word, max_index)\n                            if rest_index < 0 then \n                                word\n                            else\n                                let rest_index = rest.IndexOf(word, max_index)\n                                if rest_index < 0 then \n                                    word\n                                else\n                                    let rest_index = rest.IndexOf(word, max_index)\n                                    if rest_index < 0 then \n                                        word\n                                    else\n                                        let rest_index = rest.IndexOf(word, max_index)\n                                        if rest_index < 0 then \n                                            word\n                                        else\n                                            let rest_index = rest.IndexOf(word, max_index)\n                                            if rest_index < 0 then \n                                                word\n                                            else\n                                                let rest_index = rest.IndexOf(word, max_index)\n                                                if rest_index < 0 then \n                                                    word\n                                                else\n                                                    let rest_index = rest.IndexOf(word, max_index)\n                                                    if rest_index < 0 then \n                                                        word\n                                                    else\n                                                        let rest_index = rest.IndexOf(word, max_index)\n                                                        if rest_index < 0 then \n                                                            word\n                                                        else\n                                                            let rest_index = rest.IndexOf(word, max_index)\n                                                            if rest_index < 0 then \n                                                                word\n                                                            else\n                                                                let rest_index = rest.IndexOf(word, max_index)\n                               \nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpb1vd4jke.fsx(63,65): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max (words: string list): string  = \n    let mutable max = 0\n    let mutable i = 0\n    while i < words.Length do\n        let word = words.[i]\n        if word.Length > max then\n            max <- word.Length\n        i <- i + 1\n    max\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675476800,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpals8sjmc.fsx(16,5): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}