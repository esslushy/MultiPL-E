{
  "name": "HumanEval_58_common",
  "language": "fs",
  "prompt": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n",
  "tests": "let test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with\n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2'\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476897,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzpmyjomh.fsx(49,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec loop l1 l2 acc =\n        match l1, l2 with\n        | [], [] -> acc\n        | x::xs, y::ys -> loop xs y (loop xs y (acc + x))\n    loop l1 l2 []\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5xocejcf.fsx(10,35): error FS0001: Type mismatch. Expecting a\n    ''a list'    \nbut given a\n    ''a'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec loop i l1 l2 = \n        match l1, l2 with \n        | [], [] -> []\n        | [], _ -> []\n        | _, [] -> []\n        | _, _ -> \n            let l1' = l1 |> List.filter (fun x -> x < i)\n            let l2' = l2 |> List.filter (fun x -> x < i)\n            loop i l1' l2'\n    loop 0 l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec loop acc l1 l2 = \n        match l1, l2 with \n        | [], [] -> acc\n        | h1::t1, h2::t2 -> loop (h1::acc) t1 t2\n        | _ -> loop [] l1 l2\n    loop [] l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec loop i l1 l2 = \n        match l1, l2 with\n        | [], [] -> []\n        | [], _ -> []\n        | _, [] -> []\n        | _, _ -> \n            let l1' = l1 |> List.map (fun x -> x + i)\n            let l2' = l2 |> List.map (fun x -> x + i)\n            loop (i + 1) l1' l2'\n    loop 0 l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with \n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.rev l1\n            let l2' = List.rev l2\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2' = List.rev l2'\n            let l1' = List.rev l1'\n            let l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476897,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpg8c6sw2k.fsx(49,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' (l1: int list) (l2: int list) = \n        match l1, l2 with \n        | [], [] -> []\n        | [], _ -> []\n        | _, [] -> []\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            if l1' = l2' then \n                l1'\n            else \n                common' l1' l2'\n    common' l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with \n        | [], [] -> acc\n        | h1::t1, h2::t2 -> \n            if h1 = h2 then common' (h1::acc) t1 t2\n            else common' (h1::acc) t1 t2\n    \n    match l1, l2 with \n    | [], [] -> []\n    | h1::t1, h2::t2 -> \n        if h1 = h2 then common' [] t1 t2\n        else common' [] t1 t2\n    | _ -> \n        let rec common' acc l1 l2 = \n            match l1, l2 with \n            | [], [] -> acc\n            | h1::t1, h2::t2 -> \n                if h1 = h2 then common' (h1::acc) t1 t2\n                else common' (h1::acc) t1 t2\n        common' [] l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpptm2229f.fsx(8,15): warning FS0025: Incomplete pattern matches on this expression. For example, the value '(_,[_])' may indicate a case not covered by the pattern(s).\n\n\n\n/tmp/tmpptm2229f.fsx(21,19): warning FS0025: Incomplete pattern matches on this expression. For example, the value '(_,[_])' may indicate a case not covered by the pattern(s).\n\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with\n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2'\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476897,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzpmyjomh.fsx(49,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec loop l1 l2 acc = \n        match l1, l2 with\n        | [], [] -> acc\n        | h1::t1, h2::t2 -> loop t1 t2 (h1::acc)\n    loop l1 l2 []\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnty6bltd.fsx(8,15): warning FS0025: Incomplete pattern matches on this expression. For example, the value '(_,[_])' may indicate a case not covered by the pattern(s).\n\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with \n        | [], [] -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476897,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp9_726wpi.fsx(47,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with \n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476897,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4a0xpz_s.fsx(49,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with\n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            let common' = common' (List.append l1' l2')\n            List.append l1' common'\n    \n    let rec common acc l1 l2 = \n        match l1, l2 with\n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            let common' = common' (List.append l1' l2')\n            List.append l1' common'\n    \n    common [] l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa1_ky4ca.fsx(16,29): error FS0001: This expression was expected to have type\n    ''a list'    \nbut here has type\n    ''a list -> 'a list -> 'a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec loop acc = \n        match l1, l2 with \n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> loop (acc @ [l1.Head; l2.Head])\n    loop []\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec loop acc l1 l2 = \n        match l1, l2 with\n        | [], [] -> acc\n        | [], x :: xs -> loop (x :: acc) xs\n        | x :: xs, y :: ys -> loop (x :: acc) ys\n        | x :: xs, [] -> loop acc xs\n        | [], y :: ys -> loop (x :: acc) ys\n        | x :: xs, y :: ys -> loop (x :: acc) ys\n        | _ -> failwith \"unreachable\"\n    loop [] l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1_00aypj.fsx(10,26): error FS0001: Type mismatch. Expecting a\n    ''a'    \nbut given a\n    ''b list -> 'a'    \nThe types ''a' and ''b list -> 'a' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec loop acc l1 l2 = \n        match l1, l2 with\n        | [], [] -> acc\n        | _, [] -> acc\n        | [], _ -> loop (acc @ []) l1 l2\n        | _, _ -> loop (acc @ []) l1 l2\n    loop [] l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with \n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476897,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4a0xpz_s.fsx(49,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with\n        | [], [] -> acc\n        | _, [] -> acc\n        | x::xs, y::ys -> \n            if x = y then common' (x::acc) xs ys\n            else common' (x::acc) xs ys\n    common' [] l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp99124y0o.fsx(8,15): warning FS0025: Incomplete pattern matches on this expression. For example, the value '(_,[_])' may indicate a case not covered by the pattern(s).\n\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec common' acc l1 l2 = \n        match l1, l2 with\n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2' = List.sort l2'\n            let l1' = List.sort l1'\n            let l2'\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476897,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzpmyjomh.fsx(49,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common (l1: int list) (l2: int list): int list  = \n    let rec loop i l1 l2 = \n        match l1, l2 with \n        | [], [] -> []\n        | x::xs, y::ys -> \n            if x = y then loop (i+1) xs ys\n            else loop (i+1) xs ys\n    loop 0 l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675476898,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplo0dcdcz.fsx(8,15): warning FS0025: Incomplete pattern matches on this expression. For example, the value '(_,[_])' may indicate a case not covered by the pattern(s).\n\n",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}