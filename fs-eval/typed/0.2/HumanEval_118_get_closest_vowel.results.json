{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "fs",
  "prompt": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n",
  "tests": "let test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = word.ToCharArray()\n    let mutable i = 0\n    let mutable best = \"\"\n    while i < vowels.Length do\n        if vowels.[i] = 'y' && i < vowels.Length && vowels.[i] = 'o' && i < vowels.Length && vowels.[i] = 'u' then\n            best <- best + vowels.[i]\n            i <- i + 1\n        else\n            i <- i + 1\n    best\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp6zumo910.fsx(17,28): error FS0001: The type 'char' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = [ 'a' .. 'z' ]\n    let vowels_left = List.filter (fun v -> v <> 'a' && v <> 'e') vowels\n    let vowels_right = List.filter (fun v -> v <> 'e' && v <> 'i') vowels\n    let vowels_left_right = List.filter (fun v -> v <> 'i' && v <> 'o' && v <> 'u') vowels\n    let vowels_left_right_vowels = List.filter (fun v -> v <> 'o' && v <> 'u' && v <> 'e' && v <> 'i') vowels\n    let vowels_left_right_vowels_left = List.filter (fun v -> v <> 'e' && v <> 'i' && v <> 'o' && v <> 'u') vowels\n    let vowels_right_left = List.filter (fun v -> v <> 'o' && v <> 'u' && v <> 'e' && v <> 'i') vowels\n    let vowels_right_left_vowels = List.filter (fun v -> v <> 'e' && v <> 'i' && v <> 'o' && v <> 'u') vowels\n    let vowels_right_left_vowels_left = List.filter (fun v -> v <> 'e' && v <> 'i' && v <> 'o' && v <> 'u' && v <> 'e' && v <> 'i') vowels\n    let vowels_right_left_vowels_left_right = List.filter (fun v -> v <> 'e' && v <> 'i' && v <> 'o' && v <> 'u' && v <> 'e' && v <> 'i' && v <> 'o' && v <> 'u' && v <> 'e' && v <> 'i') vowels\n    let vowels_right_left_vowels_left_right_vowels = List.filter (fun v -> v <> 'e' && v <>\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpx7pcukbl.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (22:76). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpx7pcukbl.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (22:76). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpx7pcukbl.fsx(40,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (22:76). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpx7pcukbl.fsx(40,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (22:76). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpx7pcukbl.fsx(22,66): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd5z6ex6_.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['a'..'z']\n    let vowels_to_find_end = ['A'..'Z']\n    let vowels_to_find_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_l9erggp.fsx(33,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['A'..'Z']\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = 'a')\n    let vowels_end = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_end_index = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = 'a')\n    let vowels_end = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = 'a')\n    let vowels_end = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = 'a')\n    let vowels_end = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = 'a')\n    let vowels_end = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = 'a')\n    let vowels_end = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = 'a')\n    let vowels_end = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = 'a')\n    let vowels_end = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = 'a')\n    let vowels_end = vowels |> Array.findIndex (fun c -> c = 'z')\n    let vowels_start = vowels |> Array.findIndex (fun c -> c = '\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3eg8ms8f.fsx(32,64): error FS0010: Unexpected quote symbol in expression\n\n\n\n/tmp/tmp3eg8ms8f.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (32:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd5z6ex6_.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = word.ToCharArray()\n    let mutable best = \"\"\n    for i = vowels.Length - 1 downto 0 do\n        if vowels.[i] = 'a' then\n            best <- best + vowels.[i]\n    best\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptetk5u5j.fsx(16,28): error FS0001: The type 'char' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word.ToCharArray()\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        let first_vowel = vowels_in_word.[0]\n        let second_vowel = vowels_in_word.[1]\n        let first_vowel_in_word = first_vowel.ToString()\n        let second_vowel_in_word = second_vowel.ToString()\n        let first_vowel_in_word_with_vowel = first_vowel_in_word.Replace(first_vowel, second_vowel)\n        let second_vowel_in_word_with_vowel = second_vowel_in_word.Replace(second_vowel, first_vowel)\n        let first_vowel_in_word_with_vowel = first_vowel_in_word_with_vowel.Replace(first_vowel, second_vowel)\n        first_vowel_in_word_with_vowel\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpw4dh7bq9.fsx(15,45): error FS0001: Type mismatch. Expecting a\n    'char list -> bool'    \nbut given a\n    ''a[] -> bool'    \nThe type 'char list' does not match the type ''a[]'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray() |> Array.filter (fun c -> c <> ' ')\n    let vowels_in_word_length = vowels.Length\n    let vowels_in_word_length_in_vowels = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words_in_words_in_words = vowels_in_word.Length\n    let vowels_in_word_length_in_vowels_in_words\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkuc5rbea.fsx(28,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['A'..'Z']\n    let vowels_in_word = word.ToCharArray() |> Array.filter (fun c -> c <> ' ')\n    let vowels_in_word_length = vowels.Length\n    let vowels_in_word_index = vowels_in_word.Length - 1\n    let vowels_in_word_index_in_vowel = vowels_in_word_index - 1\n    let vowel_index = vowels_in_word_index_in_vowel + vowels_in_word_index\n    let vowels_in_word_index_in_vowel_in_vowel = vowels_in_word_index_in_vowel - vowels_in_word_index_in_vowel\n    let vowel_index_in_vowel_in_vowel_in_vowel = vowel_index_in_vowel_in_vowel - vowel_index_in_vowel_in_vowel\n    let vowel_index_in_vowel_in_vowel_in_vowel = vowel_index_in_vowel_in_vowel_in_vowel - vowel_index_in_vowel_in_vowel_in_vowel\n    let vowel_index_in_vowel_in_vowel_in_vowel = vowel_index_in_vowel_in_vowel_in_vowel - vowel_index_in_vowel_in_vowel_in_vowel\n    let vowel_index_in_vowel_in_vowel_in_vowel = vowel_index_in_vowel_in_vowel_in_vowel_in_vowel - vowel_index_in_vowel_in_vowel_in_vowel_in_vowel\n    let vowel_index_in_vowel_in_vowel_in_vowel = vowel_index_in_vowel_in_vowel_in_vowel_in\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnrvj9iu_.fsx(23,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray() |> Array.filter (fun c -> vowels |> Array.contains c)\n    let vowels_in_word_len = vowels_in_word.Length\n    let vowels_in_word_len_in_word = vowels_in_word_len - 1\n    let vowels_in_word_len_in_word_in_word = vowels_in_word_len - 1\n    let vowels_in_word_in_word_in_word_in_word = vowels_in_word_in_word_in_word_in_word_in_word_in_word\n    let vowels_in_word_in_word_in_word_in_word_in_word_in_word = vowels_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word\n    let vowels_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word_in_word\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphe3iemdd.fsx(20,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = word.ToCharArray()\n    let mutable i = 0\n    let mutable result = \"\"\n    while i < vowels.Length do\n        if vowels.[i] = 'a' || vowels.[i] = 'e' || vowels.[i] = 'i' || vowels.[i] = 'o' || vowels.[i] = 'u' || vowels.[i] = 'y' || vowels.[i] = 'y' || vowels.[i] = 'a' || vowels.[i] = 'e' || vowels.[i] = 'i' || vowels.[i] = 'o' || vowels.[i] = 'u' || vowels.[i] = 'y' || vowels.[i] = 'y' || vowels.[i] = 'a' || vowels.[i] = 'e' || vowels.[i] = 'i' || vowels.[i] = 'o' || vowels.[i] = 'u' || vowels.[i] = 'y' || vowels.[i] = 'y' || vowels.[i] = 'a' || vowels.[i] = 'e' || vowels.[i] = 'i' || vowels.[i] = 'o' || vowels.[i] = 'u' || vowels.[i] = 'y' then\n            result <- result + vowels.[i]\n            i <- i + 1\n    result\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpoxcw2qme.fsx(17,32): error FS0001: The type 'char' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['A'..'Z']\n    let vowels_to_find = ['a'..'z']\n    let vowels_to_find_end = ['A'..'Z']\n    let vowels_to_find_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpx3aeriey.fsx(33,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = [ 'a' .. 'z' ]\n    let vowels_to_find = vowels |> List.filter (fun v -> word.Contains(v))\n    let vowels_to_find_end = vowels |> List.filter (fun v -> word.EndsWith(v))\n    let vowels_to_find_start = vowels |> List.filter (fun v -> word.StartsWith(v))\n    let vowels_to_find_middle = vowels |> List.filter (fun v -> word.Contains(v))\n    let vowels_to_find_end_middle = vowels |> List.filter (fun v -> word.EndsWith(v))\n    let vowels_to_find_middle_end = vowels |> List.filter (fun v -> word.EndsWith(v))\n    let vowels_to_find_start_middle = vowels |> List.filter (fun v -> word.StartsWith(v))\n    let vowels_to_find_middle_start = vowels |> List.filter (fun v -> word.StartsWith(v))\n    let vowels_to_find_end_middle_start = vowels |> List.filter (fun v -> word.EndsWith(v))\n    let vowels_to_find_middle_end_start = vowels |> List.filter (fun v -> word.EndsWith(v))\n    let vowels_to_find_end_middle_end = vowels |> List.filter (fun v -> word.EndsWith(v))\n    let vowels_to_find_end_middle_end_start = vowels |> List.filter (fun v -> word.EndsWith(v))\n    let vowels_to_find_start_middle = vowels |> List.filter (fun v -> word.StartsWith(v))\n    let vowels_to_find_start_middle_start = vowels |> List.filter (fun v -> word.StartsWith(v))\n    let vowels_to_find_middle_start = vowels |> List.filter (fun v -> word.StartsWith(v))\n    let\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbw2ljn3v.fsx(29,1): error FS0010: Incomplete structured construct at or before this point in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd5z6ex6_.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd5z6ex6_.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd5z6ex6_.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray()\n    let mutable found = false\n    let mutable i = 0\n    while i < vowels_in_word.Length && not found do\n        if vowels.[i] = vowels.[i-1] then\n            found <- true\n        else\n            i <- i + 1\n    if found then\n        vowels.[i-1]\n    else\n        \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuaoi3xjd.fsx(22,9): error FS0193: Type constraint mismatch. The type \n    'char'    \nis not compatible with type\n    'string'    \n\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['a'..'z'] @ ['A'..'Z']\n    let vowels_to_find_end = ['a'..'z'] @ ['A'..'Z'] @ ['a'..'z']\n    let vowels_to_find_end_end = ['a'..'z'] @ ['A'..'Z'] @ ['a'..'z'] @ ['a'..'z']\n    let vowels_to_find_end_end_end = ['a'..'z'] @ ['A'..'Z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z'] @ ['A'..'Z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z'] @ ['A'..'Z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z']\n    let vowels_to_find_end_end_end_end_end = ['a'..'z'] @ ['A'..'Z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z']\n    let vowels_to_find_end_end_end_end_end_end = ['a'..'z'] @ ['A'..'Z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['a'..'z'] @ ['\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwp_h8q6x.fsx(20,194): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmpwp_h8q6x.fsx(21,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (20:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray()\n    let mutable i = 0\n    let mutable best_vowel = \"\"\n    while i < vowels_in_word.Length && best_vowel.Length <> 0 do\n        if vowels.[i] = vowels.[i-1] then\n            best_vowel <- vowels.[i]\n            i <- i + 1\n        else\n            i <- i + 1\n    best_vowel\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3umazji0.fsx(18,27): error FS0193: Type constraint mismatch. The type \n    'char'    \nis not compatible with type\n    'string'    \n\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray()\n    let mutable best = \"\"\n    for i = vowels.Length-1 downto 0 do\n        let v = vowels.[i]\n        if vowels_in_word.[i] = v then\n            best <- best + v\n    best\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675477055,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgsjgix27.fsx(18,28): error FS0001: The type 'char' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}