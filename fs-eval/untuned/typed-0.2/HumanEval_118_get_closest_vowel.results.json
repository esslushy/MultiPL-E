{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "fs",
  "prompt": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n",
  "tests": "let test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().replace(/[a-z]/g, \"\").replace(/[aeiou]/g, \"\").replace(/[^aeiou]/g, \"\")\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprp95fwn_.fsx(12,33): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().replace(/[^a-z]/g, \"\").replace(/[-z]/g, \"\").replace(/[-z]/g, \"\").replace(/[-z]/g, \"\").replace(/[-z]/g, \"\")\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphwre6zi_.fsx(12,33): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n  (word.charAt(0) == 'y') ? \"u\" : \"U\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpn7hmxlp6.fsx(12,29): error FS0010: Unexpected string literal in expression. Expected identifier, '(' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().replace(/[a-z]/g, \"\").replace(/[^a-z]/g, \"\").replace(/[^a-z]/g, \"\").replace(/[a-z]/g, \"\")\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcuds0lr2.fsx(12,33): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.split(\"\").map(vowel => vowel.toUpperCase()).reduce((a, b) => a + b);\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790570,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0jn_lepk.fsx(12,10): error FS0039: The type 'String' does not define the field, constructor or member 'split'. Maybe you want one of the following:\n   Split\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().replace(/[aeiou]/g, \"\").replace(/[aeiou]/g, \"\").toLowerCase();\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpiwkogg6s.fsx(12,33): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.split(\"\").map(vowel => vowel.toUpperCase()).reduce((a, b) => a + b);\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790570,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0jn_lepk.fsx(12,10): error FS0039: The type 'String' does not define the field, constructor or member 'split'. Maybe you want one of the following:\n   Split\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    (word.charAt(0) == 'y' ? \"y\" : \"u\") + word.substr(1) + word.substr(2);\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp9pha2tc2.fsx(12,30): error FS0010: Unexpected string literal in expression. Expected identifier, '(' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().replace(/[aeiouy]/g, \"\").replace(/[aeiouy]/g, \"\").replace(/[aeiouy]/g, \"\").replace(/[aeiouy]/g, \"\")\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_fabee4t.fsx(12,33): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    (word.charAt(0) == 'y' || word.charAt(0) == 'F' || word.charAt(0) == 'u' || word.charAt(0) == 'U') ? word.charAt(1) : word;\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp9jnxwtuj.fsx(12,127): error FS0010: Unexpected symbol ';' in binding. Expected incomplete structured construct at or before this point or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().replace(/[aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[aeiou]/g, \"\")\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpsrbodq98.fsx(12,33): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().split(\"v\").filter(v => v.toLowerCase().indexOf(\"u\") > -1).join(\"\");\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790570,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpam33d0fv.fsx(12,10): error FS0039: The type 'String' does not define the field, constructor or member 'toLowerCase'. Maybe you want one of the following:\n   ToLower\n   ToLowerInvariant\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n  word.toLowerCase().replace(/[a-z]/g, \"\").replace(/[A-Z]/g, \"\").replace(/[0-9]/g, \"\").replace(/[-]/g, \"\").replace(/[^a-z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2ttya1z8.fsx(12,31): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n\n\n/tmp/tmp2ttya1z8.fsx(13,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2ttya1z8.fsx(13,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2ttya1z8.fsx(30,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2ttya1z8.fsx(30,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.substr(0, 1) + word.substr(1, 1) + word.substr(2, 1) + word.substr(3, 1) + word.substr(4, 1) + word.substr(5, 1) + word.substr(6, 1) + word.substr(7, 1) + word.substr(8, 1) + word.substr(9, 1) + word.substr(10, 1) + word.substr(11, 1) + word.substr(12, 1) + word.substr(13, 1) + word.substr(14, 1) + word.substr(15, 1) + word.substr(16, 1) + word.substr(17, 1) + word.substr(18, 1) + word.substr(19, 1) + word.substr(20, 1) + word.substr(21, 1) + word.substr(22, 1) + word.substr(23, 1) + word.substr(24, 1) + word.substr(25, 1) + word.substr(26, 1) + word.substr(27, 1) + word.substr(28, 1) + word.substr(29, 1) + word.substr(30, 1) + word.substr(31, 1) + word.substr(32, 1) + word.substr(33, 1) + word.substr(34, 1) + word.substr(35, 1) + word.substr(36, 1) + word.substr(37, 1) + word.substr(38, 1) + word.substr(39, 1) + word.substr(40, 1) + word.substr(41, 1) + word.substr(42, 1) + word.substr(43, 1) + word.substr(44, 1) + word.substr(45, 1) + word.substr(46, 1) + word.substr(47, 1) + word.substr(48, 1) + word.substr(49, 1) + word.substr(50, 1) + word\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790570,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppfajtjzg.fsx(12,10): error FS0039: The type 'String' does not define the field, constructor or member 'substr'. Maybe you want one of the following:\n   Substring\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().replace(/[a-z]/g, \"\").replace(/[^a-z]/g, \"\").replace(/[^a-z]/g, \"\").replace(/[^a-z]/g, \"\").replace(/[a-z]/g, \"\").toLowerCase();\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy7fx_f_7.fsx(12,33): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n  word.toLowerCase().split(\" \").map(vowel => vowel.toLowerCase()).reduce((prev, curr) => prev + curr, \"\")\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790570,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0280ozkl.fsx(12,8): error FS0039: The type 'String' does not define the field, constructor or member 'toLowerCase'. Maybe you want one of the following:\n   ToLower\n   ToLowerInvariant\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    (word.charAt(0) == 'y' || word.charAt(0) == 'F' ? word.charAt(1) : word.charAt(0)) +\n    (word.charAt(1) == 'o' ? word.charAt(2) : word.charAt(0));\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4odwn9b3.fsx(12,83): error FS0010: Unexpected symbol '(' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().replace(/[a-z]/g, \"\").replace(/[A-Z]/g, \"\").replace(/[0-9]/g, \"\").replace(/[^a-z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[^0-9]/g, \"\").replace(/[^A-Z]/g, \"\").replace(/[\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpss32_dxn.fsx(12,33): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n\n\n/tmp/tmpss32_dxn.fsx(13,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpss32_dxn.fsx(13,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpss32_dxn.fsx(13,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpss32_dxn.fsx(30,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpss32_dxn.fsx(30,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n    word.toLowerCase().replace(/[^a-z]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace(/[^aeiou]/g, \"\").replace\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpen91i_zp.fsx(12,33): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel (word: string): string  = \n  (word.charAt(0) == 'y' || word.charAt(0) == 'F' || word.charAt(0) == 'u') ? word.substr(1) : word;\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675790569,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdo265b2m.fsx(12,100): error FS0010: Unexpected symbol ';' in binding. Expected incomplete structured construct at or before this point or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}