{
  "name": "HumanEval_87_get_row",
  "language": "fs",
  "prompt": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n",
  "tests": "let test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n];\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpvafs969n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 1, 6],\n    [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n];\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpvafs969n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 1, 6],\n    [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n];\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpvafs969n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmps4v96n8x.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmps4v96n8x.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n];\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpvafs969n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n];\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpvafs969n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmps4v96n8x.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 1, 6],\n    [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmps4v96n8x.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n];\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpvafs969n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmps4v96n8x.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmps4v96n8x.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmps4v96n8x.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n    [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 1, 6],\n    [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpzsj8cu8n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmps4v96n8x.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n]\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmps4v96n8x.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmps4v96n8x.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a 2 dimensional data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n// each row may contain a different number of columns.\n// Given lst, and integer x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates of the row by columns in descending order.\n// Examples:\n// get_row([\n// [1,2,3,4,5,6],\n// [1,2,3,4,1,6],\n// [1,2,3,4,5,1]\n// ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n// get_row([], 1) == []\n// get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\nlet get_row lst x = \n[\n  [1, 2, 3, 4, 5, 6],\n  [1, 2, 3, 4, 1, 6],\n  [1, 2, 3, 4, 5, 1]\n];\nlet test() = \n  let candidate = get_row\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 4); (1, 0); (2, 5); (2, 0)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]] 2 = [(0, 1); (1, 1); (2, 1); (3, 1); (4, 1); (5, 1)])\n  assert (candidate [[1; 2; 3; 4; 5; 6]; [1; 2; 3; 4; 5; 6]; [1; 1; 3; 4; 5; 6]; [1; 2; 1; 4; 5; 6]; [1; 2; 3; 1; 5; 6]; [1; 2; 3; 4; 1; 6]; [1; 2; 3; 4; 5; 1]] 1 = [(0, 0); (1, 0); (2, 1); (2, 0); (3, 2); (3, 0); (4, 3); (4, 0); (5, 4); (5, 0); (6, 5); (6, 0)])\n  assert (candidate [] 1 = [])\n  assert (candidate [[1]] 2 = [])\n  assert (candidate [[]; [1]; [1; 2; 3]] 3 = [(2, 2)])\n  0\n\ntest()",
      "timestamp": 1675797951,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpvafs969n.fsx(18,1): warning FS0020: The result of this expression has type '((int * int * int * int * int * int) list * (int * int * int * int * int * int) list * (int * int * int * int * int * int) list) list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n\n\n/tmp/tmpvafs969n.fsx(24,19): error FS0039: The value or constructor 'get_row' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}