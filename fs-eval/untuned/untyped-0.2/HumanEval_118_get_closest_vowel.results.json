{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "fs",
  "prompt": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n",
  "tests": "let test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.charAt(0) == 'y' ? word.substr(1, 1) : word.substr(0, 1))\n    .split('v')[0]\n    .split('o')[0]\n    .split('u')[0]\n    .split('e')[0]\n    .split('e')[1]\n    .split('a')[0]\n    .split('a')[1]\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .split(' ')\n    .join(' ')\n    .\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqawdo34e.fsx(12,61): error FS0010: Unexpected symbol '(' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.toLowerCase()).replace(/[^a-z]/g, \"\").toLowerCase();\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpo1zi0kqk.fsx(12,35): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    word.replace(/[^a-z]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    .replace(/[^aeiou]/g, '')\n    \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptxt37dqf.fsx(12,19): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.toLowerCase()).replace(/[^a-z]/g, \"\").split(\" \");\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkgv5zbc4.fsx(12,35): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    \"yogurt\"\n    .split(\"\")\n    .map(vowel => vowel.toLowerCase())\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel => vowel != \"u\")\n    .filter(vowel =>\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp14i6m22g.fsx(13,5): error FS0010: Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.\n\n\n\n/tmp/tmp14i6m22g.fsx(50,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp14i6m22g.fsx(50,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp14i6m22g.fsx(67,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp14i6m22g.fsx(67,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    word.replace(/[a-z]/g, (s) => s.toUpperCase());\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7t0jun4w.fsx(12,19): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    \"yogurt\"\n    .replace(/[^a-z]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpexz1ua_c.fsx(13,5): error FS0010: Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.toLowerCase().indexOf(\"yogurt\") == -1) ? \"\" : word.toLowerCase().slice(0, word.toLowerCase().indexOf(\"yogurt\"));\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk1ecoctd.fsx(12,52): error FS0010: Unexpected string literal in expression. Expected identifier, '(' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.toLowerCase().indexOf(\"yogurt\") > -1) ? \"u\" : \"\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuh5pnqap.fsx(12,51): error FS0010: Unexpected string literal in expression. Expected identifier, '(' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.charAt(0) == 'y' && word.charAt(1) == 'o' && word.charAt(2) == 'g') ? \"u\" : \"\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp6_ww3z6e.fsx(12,81): error FS0010: Unexpected string literal in expression. Expected identifier, '(' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    word.replace(/[a-z]/g, (match) => {\n        let vowel = match.toLowerCase();\n        let consonants = word.split(vowel);\n        let left = consonants[0];\n        let right = consonants[1];\n        let left_vowel = left.split(vowel);\n        let right_vowel = right.split(vowel);\n        let left_vowel_index = left_vowel.indexOf(vowel);\n        let right_vowel_index = right_vowel.indexOf(vowel);\n        let left_vowel_index_diff = left_vowel_index - right_vowel_index;\n        let right_vowel_index_diff = right_vowel_index - left_vowel_index;\n        let left_vowel_index_diff_abs = left_vowel_index_diff * -1;\n        let right_vowel_index_diff_abs = right_vowel_index_diff * -1;\n        let left_vowel_index_diff_abs_abs = left_vowel_index_diff_abs * -1;\n        let right_vowel_index_diff_abs_abs = right_vowel_index_diff_abs * -1;\n        let left_vowel_index_diff_abs_abs_abs = left_vowel_index_diff_abs_abs * -1;\n        let left_vowel_index_diff_abs_abs_abs = left_vowel_index_diff_abs_abs * -1;\n        let left_vowel_index_diff_abs_abs_abs = left_vowel_index_diff_abs_abs * -1;\n        let left_vowel_index_diff_abs_abs_abs = left_vowel_index_diff_abs_abs * -1;\n        let left_vowel_index_diff_abs_abs_abs = left_vowel_index_diff_abs_abs * -1;\n        let left_vowel\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_5_cp0dq.fsx(12,19): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n\n\n/tmp/tmp_5_cp0dq.fsx(33,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.toLowerCase()).replace(/[a-z]/g, function(match) {\n        return match.toUpperCase();\n    });\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_zuk3wg9.fsx(12,35): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n\n\n/tmp/tmp_zuk3wg9.fsx(13,9): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:52). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_zuk3wg9.fsx(13,9): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:52). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_zuk3wg9.fsx(13,16): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:52). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.charAt(0) == 'y' ? \"u\" : \"\") +\n    (word.charAt(1) == 'o' ? \"u\" : \"\") +\n    (word.charAt(2) == 't' ? \"u\" : \"\") +\n    (word.charAt(3) == 'e' ? \"u\" : \"\") +\n    (word.charAt(4) == 'r' ? \"u\" : \"\") +\n    (word.charAt(5) == 't' ? \"u\" : \"\") +\n    (word.charAt(6) == 'e' ? \"u\" : \"\") +\n    (word.charAt(7) == 'r' ? \"u\" : \"\") +\n    (word.charAt(8) == 't' ? \"u\" : \"\") +\n    (word.charAt(9) == 'e' ? \"u\" : \"\") +\n    (word.charAt(10) == 'r' ? \"u\" : \"\") +\n    (word.charAt(11) == 't' ? \"u\" : \"\") +\n    (word.charAt(12) == 'e' ? \"u\" : \"\") +\n    (word.charAt(13) == 'r' ? \"u\" : \"\") +\n    (word.charAt(14) == 't' ? \"u\" : \"\") +\n    (word.charAt(15) == 'e' ? \"u\" : \"\") +\n    (word.charAt(16) == 'r' ? \"u\" : \"\") +\n    (word.charAt(17) == 't' ? \"u\" : \"\") +\n    (word.charAt(18) == 'e' ? \"u\" : \"\") +\n    (word.charAt(19) == 'r' ? \"u\" : \"\") +\n    (word.charAt(20) == 't' ? \"u\" : \"\") +\n    (word.charAt(21) == 'e' ? \"u\" : \"\") +\n    (word.charAt(22) == 'r' ? \"u\" : \"\") +\n    (word.charAt\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp62zuhkpi.fsx(12,30): error FS0010: Unexpected string literal in expression. Expected identifier, '(' or other token.\n\n\n\n/tmp/tmp62zuhkpi.fsx(36,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (11:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    word.replace(/[^a-z]/g, '');\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpw9ztnkl4.fsx(12,19): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.toLowerCase().match(/[a-z]/) || []).join(\"\");\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkqqo98nn.fsx(12,24): error FS0599: Missing qualification after '.'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.toLowerCase().indexOf(\"yogurt\") >= 0) ? \"u\" : \"\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp43_ktlss.fsx(12,51): error FS0010: Unexpected string literal in expression. Expected identifier, '(' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.toLowerCase()).replace(/[a-z]/g, \"\").replace(/[^a-z]/g, \"\").replace(/[^a-z]/g, \"\")\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpctronkoo.fsx(12,35): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    word.replace(/[a-z]/g, (s) => s.toUpperCase());\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7t0jun4w.fsx(12,19): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    \"yogurt\"\n    .replace(/[^a-z]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .replace(/[^aeiouy]/g, \"\")\n    .\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpexz1ua_c.fsx(13,5): error FS0010: Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    (word.toLowerCase()).replace(/[a-z]/g, \"\").toLowerCase().slice(0, -1);\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675797181,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp47p4dsw1.fsx(12,35): error FS0010: Unexpected symbol '[' in expression. Expected ')' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}