{
  "name": "HumanEval_7_filter_by_substring",
  "language": "fs",
  "prompt": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n",
  "tests": "let test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(substring)\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqpzngzup.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(substring)\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqpzngzup.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(' ')\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .join(' ');\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797956,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3iy5056v.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(' ')\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmporu0uj8z.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(substring)\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .filter(s => s.includes(substring))\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqpzngzup.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  strings =>\n    strings.filter(s => s.startsWith(substring))\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplwojvktj.fsx(8,5): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    strings =>\n        strings.filter(s => s.startsWith(substring))\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s => s)\n    .map(s => s.substring(substring.length))\n    .filter(s =>\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmtnaperl.fsx(9,5): error FS0010: Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.\n\n\n\n/tmp/tmpmtnaperl.fsx(47,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpmtnaperl.fsx(47,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpmtnaperl.fsx(55,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpmtnaperl.fsx(55,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(substring)\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.length))\n  .map(s => s.substring(0, substring.\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpr49h_y1p.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n\n\n/tmp/tmpr49h_y1p.fsx(36,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  (str) => {\n    return str.includes(substring)\n  }\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjnspaqqf.fsx(7,4): error FS0039: The value or constructor 'str' is not defined. Maybe you want one of the following:\n   string\n   String\n   strings\n   stderr\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    strings =>\n        strings.filter(s => s.startsWith(substring))\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0fm9ws6_.fsx(8,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(' ')\n  .filter(s => s.startsWith(substring))\n  .map(s => s.substring(substring.length))\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s => s.length > 0)\n  .map(s => s)\n  .filter(s\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy44c7yfg.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n\n\n/tmp/tmpy44c7yfg.fsx(54,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  strings =>\n    strings.filter(s => s.startsWith(substring))\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplwojvktj.fsx(8,5): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  (str) => {\n    return str.split(substring).filter(s => s.length > 0);\n  };\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqaf6gb4e.fsx(7,4): error FS0039: The value or constructor 'str' is not defined. Maybe you want one of the following:\n   string\n   String\n   strings\n   stderr\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  + 'bacd'\n  + 'cde'\n  + 'array'\n  + 'a'\n  + 'b'\n  + 'c'\n  + 'd'\n  + 'e'\n  + 'f'\n  + 'g'\n  + 'h'\n  + 'i'\n  + 'j'\n  + 'k'\n  + 'l'\n  + 'm'\n  + 'n'\n  + 'o'\n  + 'p'\n  + 'q'\n  + 'r'\n  + 's'\n  + 't'\n  + 'u'\n  + 'v'\n  + 'w'\n  + 'x'\n  + 'y'\n  + 'z'\n  + 'a'\n  + 'b'\n  + 'c'\n  + 'd'\n  + 'e'\n  + 'f'\n  + 'g'\n  + 'h'\n  + 'i'\n  + 'j'\n  + 'k'\n  + 'l'\n  + 'm'\n  + 'n'\n  + 'o'\n  + 'p'\n  + 'q'\n  + 'r'\n  + 's'\n  + 't'\n  + 'u'\n  + 'v'\n  + 'w'\n  + 'x'\n  + 'y'\n  + 'z'\n  + 'a'\n  + 'b'\n  + 'c'\n  + 'd'\n  + 'e'\n  + 'f'\n  + 'g'\n  + 'h'\n  + 'i'\n  + 'j'\n  + 'k'\n  + 'l'\n  + 'm'\n  + 'n'\n  + 'o'\n  + 'p'\n  + 'q'\n  + 'r'\n  + 's'\n  + 't'\n  + 'u'\n  + 'v'\n  + 'w'\n  + 'x'\n  + 'y'\n  + 'z'\n  + 'a'\n  + 'b'\n  + 'c'\n\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkfn19xd0.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(substring)\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8h523ck4.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n\n\n/tmp/tmp8h523ck4.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(substring)\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8h523ck4.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n\n\n/tmp/tmp8h523ck4.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(substring)\n  .filter(s => s.includes(substring))\n  .map(s => s.toLowerCase())\n  .join('');\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpx3jl0szp.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  `\n  {{\n    filter_by_substring(['a', 'b', 'c'], 'd')\n    .map(s => s.toLowerCase())\n  }}\n  `;\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprybuugny.fsx(7,3): error FS0010: Unexpected reserved keyword in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  'abc'\n  .split(substring)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s => s.toLowerCase())\n  .filter(s => s.length > 0)\n  .map(s\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpg6cmp6am.fsx(7,3): error FS0010: Unexpected quote symbol in binding\n\n\n\n/tmp/tmpg6cmp6am.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n  (str) => str.includes(substring)\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675797957,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpn3tnn9s9.fsx(7,4): error FS0039: The value or constructor 'str' is not defined. Maybe you want one of the following:\n   string\n   String\n   strings\n   stderr\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}