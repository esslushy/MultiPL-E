{
  "name": "HumanEval_58_common",
  "language": "fs",
  "prompt": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n",
  "tests": "let test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120]\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj99vh6f3.fsx(10,75): error FS0001: This expression was expected to have type\n    'int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 4, 3, 34, 653, 2, 5, 9, 653, 121]\nlet common2 = \n  [5, 7, 1, 5, 9, 653, 121]\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdb12kf8d.fsx(12,75): error FS0001: This expression was expected to have type\n    'int * int * int * int * int * int * int * int * int * int'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  (l1, l2) => {\n    let l1_len = l1.length;\n    let l2_len = l2.length;\n    let i = 0;\n    let j = 0;\n    let result = [];\n    while (i < l1_len && j < l2_len) {\n      if (l1[i] === l2[j]) {\n        result.push(l1[i]);\n        i++;\n      } else {\n        j++;\n      }\n    }\n    return result;\n  };\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjis3lauy.fsx(16,12): error FS0010: Unexpected symbol ';' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [l1, l2]\nlet common2 = \n  [l1, l2]\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp99f5k8a8.fsx(9,4): error FS0039: The value or constructor 'l1' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121]\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa1artfdk.fsx(10,75): error FS0001: This expression was expected to have type\n    'int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  (l1, l2) => {\n    let l1_len = l1.length, l2_len = l2.length;\n    let l1_i = 0, l2_i = 0;\n    while (l1_i < l1_len && l2_i < l2_len) {\n      if (l1[l1_i] < l2[l2_i]) {\n        l1_i++;\n      } else {\n        l2_i++;\n      }\n    }\n    return {\n      l1: l1,\n      l2: l2\n    };\n  };\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8sfxj13g.fsx(12,15): error FS0010: Unexpected symbol ';' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121]\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa1artfdk.fsx(10,75): error FS0001: This expression was expected to have type\n    'int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121]\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa1artfdk.fsx(10,75): error FS0001: This expression was expected to have type\n    'int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 4, 3, 34, 653, 2, 5]\n  .sort()\n  .map(x => x)\n  .map(x => x[0])\n  .map(x => x[1])\n  .map(x => x[2])\n  .map(x => x[3])\n  .map(x => x[4])\n  .map(x => x[5])\n  .map(x => x[6])\n  .map(x => x[7])\n  .map(x => x[8])\n  .map(x => x[9])\n  .map(x => x[10])\n  .map(x => x[11])\n  .map(x => x[12])\n  .map(x => x[13])\n  .map(x => x[14])\n  .map(x => x[15])\n  .map(x => x[16])\n  .map(x => x[17])\n  .map(x => x[18])\n  .map(x => x[19])\n  .map(x => x[20])\n  .map(x => x[21])\n  .map(x => x[22])\n  .map(x => x[23])\n  .map(x => x[24])\n  .map(x => x[25])\n  .map(x => x[26])\n  .map(x => x[27])\n  .map(x => x[28])\n  .map(x => x[29])\n  .map(x => x[30])\n  .map(x => x[31])\n  .map(x => x[32])\n  .map(x => x[33])\n  .map(x => x[34])\n  .map(x => x[35])\n  .map(x => x[36])\n  .map(x => x[37])\n  .map(x => x[38])\n  .map(x => x[39])\n  .map(x => x[40])\n  .map(x => x[41])\n  .map(x => x[42])\n  .map(x => x\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq6lfce1k.fsx(8,3): error FS0010: Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.\n\n\n\n/tmp/tmpq6lfce1k.fsx(54,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  (l1, l2) => {\n    let l1_len = l1.length;\n    let l2_len = l2.length;\n    let res = [];\n    let i = 0;\n    while (i < l1_len && i < l2_len) {\n      if (l1[i] < l2[i]) {\n        res.push(l1[i]);\n        i++;\n      } else {\n        res.push(l2[i]);\n        i++;\n      }\n    }\n    return res;\n  }();\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyw5s1pir.fsx(15,12): error FS0010: Unexpected symbol ';' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  (l1, l2) => {\n    let l1_len = l1.length\n    let l2_len = l2.length\n    let l1_idx = 0\n    let l2_idx = 0\n    let l1_sum = 0\n    let l2_sum = 0\n    let l1_sum_idx = 0\n    let l2_sum_idx = 0\n    while (l1_idx < l1_len && l2_idx < l2_len) {\n      if (l1[l1_idx] < l2[l2_idx]) {\n        l1_sum += l1[l1_idx]\n        l1_sum_idx++\n      } else {\n        l2_sum += l2[l2_idx]\n        l2_sum_idx++\n      }\n      l1_idx++\n      l2_idx++\n    }\n    return {\n      l1_sum,\n      l2_sum,\n      l1_sum_idx,\n      l2_sum_idx\n    }\n  }\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpo4f3t9u7.fsx(20,7): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:7). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpo4f3t9u7.fsx(20,7): error FS0010: Unexpected symbol '}' in expression\n\n\n\n/tmp/tmpo4f3t9u7.fsx(26,5): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (25:7). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120]\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj99vh6f3.fsx(10,75): error FS0001: This expression was expected to have type\n    'int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  (l1, l2) => {\n    let result = {};\n    let i = 0;\n    while (i < l1.length && i < l2.length) {\n      if (l1[i] < l2[i]) {\n        result[l1[i]] = l1[i];\n        i++;\n      } else {\n        result[l2[i]] = l2[i];\n        i++;\n      }\n    }\n    return result;\n  };\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjlypoogj.fsx(13,9): error FS0609: Field bindings must have the form 'id = expr;'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  (l1, l2) => {\n    let l1_len = l1.length;\n    let l2_len = l2.length;\n    let l1_i = 0;\n    let l2_i = 0;\n    let l1_j = 0;\n    let l2_j = 0;\n    let l1_k = 0;\n    let l2_k = 0;\n    while (l1_i < l1_len && l2_i < l2_len) {\n      if (l1[l1_i] < l2[l2_i]) {\n        l1_i++;\n      } else {\n        l2_i++;\n      }\n    }\n    while (l1_i < l1_len) {\n      if (l2[l2_i] < l1[l1_i]) {\n        l1_i++;\n      } else {\n        l2_i++;\n      }\n    }\n    while (l2_i < l2_len) {\n      if (l1[l1_i] < l2[l2_i]) {\n        l1_i++;\n      } else {\n        l2_i++;\n      }\n    }\n    return {\n      l1: l1,\n      l2: l2\n    };\n  }\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_v39ynb8.fsx(18,15): error FS0010: Unexpected symbol ';' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121]\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa1artfdk.fsx(10,75): error FS0001: This expression was expected to have type\n    'int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int * int'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  (l1, l2) => {\n    let l1_len = l1.length;\n    let l2_len = l2.length;\n    let common_len = Math.min(l1_len, l2_len);\n    let common_index = 0;\n    let common_index_len = 0;\n    let common_index_max = l1_len - 1;\n    let common_index_min = 0;\n    let common_index_max_len = 0;\n    let common_index_min_len = 0;\n    let common_index_max_len_len = 0;\n    let common_index_min_len_len = 0;\n    let common_index_max_len_len_len = 0;\n    let common_index_min_len_len_len = 0;\n    let common_index_max_len_len_len_len = 0;\n    let common_index_min_len_len_len_len = 0;\n    let common_index_max_len_len_len_len_len = 0;\n    let common_index_min_len_len_len_len_len = 0;\n    let common_index_max_len_len_len_len_len_len = 0;\n    let common_index_min_len_len_len_len_len_len = 0;\n    let common_index_max_len_len_len_len_len_len_len = 0;\n    let common_index_min_len_len_len_len_len_len_len = 0;\n    let common_index_max_len_len_len_len_len_len_len_len = 0;\n    let common_index_min_len_len_len_len_len_len_len_len_len = 0;\n    let common_index_max_len_len_len_len_len_len_len_len_len_len = 0;\n    let common_index_min_len_len_len_len_len_len_len_len_len_len_len = 0;\n    let common_index_max_len_len_len_len_len_len_len\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdrn4trxh.fsx(34,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n\n\n/tmp/tmpdrn4trxh.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 4, 3, 34, 653, 2, 5]\n  .sort()\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  .map(l2)\n  .map(l1)\n  \nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1a52nsoq.fsx(8,3): error FS0010: Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  [1, 4, 3, 34, 653, 2, 5]\n  .sort()\n  .map(x => x)\n  .map(x => x[0])\n  .map(x => x[1])\n  .map(x => x[2])\n  .map(x => x[3])\n  .map(x => x[4])\n  .map(x => x[5])\n  .map(x => x[6])\n  .map(x => x[7])\n  .map(x => x[8])\n  .map(x => x[9])\n  .map(x => x[10])\n  .map(x => x[11])\n  .map(x => x[12])\n  .map(x => x[13])\n  .map(x => x[14])\n  .map(x => x[15])\n  .map(x => x[16])\n  .map(x => x[17])\n  .map(x => x[18])\n  .map(x => x[19])\n  .map(x => x[20])\n  .map(x => x[21])\n  .map(x => x[22])\n  .map(x => x[23])\n  .map(x => x[24])\n  .map(x => x[25])\n  .map(x => x[26])\n  .map(x => x[27])\n  .map(x => x[28])\n  .map(x => x[29])\n  .map(x => x[30])\n  .map(x => x[31])\n  .map(x => x[32])\n  .map(x => x[33])\n  .map(x => x[34])\n  .map(x => x[35])\n  .map(x => x[36])\n  .map(x => x[37])\n  .map(x => x[38])\n  .map(x => x[39])\n  .map(x => x[40])\n  .map(x => x[41])\n  .map(x => x[42])\n  .map(x => x\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq6lfce1k.fsx(8,3): error FS0010: Unexpected symbol '.' in binding. Expected incomplete structured construct at or before this point or other token.\n\n\n\n/tmp/tmpq6lfce1k.fsx(54,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (6:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  (l1, l2) => {\n    let l1_i = 0;\n    let l2_i = 0;\n    while (l1_i < l1.length && l2_i < l2.length) {\n      if (l1[l1_i] < l2[l2_i]) {\n        l1_i++;\n      } else {\n        l2_i++;\n      }\n    }\n    return l1_i === l2_i ? l1 : l2;\n  }(l1, l2);\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp9ksyh6gp.fsx(12,15): error FS0010: Unexpected symbol ';' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n  (l1, l2) => {\n    let l1_len = l1.length;\n    let l2_len = l2.length;\n    let res = [];\n    let i = 0;\n    while (i < l1_len) {\n      let l1_i = l1[i];\n      let l2_i = l2[i];\n      if (l1_i < l2_i) {\n        res.push(l1_i);\n      } else {\n        res.push(l2_i);\n      }\n      i++;\n    }\n    return res;\n  };\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675797436,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4g54c_al.fsx(17,9): error FS0010: Unexpected keyword 'else' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}