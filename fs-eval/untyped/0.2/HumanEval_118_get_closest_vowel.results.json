{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "fs",
  "prompt": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n",
  "tests": "let test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['A'..'Z']\n    let vowels_to_find_list = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list = vowels_to_find |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list = vowels_to_find_list |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list_list = vowels_to_find_list_list |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list_list = vowels_to_find_list_list_list |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list_list = vowels_to_find_list_list_list |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list_list = vowels_to_find_list_list_list |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list_list = vowels_to_find_list_list_list |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list_list = vowels_to_find_list_list_list |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list_list = vowels_to_find_list_list_list |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list_list = vowels_to_find_list_list_list |> List.map (fun c -> c.ToString())\n    let vowels_to_find_list_list_list_list = vowels_to_find_list_list_list |> List\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy_02jgkx.fsx(25,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> Seq.contains c)\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.reduce (fun acc c -> acc + c)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520699,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = ['a'..'z']\n    let vowels_in_word_end = ['a'..'z']\n    let vowels_in_word_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['a\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppw40_3te.fsx(33,43): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmppw40_3te.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray() |> Array.filter (fun c -> vowels |> Array.contains c)\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        let vowels_in_word = vowels_in_word |> Array.map (fun c -> c.ToString())\n        let vowels = vowels_in_word |> Array.filter (fun c -> vowels |> Array.contains c)\n        if vowels.Length = 0 then\n            \"\"\n        else\n            vowels |> Array.map (fun c -> c.ToString()) |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwxhfqweq.fsx(13,26): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpafvq1kxc.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpafvq1kxc.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpafvq1kxc.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpafvq1kxc.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpafvq1kxc.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpafvq1kxc.fsx(61,5): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpafvq1kxc.fsx(43,23): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpe6h5dkem.fsx(26,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpe6h5dkem.fsx(43,1): error FS0010: Unexpected identifier in expression. Expected 'in' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpsagb17na.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqpnz5c33.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqpnz5c33.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqpnz5c33.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqpnz5c33.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqpnz5c33.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"t\"\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps87p8q1v.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgn5la0n8.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left_vowels_right_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels_right_vowels_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left_vowels_right_vowels_right_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels_right_vowels_right_vowels_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left_vowels_right_vowels_right_vowels_right_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels_right_vowels_right_vowels_right_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqszg2yjc.fsx(26,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = vowels |> List.filter (fun x -> x <> 'a' && x <> 'e')\n    let vowels_to_find_end = vowels |> List.filter (fun x -> x <> 'a' && x <> 'e')\n    let vowels_to_find_start = vowels |> List.filter (fun x -> x <> 'a' && x <> 'e')\n    let vowels_to_find_end_start = vowels |> List.filter (fun x -> x <> 'a' && x <> 'e' && x <> 'i')\n    let vowels_to_find_end_start_end = vowels |> List.filter (fun x -> x <> 'a' && x <> 'e' && x <> 'i' && x <> 'o')\n    let vowels_to_find_end_start_end_end = vowels |> List.filter (fun x -> x <> 'a' && x <> 'e' && x <> 'i' && x <> 'o' && x <> 'u')\n    let vowels_to_find_end_start_end_end_end = vowels |> List.filter (fun x -> x <> 'a' && x <> 'e' && x <> 'i' && x <> 'o' && x <> 'u' && x <> 'y')\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.filter (fun x -> x <> 'a' && x <> 'e' && x <> 'i' && x <> 'o' && x <> 'u' && x <> 'y' && x <> 'a')\n    let vowels_to_find_end_start_end_end_end_end_end = vowels |> List.filter (fun x -> x <> 'a' && x <> 'e' && x <> 'i' && x <> 'o' && x <> 'u' && x <> 'y' && x <\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgli0v5w4.fsx(22,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmpgli0v5w4.fsx(22,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (21:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [|\n            'a'\n            'e'\n            'i'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            'u'\n            'y'\n            'o'\n            \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4ns07h2e.fsx(115,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp4ns07h2e.fsx(115,1): error FS0010: Unexpected keyword 'let' or 'use' in binding. Expected '|]' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length) |> fun c -> c.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520699,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgn5la0n8.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqpnz5c33.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqpnz5c33.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqpnz5c33.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqpnz5c33.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqpnz5c33.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c ->\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpxlz_luvi.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpxlz_luvi.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpxlz_luvi.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpxlz_luvi.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpxlz_luvi.fsx(41,24): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpsagb17na.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    let vowels_in_word = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    if vowels.Length = 0 && vowels_in_word.Length = 0 then \"\"\n    else\n        let closest_vowel = \n            vowels\n            |> List.sortBy (fun c -> c.ToString())\n            |> List.head\n        let closest_vowel_in_word = \n            vowels_in_word\n            |> List.sortBy (fun c -> c.ToString())\n            |> List.head\n        closest_vowel_in_word\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520699,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"Yogurt\"\n            \"Full\"\n            \"Quick\"\n            \"Ab\"\n            \"U\"\n            \"Yogurt\"\n            \"Full\"\n            \"Quick\"\n            \"Ab\"\n            \"U\"\n            \"Yogurt\"\n            \"Full\"\n        ]\n    let vowels_index = vowels |> Array.findIndex (fun v -> v = word)\n    vowels.[vowels_index]\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675520698,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq9jkw_mv.fsx(33,34): error FS0001: Type mismatch. Expecting a\n    'string list -> 'a'    \nbut given a\n    ''b[] -> int'    \nThe type 'string list' does not match the type ''a[]'\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}