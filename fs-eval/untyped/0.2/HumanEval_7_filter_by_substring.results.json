{
  "name": "HumanEval_7_filter_by_substring",
  "language": "fs",
  "prompt": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n",
  "tests": "let test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        match strings with\n        | [] -> None\n        | head::tail ->\n            if head.StartsWith substring then\n                Some (head, tail)\n            else\n                filter_by_substring' tail (substring + head)\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjgums594.fsx(18,33): error FS0001: This expression was expected to have type\n    '(string * string list) option'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (substrings:string list) (substring:string) =\n        if strings |> List.contains substring then\n            substrings\n        else\n            filter_by_substring' (substrings @ [substring]) substring\n    filter_by_substring' [] substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520740,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (acc: string list) (substring: string) =\n        match substring with\n        | \"\" -> acc\n        | _ -> filter_by_substring' (acc @ [substring]) (substring.Substring(1))\n    filter_by_substring' [] strings\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpp0o1fzhs.fsx(14,21): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (acc: string list) (substring: string) =\n        match substring with\n        | 'a' -> acc\n        | 'b' -> filter_by_substring' (acc @ [substring]) 'b'\n        | 'c' -> filter_by_substring' (acc @ [substring]) 'c'\n        | 'd' -> filter_by_substring' (acc @ [substring]) 'd'\n        | 'e' -> filter_by_substring' (acc @ [substring]) 'e'\n        | 'f' -> filter_by_substring' (acc @ [substring]) 'f'\n        | 'g' -> filter_by_substring' (acc @ [substring]) 'g'\n        | 'h' -> filter_by_substring' (acc @ [substring]) 'h'\n        | 'i' -> filter_by_substring' (acc @ [substring]) 'i'\n        | 'j' -> filter_by_substring' (acc @ [substring]) 'j'\n        | 'k' -> filter_by_substring' (acc @ [substring]) 'k'\n        | 'l' -> filter_by_substring' (acc @ [substring]) 'l'\n        | 'm' -> filter_by_substring' (acc @ [substring]) 'm'\n        | 'n' -> filter_by_substring' (acc @ [substring]) 'n'\n        | 'o' -> filter_by_substring' (acc @ [substring]) 'o'\n        | 'p' -> filter_by_substring' (acc @ [substring]) 'p'\n        | 'q' -> filter_by_substring' (acc @ [substring]) 'q'\n        | 'r' -> filter_by_substring' (acc @ [substring]) 'r'\n        | 's' -> filter_by_substring' (acc @ [substring]) 's'\n        | 't' -> filter_by_substring' (acc @ [substring]) 't'\n        | 'u' -> filter_by_substring' (acc @ [sub\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpn3z37nae.fsx(30,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpn3z37nae.fsx(30,1): error FS0010: Unexpected keyword 'let' or 'use' in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    strings\n    |> List.filter (fun s -> s.Contains(substring))\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppvahjq83.fsx(8,30): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        if strings.IsEmpty then\n            substring\n        else\n            let sub = strings.Head\n            if sub.StartsWith substring then\n                strings.Tail.Head\n            else\n                filter_by_substring' (strings.Tail) sub\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptfmzvr9c.fsx(19,33): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        if strings |> List.exists (fun s -> s.Contains substring) then\n            strings\n        else\n            filter_by_substring' (strings |> List.filter (fun s -> s.Contains substring)) (substring + substring)\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520740,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        if strings |> List.exists (fun s -> s.Contains substring) then\n            strings\n        else\n            strings |> List.filter (fun s -> s.Contains substring)\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520740,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (acc:string list) (substring:string) =\n        match substring.ToCharArray() with\n        | [|'a'|] -> acc\n        | [|'b'|] -> filter_by_substring' (acc@[substring]) 'b'\n        | [|'c'|] -> filter_by_substring' (acc@[substring]) 'c'\n        | [|'d'|] -> filter_by_substring' (acc@[substring]) 'd'\n        | [|'e'|] -> filter_by_substring' (acc@[substring]) 'e'\n        | [|'f'|] -> filter_by_substring' (acc@[substring]) 'f'\n        | [|'g'|] -> filter_by_substring' (acc@[substring]) 'g'\n        | [|'h'|] -> filter_by_substring' (acc@[substring]) 'h'\n        | [|'i'|] -> filter_by_substring' (acc@[substring]) 'i'\n        | [|'j'|] -> filter_by_substring' (acc@[substring]) 'j'\n        | [|'k'|] -> filter_by_substring' (acc@[substring]) 'k'\n        | [|'l'|] -> filter_by_substring' (acc@[substring]) 'l'\n        | [|'m'|] -> filter_by_substring' (acc@[substring]) 'm'\n        | [|'n'|] -> filter_by_substring' (acc@[substring]) 'n'\n        | [|'o'|] -> filter_by_substring' (acc@[substring]) 'o'\n        | [|'p'|] -> filter_by_substring' (acc@[substring]) 'p'\n        | [|'q'|] -> filter_by_substring' (acc@[substring]) 'q'\n        | [|'r'|] -> filter_by_substring' (acc@[substring]) 'r'\n        | [|'s'|\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpoxadcz_5.fsx(28,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpoxadcz_5.fsx(28,1): error FS0010: Unexpected keyword 'let' or 'use' in pattern\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        if strings |> List.contains substring then\n            strings\n        else\n            let new_strings = strings |> List.filter (fun s -> s.Contains substring)\n            filter_by_substring' new_strings substring\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520740,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        match strings with\n        | [] -> None\n        | head::tail ->\n            if substring.StartsWith(head) then\n                Some(head, tail)\n            else\n                filter_by_substring' tail (substring.Substring(1))\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3scb7mol.fsx(18,33): error FS0001: This expression was expected to have type\n    '(string * string list) option'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    strings \n    |> List.filter (fun s -> s.Contains substring)\n    |> List.map (fun s -> s.Substring(substring.Length))\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8b19ask8.fsx(8,30): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (acc: string list) (acc_substring: string) =\n        if acc_substring.StartsWith(substring) then\n            acc\n        else\n            filter_by_substring' (acc@[acc_substring]) substring\n    filter_by_substring' [] strings\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpb423i4_2.fsx(8,12): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        match strings with\n        | [] -> []\n        | head::tail ->\n            if substring.StartsWith(head) then\n                filter_by_substring' tail (substring.Substring(1))\n            else\n                filter_by_substring' tail (substring.Substring(1))\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520740,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        match strings with\n        | [] -> []\n        | head::tail ->\n            if substring.StartsWith(head) then\n                filter_by_substring' tail (substring.Substring(1))\n            else\n                filter_by_substring' tail (substring.Substring(1))\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520740,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        if strings |> List.contains substring then\n            strings\n        else\n            filter_by_substring' (strings |> List.append [substring]) (substring + substring)\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520740,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (substrings: string list) (substring: string) =\n        match strings with\n        | [] -> []\n        | head::tail ->\n            if substring.StartsWith(head) then\n                filter_by_substring' tail (substring.Substring(1))\n            else\n                filter_by_substring' tail (substring.Substring(1))\n    filter_by_substring' [] substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpxy_6zp66.fsx(11,16): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (acc:string list) (substring:string) =\n        if String.IsNullOrEmpty substring then acc\n        else\n            let new_acc = List.filter (fun x -> x.Contains substring) acc\n            filter_by_substring' new_acc substring\n    filter_by_substring' [] strings\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpp7j7chdw.fsx(8,19): error FS0039: The value, constructor, namespace or type 'IsNullOrEmpty' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings:string list) (substring:string) =\n        match strings with\n        | [] -> None\n        | head::tail ->\n            if substring.StartsWith(head) then\n                Some(substring.Substring(head.Length))\n            else\n                filter_by_substring' tail substring\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpydu879ym.fsx(18,33): error FS0001: This expression was expected to have type\n    'string option'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Filter an input list of strings only for ones that contain given substring\n// >>> filter_by_substring([], 'a')\n// []\n// >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n// ['abc', 'bacd', 'array']\nlet filter_by_substring strings substring = \n    let rec filter_by_substring' (strings: string list) (substring: string) =\n        match strings with\n        | [] -> None\n        | head::tail ->\n            if substring.StartsWith(head) then\n                Some(head, tail)\n            else\n                filter_by_substring' tail (substring.Substring(1))\n    filter_by_substring' strings substring\nlet test() = \n  let candidate = filter_by_substring\n  assert (candidate [] \"john\" = [])\n  assert (candidate [\"xxx\"; \"asd\"; \"xxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xxx\" = [\"xxx\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"xxx\"; \"asd\"; \"aaaxxy\"; \"john doe\"; \"xxxAAA\"; \"xxx\"] \"xx\" = [\"xxx\"; \"aaaxxy\"; \"xxxAAA\"; \"xxx\"])\n  assert (candidate [\"grunt\"; \"trumpet\"; \"prune\"; \"gruesome\"] \"run\" = [\"grunt\"; \"prune\"])\n  0\n\ntest()",
      "timestamp": 1675520739,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3scb7mol.fsx(18,33): error FS0001: This expression was expected to have type\n    '(string * string list) option'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}