{
  "name": "HumanEval_158_find_max",
  "language": "fs",
  "prompt": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n",
  "tests": "let test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with\n        | [] -> 0\n        | x::xs -> \n            match x with\n            | \"name\" -> find_max_rec xs\n            | \"of\" -> find_max_rec xs\n            | \"string\" -> find_max_rec xs\n            | _ -> find_max_rec xs\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdpxin0h3.fsx(21,48): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec (words: string list) = \n        match words with \n        | [] -> 0\n        | x::xs -> \n            let max = List.max xs\n            if max = x then \n                find_max_rec xs\n            else\n                find_max_rec (xs@[max])\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps4in4an2.fsx(21,48): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words =\n        match words with\n        | [] -> 0\n        | word :: rest ->\n            let max_number =\n                match word with\n                | \"name\" -> 1\n                | \"of\" -> 2\n                | \"string\" -> 3\n                | \"game\" -> 4\n                | _ -> failwith \"Invalid word\"\n            let number = find_max_rec rest\n            number + max_number\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprqgq7z9w.fsx(25,48): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with\n        | [] -> \"\"\n        | word :: rest -> \n            let max_char = \n                words \n                |> List.map (fun word -> \n                    word.Length)\n                |> List.max\n            let word = word.ToCharArray()\n            if word.Length > max_char then\n                word.[0..max_char-1]\n            else\n                word\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptgizt9lh.fsx(16,21): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with\n        | [] -> \"\"\n        | x::xs -> \n            let rec find_max_rec_rec words = \n                match words with\n                | [] -> \"\"\n                | x::xs -> \n                    let rec find_max_rec_rec_rec words = \n                        match words with\n                        | [] -> \"\"\n                        | x::xs -> \n                            let rec find_max_rec_rec_rec words = \n                                match words with\n                                | [] -> \"\"\n                                | x::xs -> \n                                    let rec find_max_rec_rec_rec words = \n                                        match words with\n                                        | [] -> \"\"\n                                        | x::xs -> \n                                            let rec find_max_rec_rec_rec words = \n                                                match words with\n                                                | [] -> \"\"\n                                                | x::xs -> \n                                                    let rec find_max_rec_rec_rec words = \n                                                        match words with\n                                                        | [] -> \"\"\n                                                        | x::xs -> \n                                                            let rec find_max_rec_rec_rec words = \n                                                                match words with\n                                                                | [] -> \"\"\n                                                                | x::xs -> \n                                                                    let rec find_max_rec_rec_rec words = \n                                                                        match words with\n                                                                        | [] -> \"\"\n                                                                        | x::xs -> \n                                                                            let rec find_max_rec_rec_rec words = \n                                                                                match words with\n                                                                                | [] -> \"\"\n                                                                                | x::xs -> \n                                                                                    let rec find_max_rec_rec_rec words = \n                                                                                        match words with\n                                                                                        | [] -> \"\"\n                                                                                        | x::xs -> \n                                                                                            let rec find_max_rec_rec_rec words = \n                                                                                               match words with\n                                                                                               | [] -> \"\"\n                                                                                               | x::xs -> \n                                                                                                   let rec find_max_rec_rec_rec words = \n                                                                                                       match words with\n                                                                                                       | [] -> \"\"\n                                                                                                       | x::xs\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520477,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppovy_b7f.fsx(61,1): error FS0010: Incomplete structured construct at or before this point in pattern matching. Expected '->' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words =\n        match words with\n        | [] -> None\n        | x::xs ->\n            let max_char = List.max x\n            if max_char <> x then\n                Some(max_char, xs)\n            else\n                find_max_rec xs\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpf9onayde.fsx(14,28): error FS0001: Type mismatch. Expecting a\n    ''a'    \nbut given a\n    ''a list'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec acc words = \n        match words with\n        | [] -> acc\n        | (word, _)::tail -> \n            let new_acc = find_max_rec acc tail\n            if word = new_acc then acc\n            else find_max_rec new_acc tail\n    find_max_rec \"\" words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7jf8_6wu.fsx(19,22): error FS0001: This expression was expected to have type\n    'string * 'a'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with\n        | [] -> \"\"\n        | x::xs -> \n            let max_char = List.max xs\n            if max_char = \"\" then \n                find_max_rec xs\n            else\n                let max_char = List.max xs\n                if max_char = \"\" then \n                    find_max_rec xs\n                else\n                    max_char\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with\n        | [] -> \"\"\n        | x::xs -> \n            match x with\n            | \"name\" -> \"name\"\n            | \"of\" -> \"of\"\n            | \"string\" -> \"string\"\n            | \"game\" -> \"game\"\n            | _ -> find_max_rec xs\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with\n        | [] -> 0\n        | x::xs -> \n            let max_count = List.max xs\n            if max_count > List.length xs then\n                List.rev xs\n                |> find_max_rec\n            else\n                max_count\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnysgdwdg.fsx(22,22): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec (words: string list) =\n        match words with\n        | [] -> \"\"\n        | head::tail ->\n            let max_char = List.max [for word in words -> word.Length]\n            if head.Length > max_char then\n                find_max_rec tail\n            else\n                head\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec (words:string list) = \n        match words with\n        | [] -> 0\n        | x::xs -> \n            let max_num = List.max xs\n            if max_num = 0 then 0\n            else find_max_rec xs\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0h9s865a.fsx(14,26): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with\n        | [] -> \"\"\n        | head::tail -> \n            let max_count = List.length head\n            if max_count > List.length tail then\n                find_max_rec tail\n            else\n                head\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwakdygmh.fsx(17,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is 'string'. This branch returns a value of type ''a list'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words =\n        match words with\n        | [] -> \"\"\n        | (word, words)::tail ->\n            if List.length words = List.length tail then\n                let max_word = List.max words\n                let max_words = List.length words\n                if max_words > max_word then\n                    find_max_rec tail\n                else\n                    word\n            else\n                find_max_rec tail\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3ok106fn.fsx(25,22): error FS0001: This expression was expected to have type\n    'string * int list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with\n        | [] -> 0\n        | word :: rest -> \n            let max_count = \n                match find_max_rec rest with\n                | 0 -> 0\n                | _ -> max_count\n            if max_count = 0 then word\n            else find_max_rec rest\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4gl1air3.fsx(16,24): error FS0039: The value or constructor 'max_count' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with \n        | [] -> \"\"\n        | head :: tail -> \n            let max_length = List.maxBy (fun word -> word.Length) words\n            let max_word = head.Substring(0, max_length)\n            if max_length = 0 then max_word\n            else find_max_rec tail\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpeb6cnbjw.fsx(13,54): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec (words:list<string>) =\n        match words with\n        | [] -> 0\n        | head::tail ->\n            let max_count = List.length head\n            if max_count > List.length tail then\n                find_max_rec tail\n            else\n                let max_count = List.length tail\n                if max_count > List.length head then\n                    find_max_rec head\n                else\n                    find_max_rec tail\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpiojdn1g5.fsx(13,41): error FS0001: This expression was expected to have type\n    ''a list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec (words:list<string>) = \n        match words with\n        | [] -> \"\"\n        | head::tail -> \n            let max = head.Length\n            if head.Length > max then\n                let head_max = head.Length\n                let tail_max = tail.Length\n                let max_head = head.Length\n                let max_tail = tail.Length\n                let max_head_max = head_max\n                let max_tail_max = tail_max\n                let max_head_max_tail = head_max\n                let max_tail_max_tail = tail_max\n                let max_head_max_tail_max = head_max\n                let max_tail_max_tail_max = tail_max\n                let max_head_max_tail_max_tail = head_max\n                let max_tail_max_tail_max_tail = tail_max\n                let max_head_max_tail_max_tail_max = head_max\n                let max_tail_max_tail_max_tail_max = tail_max\n                let max_head_max_tail_max_tail_max_tail = tail_max\n                let max_tail_max_tail_max_tail_max_tail = tail_max\n                let max_head_max_tail_max_tail_max_tail_max = tail_max\n                let max_tail_max_tail_max_tail_max_tail = tail_max\n                let max_head_max_tail_max_tail_max_tail_max = tail_max\n                let max_tail_max_tail_max_tail_max_tail = tail_max\n                let max_head_max_tail_max_tail_max_tail_max = tail_max\n                let max_tail_max_tail_max_tail_max_tail = tail_max\n                let max_head_max_tail_max_tail_max_tail_max = tail_max\n                let max_tail_max_tail_max_tail_max_tail = tail_max\n                let max_head_max_tail_max_tail_max_tail_max = tail_max\n                let max_tail_\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520477,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5t29bs9l.fsx(41,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec words = \n        match words with\n        | [] -> 0\n        | x::xs -> \n            let max = \n                match x with\n                | \"name\" -> 1\n                | \"of\" -> 2\n                | \"string\" -> 3\n                | \"game\" -> 4\n                | _ -> failwith \"Invalid word\"\n            find_max_rec xs\n    find_max_rec words\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520478,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkq7f6ony.fsx(24,48): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Write a function that accepts a list of strings.\n// The list contains different words. Return the word with maximum number\n// of unique characters. If multiple strings have maximum number of unique\n// characters, return the one which comes first in lexicographical order.\n// find_max([\"name\", \"of\", \"string\"]) == \"string\"\n// find_max([\"name\", \"enam\", \"game\"]) == \"enam\"\n// find_max([\"aaaaaaa\", \"bb\" ,\"cc\"]) == \"\"aaaaaaa\"\nlet find_max words = \n    let rec find_max_rec (words:string list) =\n        match words with\n        | [] -> 0\n        | head::tail ->\n            let max_count = List.length words - 1\n            if head.Length > max_count then\n                find_max_rec tail\n            else\n                let max_count = List.length words - 1\n                if head.Length > max_count then\n                    find_max_rec tail\n                else\n                    let max_count = List.length words - 1\n                    if head.Length > max_count then\n                        find_max_rec tail\n                    else\n                        let max_count = List.length words - 1\n                        if head.Length > max_count then\n                            find_max_rec tail\n                        else\n                            let max_count = List.length words - 1\n                            if head.Length > max_count then\n                                find_max_rec tail\n                            else\n                                let max_count = List.length words - 1\n                                if head.Length > max_count then\n                                    find_max_rec tail\n                                else\n                                    let max_count = List.length words - 1\n                                    if head.Length > max_count then\n                                        find_max_rec tail\n                                    else\n                                        let max_count = List.length words - 1\n                                        if head.Length > max_count then\n                                            find_max_rec tail\n                                        else\n                                            let max_count = List.length words - 1\n                                            if head.Length > max_count then\n                                                find_max_rec tail\n                                            else\n                                                let max_count = List.length words - 1\n                                                if head.Length > max_count then\n                                                    find_max_rec tail\n                                                else\n                                                    let max_count = List.length words - 1\n                                                    if head.Length > max_count then\n                                                        find_max_rec tail\n                                                    else\n                                                        let max_count = List.length words - 1\n                                                        if head.Length > max_count then\n                                                            find_max_rec tail\n                                                        else\n                                                            let max_count = List.length words - 1\n                                                            if head.Length > max_count then\n                                                                find_max_\nlet test() = \n  let candidate = find_max\n  assert (candidate [\"name\"; \"of\"; \"string\"] = \"string\")\n  assert (candidate [\"name\"; \"enam\"; \"game\"] = \"enam\")\n  assert (candidate [\"aaaaaaa\"; \"bb\"; \"cc\"] = \"aaaaaaa\")\n  assert (candidate [\"abc\"; \"cba\"] = \"abc\")\n  assert (candidate [\"play\"; \"this\"; \"game\"; \"of\"; \"footbott\"] = \"footbott\")\n  assert (candidate [\"we\"; \"are\"; \"gonna\"; \"rock\"] = \"gonna\")\n  assert (candidate [\"we\"; \"are\"; \"a\"; \"mad\"; \"nation\"] = \"nation\")\n  assert (candidate [\"this\"; \"is\"; \"a\"; \"prrk\"] = \"this\")\n  assert (candidate [\"b\"] = \"b\")\n  assert (candidate [\"play\"; \"play\"; \"play\"] = \"play\")\n  0\n\ntest()",
      "timestamp": 1675520477,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7g9hz2f2.fsx(9,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}