{
  "name": "HumanEval_58_common",
  "language": "fs",
  "prompt": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n",
  "tests": "let test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec loop i = \n        match l1 with\n        | [] -> []\n        | x :: xs -> \n            match l2 with\n            | [] -> []\n            | y :: ys -> \n                if i = 0 then \n                    y :: loop (i - 1)\n                else \n                    y :: loop (i - 1)\n    loop 0\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520561,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | x::xs -> \n            let acc' = acc @ [x]\n            common' acc' xs\n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520561,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | hd::tl -> \n            match hd with \n            | hd1 when hd1 = l1 -> common' (hd::acc) tl\n            | hd1 when hd1 = l2 -> common' (hd::acc) tl\n            | _ -> common' (hd::acc) tl\n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwi99_zm7.fsx(15,16): error FS0001: Type mismatch. Expecting a\n    ''a list'    \nbut given a\n    ''a'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l1 l2 = \n        match l1, l2 with \n        | [], [] -> acc\n        | _, [] -> acc\n        | x::xs, y::ys -> \n            if x = y then common' (acc + xs) xs ys\n            else common' (acc + xs) xs ys\n    common' 0 l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpxgtcf8qp.fsx(8,15): warning FS0025: Incomplete pattern matches on this expression. For example, the value '(_,[_])' may indicate a case not covered by the pattern(s).\n\n\n\n/tmp/tmpxgtcf8qp.fsx(14,13): error FS0001: The type ''a list' does not match the type 'int'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc = \n        match l1, l2 with \n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let c1 = List.head acc\n            let c2 = List.last acc\n            let c3 = List.tail acc\n            let c4 = List.rev acc\n            let c5 = List.rev c1\n            let c6 = List.rev c2\n            let c7 = List.rev c3\n            let c8 = List.rev c4\n            let c9 = List.rev c5\n            let c10 = List.rev c6\n            let c11 = List.rev c7\n            let c12 = List.rev c8\n            let c13 = List.rev c9\n            let c14 = List.rev c10\n            let c15 = List.rev c11\n            let c16 = List.rev c12\n            let c17 = List.rev c13\n            let c18 = List.rev c14\n            let c19 = List.rev c15\n            let c20 = List.rev c16\n            let c21 = List.rev c17\n            let c22 = List.rev c18\n            let c23 = List.rev c19\n            let c24 = List.rev c20\n            let c25 = List.rev c21\n            let c26 = List.rev c22\n            let c27 = List.rev c23\n            let c28 = List.rev c24\n            let c29 = List.rev c25\n            let c30 = List.rev c26\n            let c31 = List.rev c27\n            let c32 = List.rev c28\n            let c33 = List.rev c29\n            let c34 = List.rev c30\n            let c35 = List.rev c31\n            let c36 = List.rev c32\n            let c37 = List.rev c33\n            let c38 = List.rev c34\n            let c39 = List.rev c35\n            let c40 = List.rev c36\n            let c41 = List.rev c37\n            let c42 = List.rev c38\n            let c\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpv_256a0p.fsx(56,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | hd::tl -> \n            if hd = l1 then common' (hd::acc) tl\n            else common' (hd::acc) tl\n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp6txb99ty.fsx(13,16): error FS0001: Type mismatch. Expecting a\n    ''a list'    \nbut given a\n    ''a'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | x::xs -> \n            match x with \n            | [] -> common' (acc@[x]) xs\n            | x -> common' (acc@[x]) xs\n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptkdf3c6s.fsx(17,22): error FS0001: This expression was expected to have type\n    ''a list'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | x::xs -> \n            match x with \n            | [] -> common' (acc@[x]) xs\n            | y::ys -> \n                match y with \n                | [] -> common' (acc@[x]) xs\n                | yy -> common' (acc@[x]) xs\n    \n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpx5jxx8s3.fsx(21,22): error FS0001: This expression was expected to have type\n    ''a list list'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | x::xs -> \n            if x = l1 then common' (acc + xs) xs\n            else common' (acc + xs) x::xs\n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_ioun3f2.fsx(12,18): error FS0001: None of the types ''a list, 'a list' support the operator '+'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec loop acc = \n        match l1, l2 with \n        | [], [] -> acc\n        | [], xs -> loop (acc @ [x])\n        | xs, [] -> loop (acc @ [x])\n        | xs, ys -> loop (acc @ [x; y])\n    loop []\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpm9tpdjd5.fsx(10,34): error FS0039: The value or constructor 'x' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | x :: xs -> \n            match x with \n            | [] -> acc\n            | y :: ys -> \n                match y with \n                | [] -> acc\n                | yy -> common' (acc @ [x; yy]) xs ys\n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcmzu6k8x.fsx(16,25): error FS0001: Type mismatch. Expecting a\n    ''a -> 'b'    \nbut given a\n    ''b'    \nThe types ''a' and ''b -> 'a' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | x::xs -> \n            match x with \n            | [] -> common' (acc@[x]) xs\n            | x -> common' (acc@[x]) xs\n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptkdf3c6s.fsx(17,22): error FS0001: This expression was expected to have type\n    ''a list'    \nbut here has type\n    'int'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | hd::tl -> \n            match hd with \n            | hd1 when hd1 = l1 -> common' (hd::acc) tl\n            | hd1 when hd1 = l2 -> common' (hd::acc) tl\n            | _ -> common' (hd::acc) tl\n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwi99_zm7.fsx(15,16): error FS0001: Type mismatch. Expecting a\n    ''a list'    \nbut given a\n    ''a'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l = \n        match l with \n        | [] -> acc\n        | hd::tl -> \n            match hd with \n            | hd1 when hd1 = l1 -> common' (hd::acc) tl\n            | hd1 when hd1 = l2 -> common' (hd::acc) tl\n            | _ -> common' (hd::acc) tl\n    common' [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwi99_zm7.fsx(15,16): error FS0001: Type mismatch. Expecting a\n    ''a list'    \nbut given a\n    ''a'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l1 l2 = \n        match l1, l2 with \n        | [], [] -> acc\n        | [], _ -> acc\n        | _, [] -> acc\n        | _, _ -> \n            let l1' = List.sort l1\n            let l2' = List.sort l2\n            let l1'' = List.sort l1'\n            let l2'' = List.sort l2'\n            let l1''' = List.sort l1''\n            let l2''' = List.sort l2''\n            let l1'''' = List.sort l1''''\n            let l2'''' = List.sort l2''''\n            let l1''''' = List.sort l1'''''\n            let l2''''' = List.sort l2'''''\n            let l1'''''' = List.sort l1'''''''\n            let l2'''''' = List.sort l2'''''''\n            let l1''''''' = List.sort l1'''''''''\n            let l2''''''' = List.sort l2'''''''''\n            let l1''''''''' = List.sort l1'''''''''''\n            let l2''''''''' = List.sort l2'''''''''''\n            let l1''''''''' = List.sort l1'''''''''''''\n            let l2''''''''' = List.sort l2'''''''''''''\n            let l1''''''''' = List.sort l1'''''''''''''''\n            let l2''''''''' = List.sort l2'''''''''''''''\n            let l1''''''''' = List.sort l1'''''''''''''''''\n            let l2''''''''' = List.sort l2'''''''''''''''''\n            let l1''''''''' = List.sort l1'''''''''''''''''''\n            let l2''''''''' = List.sort l2'''''''''''''''''''\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk0a0l_ro.fsx(36,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520561,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc = \n        match l1, l2 with \n        | [], [] -> acc\n        | [], xs -> acc\n        | xs, [] -> acc\n        | xs, ys -> \n            let acc' = \n                match xs, ys with \n                | [], [] -> acc\n                | [], xs -> acc\n                | xs, [] -> acc\n                | xs, ys -> \n                    let acc' = \n                        match xs, ys with \n                        | [], [] -> acc\n                        | [], xs -> acc\n                        | xs, [] -> acc\n                        | xs, ys -> \n                            let acc' = \n                                match xs, ys with \n                                | [], [] -> acc\n                                | [], xs -> acc\n                                | xs, [] -> acc\n                                | xs, ys -> \n                                    let acc' = \n                                        match xs, ys with \n                                        | [], [] -> acc\n                                        | [], xs -> acc\n                                        | xs, [] -> acc\n                                        | xs, ys -> \n                                            let acc' = \n                                                match xs, ys with \n                                                | [], [] -> acc\n                                                | [], xs -> acc\n                                                | xs, [] -> acc\n                                                | xs, ys -> \n                                                    let acc' = \n                                                        match xs, ys with \n                                                        | [], [] -> acc\n                                                        | [], xs -> acc\n                                                        | xs, [] -> acc\n                                                        | xs, ys -> \n                                                            let acc' = \n                                                                match xs, ys with \n                                                                | [], [] -> acc\n                                                                | [], xs -> acc\n                                                                | xs, [] -> acc\n                                                                | xs, ys -> \n                                                                    let acc' = \n                                                                        match xs, ys with \n                                                                        | [], [] -> acc\n                                                                        | [], xs -> acc\n                                                                        | xs, [] -> acc\n                                                                        |\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpb0u5meo9.fsx(61,1): error FS0010: Incomplete structured construct at or before this point in pattern matching\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec common' acc l1 l2 = \n        match l1, l2 with \n        | [], [] -> acc\n        | [], x::xs -> common' (x::acc) xs\n        | x::xs, y::ys -> common' (x::acc) ys\n        | _ -> failwith \"unreachable\"\n    common' [] l1 l2\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzqwcr6t4.fsx(10,24): error FS0001: Type mismatch. Expecting a\n    ''a'    \nbut given a\n    ''b list -> 'a'    \nThe types ''a' and ''b list -> 'a' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec loop acc = \n        match l1, l2 with \n        | [], [] -> acc\n        | _, [] -> acc\n        | x::xs, y::ys -> loop (x::acc) @ loop (y::acc)\n    loop []\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520561,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp12qko9ht.fsx(8,15): warning FS0025: Incomplete pattern matches on this expression. For example, the value '(_,[_])' may indicate a case not covered by the pattern(s).\n\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return sorted unique common elements for two lists.\n// >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n// [1, 5, 653]\n// >>> common([5, 3, 2, 8], [3, 2])\n// [2, 3]\nlet common l1 l2 = \n    let rec loop acc l = \n        match l with \n        | [] -> acc\n        | x::xs -> \n            if x = l1 then loop (acc @ [x]) xs\n            else loop (acc @ [x]) xs\n    loop [] l1\nlet test() = \n  let candidate = common\n  assert (candidate [1; 4; 3; 34; 653; 2; 5] [5; 7; 1; 5; 9; 653; 121] = [1; 5; 653])\n  assert (candidate [5; 3; 2; 8] [3; 2] = [2; 3])\n  assert (candidate [4; 3; 2; 8] [3; 2; 4] = [2; 3; 4])\n  assert (candidate [4; 3; 2; 8] [] = [])\n  0\n\ntest()",
      "timestamp": 1675520560,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp9bggj15f.fsx(13,13): error FS0001: Type mismatch. Expecting a\n    ''a list'    \nbut given a\n    ''a'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}