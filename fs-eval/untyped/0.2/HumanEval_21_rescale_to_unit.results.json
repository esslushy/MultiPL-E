{
  "name": "HumanEval_21_rescale_to_unit",
  "language": "fs",
  "prompt": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n",
  "tests": "let test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers:float list) =\n        match numbers with\n        | [] -> numbers\n        | [x] -> [x]\n        | [x;y] -> [x;y]\n        | [x;y;z] -> [x;y;z]\n        | [x;y;z;w] -> [x;y;z;w]\n        | [x;y;z;w;x] -> [x;y;z;w;x]\n        | [x;y;z;w;x;y] -> [x;y;z;w;x;y]\n        | [x;y;z;w;x;y;z] -> [x;y;z;w;x;y;z]\n        | [x;y;z;w;x;y;z;w] -> [x;y;z;w;x;y;z;w]\n        | [x;y;z;w;x;y;z;w;x] -> [x;y;z;w;x;y;z;w;x]\n        | [x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z;w;x;y;z\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520711,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpl14xce7l.fsx(19,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (7:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpl14xce7l.fsx(19,1): error FS0010: Unexpected keyword 'let' or 'use' in pattern. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers:float list) =\n        match numbers with\n        | [] -> numbers\n        | head::tail ->\n            let new_numbers = head::tail\n            rescale_to_unit' new_numbers\n    rescale_to_unit' numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_list (numbers: float list) = \n        match numbers with\n        | [] -> numbers\n        | head::tail -> \n            let new_numbers = head::tail\n            rescale_to_unit_list new_numbers\n    rescale_to_unit_list numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_list (numbers:list<float>) =\n        match numbers with\n        | [] -> []\n        | x::xs ->\n            let new_numbers = List.map (fun y -> if y < x then 1.0 else 0.0) xs\n            rescale_to_unit_list new_numbers\n    rescale_to_unit_list numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_list (numbers: list<float>) =\n        match numbers with\n        | [] -> []\n        | x :: xs ->\n            let new_numbers = List.map (fun y -> (x / y)) numbers\n            rescale_to_unit_list new_numbers\n    rescale_to_unit_list numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_list (numbers:list<float>) =\n        match numbers with\n        | [] -> []\n        | head::tail ->\n            let new_numbers = head::tail\n            rescale_to_unit_list new_numbers\n    rescale_to_unit_list numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers:float list) = \n        match numbers with\n        | [] -> []\n        | [n] -> [n]\n        | n::numbers -> \n            let new_numbers = List.map (fun n -> (n + n/2.0)) numbers\n            rescale_to_unit' new_numbers\n    rescale_to_unit' numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers:float list) =\n        match numbers with\n        | [] -> numbers\n        | x::xs ->\n            let new_numbers = List.map (fun y -> if y < x then 1.0 else 0.0) xs\n            rescale_to_unit' new_numbers\n    rescale_to_unit' numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers: float list) =\n        match numbers with\n        | [] -> numbers\n        | head::tail ->\n            let new_numbers = head::tail\n            rescale_to_unit' new_numbers\n    rescale_to_unit' numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_list (numbers:list<float>) =\n        match numbers with\n        | [] -> numbers\n        | x::xs ->\n            let new_numbers = List.map (fun y -> if y = x then 0.0 else 1.0) xs\n            rescale_to_unit_list new_numbers\n    rescale_to_unit_list numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers:float list) =\n        match numbers with\n        | [] -> []\n        | [n] -> [n]\n        | n::ns ->\n            let new_numbers = List.map (fun n -> n / n) ns\n            rescale_to_unit' new_numbers\n    rescale_to_unit' numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers:list<float>) =\n        match numbers with\n        | [] -> numbers\n        | x::xs ->\n            let new_numbers = x::xs\n            rescale_to_unit' new_numbers\n    rescale_to_unit' numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_list (numbers:list<float>) =\n        match numbers with\n        | [] -> numbers\n        | x::xs ->\n            let new_numbers = List.map (fun y -> if y > x then 1.0 else 0.0) xs\n            rescale_to_unit_list new_numbers\n    rescale_to_unit_list numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_numbers (numbers:float list) = \n        match numbers with\n        | [] -> numbers\n        | head::tail -> \n            let new_numbers = head::tail\n            rescale_to_unit_numbers new_numbers\n    rescale_to_unit_numbers numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers:float list) = \n        match numbers with \n        | [] -> numbers\n        | [n] -> [n]\n        | n::numbers -> \n            let new_numbers = List.map (fun n -> n/numbers.[0]) numbers\n            rescale_to_unit' new_numbers\n    rescale_to_unit' numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_list (numbers:list<float>) =\n        match numbers with\n        | [] -> []\n        | head::tail ->\n            let new_numbers = List.map (fun n -> n * head) numbers\n            rescale_to_unit_list new_numbers\n    rescale_to_unit_list numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers:float list) = \n        match numbers with\n        | [] -> numbers\n        | n::numbers -> \n            let new_numbers = List.map (fun n -> n * n) numbers\n            rescale_to_unit' new_numbers\n    rescale_to_unit' numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_list (numbers:list<float>) = \n        match numbers with\n        | [] -> []\n        | head::tail ->\n            let new_numbers = head::tail\n            let new_numbers = List.map (fun x -> x/numbers.Length) new_numbers\n            rescale_to_unit_list new_numbers\n    rescale_to_unit_list numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3bfd0e8l.fsx(11,68): error FS0001: The type 'int' does not match the type 'float'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit' (numbers:list<float>) =\n        match numbers with\n        | [] -> []\n        | x::xs ->\n            let new_numbers = x::xs\n            rescale_to_unit' new_numbers\n    rescale_to_unit' numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of numbers (of at least two elements), apply a linear transform to that list,\n// such that the smallest number will become 0 and the largest will become 1\n// >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n// [0.0, 0.25, 0.5, 0.75, 1.0]\nlet rescale_to_unit numbers = \n    let rec rescale_to_unit_list (numbers:list<float>) =\n        match numbers with\n        | [] -> numbers\n        | head::tail ->\n            let new_numbers = head::tail\n            rescale_to_unit_list new_numbers\n    rescale_to_unit_list numbers\nlet test() = \n  let candidate = rescale_to_unit\n  assert (candidate [2.0; 49.9] = [0.0; 1.0])\n  assert (candidate [100.0; 49.9] = [1.0; 0.0])\n  assert (candidate [1.0; 2.0; 3.0; 4.0; 5.0] = [0.0; 0.25; 0.5; 0.75; 1.0])\n  assert (candidate [2.0; 1.0; 5.0; 3.0; 4.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  assert (candidate [12.0; 11.0; 15.0; 13.0; 14.0] = [0.25; 0.0; 1.0; 0.5; 0.75])\n  0\n\ntest()",
      "timestamp": 1675520712,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}