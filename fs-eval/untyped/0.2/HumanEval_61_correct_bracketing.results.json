{
  "name": "HumanEval_61_correct_bracketing",
  "language": "fs",
  "prompt": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n",
  "tests": "let test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets = \n        match brackets with \n        | [] -> true\n        | (bracket, rest) :: rest -> \n            if bracket = \"(\" && rest = \")\" then \n                loop rest\n            else \n                loop (bracket :: rest)\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptdxpnrcv.fsx(15,30): error FS0038: 'rest' is bound twice in this pattern\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets =\n        match brackets with\n        | [] -> true\n        | (bracket,bracket') :: rest ->\n            if bracket = bracket' then loop rest\n            else loop rest\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk9e4za2b.fsx(21,21): error FS0001: This expression was expected to have type\n    '('a * 'a) list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets = \n        match brackets with\n        | [] -> true\n        | (bracket, bracket_closing)::tail -> \n            if bracket = bracket_closing then loop tail\n            else loop (bracket::brackets)\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0j25dpk0.fsx(17,24): error FS0001: Type mismatch. Expecting a\n    ''a * 'a'    \nbut given a\n    ''a'    \nThe types ''a' and ''a * 'a' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets =\n        match brackets with\n        | [] -> true\n        | (bracket, closing) :: rest ->\n            match closing with\n            | '(' -> loop rest\n            | ')' -> loop rest\n            | '(' :: closing -> loop rest\n            | closing -> loop rest\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpebceg3q7.fsx(19,15): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets = \n        match brackets with \n        | [] -> true\n        | (bracket,bracket') :: rest -> \n            if bracket = bracket' then loop rest\n            else loop rest\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520692,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpehrukoa1.fsx(21,21): error FS0001: This expression was expected to have type\n    '('a * 'a) list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets =\n        match brackets with\n        | [] -> true\n        | (bracket, rest) :: rest ->\n            if bracket = \"(\" && rest = \")\" then\n                loop rest\n            else\n                loop (bracket :: rest)\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpm5kwbcdd.fsx(15,30): error FS0038: 'rest' is bound twice in this pattern\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets = \n        match brackets with\n        | [] -> true\n        | (bracket, rest) :: rest -> \n            if bracket = \"()\" then loop rest\n            else loop rest\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5h5_0zj8.fsx(15,30): error FS0038: 'rest' is bound twice in this pattern\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets =\n        match brackets with\n        | [] -> true\n        | (bracket,bracket') :: rest ->\n            if bracket = bracket' then\n                loop rest\n            else\n                loop (bracket :: rest)\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3_1lytq3.fsx(19,23): error FS0001: Type mismatch. Expecting a\n    ''a * 'a'    \nbut given a\n    ''a'    \nThe types ''a' and ''a * 'a' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets = \n        match brackets with \n        | [] -> true\n        | (bracket, rest) :: rest' -> \n            match bracket with \n            | \"(\" -> loop rest'\n            | \")\" -> loop rest'\n            | _ -> loop rest'\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520692,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnpx9smxa.fsx(23,21): error FS0001: This expression was expected to have type\n    '(string * 'a) list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets = \n        match brackets with\n        | [] -> true\n        | (bracket, bracket_list) :: rest -> \n            match bracket with\n            | '(' -> loop rest\n            | ')' -> loop rest\n            | '(' :: rest -> loop rest\n            | ')' :: rest -> loop rest\n            | _ -> false\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpo6p7i5qg.fsx(19,15): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop (brackets:string list) =\n        match brackets with\n        | [] -> true\n        | (bracket, rest) :: rest ->\n            if bracket = \"(\" && bracket = \")\" then\n                loop rest\n            else\n                loop rest\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpv6wd_r59.fsx(15,12): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a * 'b'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets =\n        match brackets with\n        | [] -> true\n        | (bracket, bracket_list)::rest ->\n            if bracket = brackets then\n                loop rest\n            else\n                loop (bracket::bracket_list)\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplvekpk1o.fsx(16,26): error FS0001: Type mismatch. Expecting a\n    ''a'    \nbut given a\n    '('a * 'b) list'    \nThe types ''a' and '('a * 'b) list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets = \n        match brackets with\n        | [] -> true\n        | (bracket,bracket') :: rest -> \n            if bracket = \"(\" && bracket' = \")\" then\n                loop rest\n            else\n                loop (bracket :: brackets)\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_tpeuxtl.fsx(19,23): error FS0001: This expression was expected to have type\n    'string * string'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets = \n        match brackets with \n        | [] -> true\n        | (bracket,bracket') :: rest -> \n            if bracket = \"(\" && bracket' = \")\" then \n                loop rest\n            else\n                loop (bracket :: brackets)\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3to1tw65.fsx(19,23): error FS0001: This expression was expected to have type\n    'string * string'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets = \n        match brackets with\n        | [] -> true\n        | (bracket, bracket_bracket)::rest -> \n            if bracket = bracket_bracket then loop rest\n            else loop rest\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520692,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpt3s0hmiz.fsx(21,21): error FS0001: This expression was expected to have type\n    '('a * 'a) list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets =\n        match brackets with\n        | [] -> true\n        | (bracket, rest) :: rest ->\n            if bracket = \"(\" && rest = \")\" then\n                loop rest\n            else\n                loop (bracket :: rest)\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpm5kwbcdd.fsx(15,30): error FS0038: 'rest' is bound twice in this pattern\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets =\n        match brackets with\n        | [] -> true\n        | (bracket,bracket') :: rest ->\n            if bracket = bracket' then\n                loop rest\n            else\n                loop (bracket :: brackets)\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuyn78sgd.fsx(19,23): error FS0001: Type mismatch. Expecting a\n    ''a * 'a'    \nbut given a\n    ''a'    \nThe types ''a' and ''a * 'a' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec loop brackets =\n        match brackets with\n        | [] -> true\n        | (bracket, bracket_list) :: rest ->\n            match bracket with\n            | '(' -> loop rest\n            | ')' -> loop rest\n            | _ -> loop rest\n    loop brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520692,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdct7y0sz.fsx(23,21): error FS0001: This expression was expected to have type\n    '(char * 'a) list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec check_bracket (bracket:string) = \n        if bracket.StartsWith(\"(\") && bracket.EndsWith(\")\") then\n            let brackets = bracket.Substring(1, bracket.Length - 2)\n            let brackets = brackets.Split([|'('; ')'|], System.StringSplitOptions.RemoveEmptyEntries)\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.map (fun x -> x.Trim())\n            let brackets = brackets |> Array.\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520691,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpxwmdrefr.fsx(37,45): error FS0599: Missing qualification after '.'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//brackets is a string of \"(\" and \")\".\n// return True if every opening bracket has a corresponding closing bracket.\n// >>> correct_bracketing(\"(\")\n// False\n// >>> correct_bracketing(\"()\")\n// True\n// >>> correct_bracketing(\"(()())\")\n// True\n// >>> correct_bracketing(\")(()\")\n// False\nlet correct_bracketing brackets = \n    let rec check_bracket (bracket:string) = \n        if bracket.StartsWith(\"(\") && bracket.EndsWith(\")\") then\n            let opening_bracket = bracket.Substring(0, bracket.Length - 2)\n            let closing_bracket = bracket.Substring(bracket.Length - 1)\n            let opening_bracket_has_closing_bracket = brackets |> List.exists (fun b -> b = opening_bracket)\n            let closing_bracket_has_opening_bracket = brackets |> List.exists (fun b -> b = closing_bracket)\n            if opening_bracket_has_opening_bracket && closing_bracket_has_opening_bracket then\n                Some(opening_bracket, opening_bracket)\n            else\n                None\n        else\n            None\n    check_bracket brackets\nlet test() = \n  let candidate = correct_bracketing\n  assert (candidate \"()\" = true)\n  assert (candidate \"(()())\" = true)\n  assert (candidate \"()()(()())()\" = true)\n  assert (candidate \"()()((()()())())(()()(()))\" = true)\n  assert (candidate \"((()())))\" = false)\n  assert (candidate \")(()\" = false)\n  assert (candidate \"(\" = false)\n  assert (candidate \"((((\" = false)\n  assert (candidate \")\" = false)\n  assert (candidate \"(()\" = false)\n  assert (candidate \"()()(()())())(()\" = false)\n  assert (candidate \"()()(()())()))()\" = false)\n  0\n\ntest()",
      "timestamp": 1675520692,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpr988vsip.fsx(18,16): error FS0039: The value or constructor 'opening_bracket_has_opening_bracket' is not defined. Maybe you want one of the following:\n   opening_bracket_has_closing_bracket\n   closing_bracket_has_opening_bracket\n   opening_bracket\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}