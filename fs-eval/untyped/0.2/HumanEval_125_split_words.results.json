{
  "name": "HumanEval_125_split_words",
  "language": "fs",
  "prompt": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n",
  "tests": "let test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzbsptdd4.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzbsptdd4.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzbsptdd4.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzbsptdd4.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzbsptdd4.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token furth",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpp5k76cee.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 =\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkvw2i2e3.fsx(39,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmpkvw2i2e3.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpckti0ozn.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        let words = words.[0].Split([|' '|], StringSplitOptions.None)\n        if words.Length = 0 then\n            [], 0\n        else\n            words.[0].Split([|' '|], StringSplitOptions.None)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.map (fun word -> word.ToUpper())\n            |> Array.map (fun word -> word.ToLower())\n            |\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuycqnqus.fsx(43,13): error FS0010: Unexpected symbol '|' in if/then/else expression. Expected incomplete structured construct at or before this point or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzbsptdd4.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzbsptdd4.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzbsptdd4.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzbsptdd4.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzbsptdd4.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token furth",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzkvejbve.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower()\n    let words_lower = words.ToLower()\n    let words_upper = words.ToUpper()\n    let words_upper_lower = words_upper.ToLower()\n    let words_upper_upper = words_upper.ToUpper()\n    let words_upper_upper_lower = words_upper_upper.ToLower()\n    let words_upper_upper_upper = words_upper_upper.ToUpper()\n    let words_upper_upper_upper_lower = words_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper = words_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_lower = words_upper_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper_upper = words_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_lower = words_upper_upper_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper_upper_upper = words_upper_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_upper_lower = words_upper_upper_upper_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper_upper_upper_upper = words_upper_upper_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_upper_upper = words_upper_upper_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_upper_upper_lower = words_upper_upper_upper_upper_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper_upper_upper_upper_upper = words_upper_upper_upper_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_upper_upper_upper_lower = words_upper_upper_upper_upper_upper_upper_upper_upper.ToLower()\n    let words_upper_\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpt6st0frh.fsx(29,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpp5k76cee.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowercase = words |> Array.map (fun word -> word.ToLower())\n    let ord = lowercase |> Array.map (fun word -> if word.Length % 2 = 0 then ord_of_char word.[0] else ord_of_char word.[1])\n    ord\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpup1w91m1.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowercase = words |> Array.map (fun x -> x.ToLower())\n    let even = lowercase |> Array.filter (fun x -> x % 2 = 0)\n    let odd = lowercase |> Array.filter (fun x -> x % 2 <> 0)\n    even, odd\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5iltji5c.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpckti0ozn.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpp5k76cee.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpi4wmabpu.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower = words |> Array.map (fun word -> word.ToLower())\n    let upper = words |> Array.map (fun word -> word.ToUpper())\n    lower, upper\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpe64fezbl.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd1ps9g5k.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqg6xaug4.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowercase = words |> Array.map (fun word -> word.ToLower())\n    let ord = lowercase |> Array.map (fun word -> if word.Length > 1 then ord_of_char word.[0] else ord_of_char ' ')\n    words, lowercase, ord\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4wu9f8p5.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd1ps9g5k.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675520609,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd1ps9g5k.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}