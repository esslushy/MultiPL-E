{
  "name": "HumanEval_98_count_upper",
  "language": "fs",
  "prompt": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n",
  "tests": "let test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if Char.IsUpper s.[i] then\n            count <- count + 1\n    count\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_rwb79pm.fsx(8,18): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable i = 0\n    let mutable count = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n        count <- count + 1\n    count\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprx28ef_s.fsx(9,15): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if Char.IsUpper s.[i] then\n            count <- count + 1\n    count\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_rwb79pm.fsx(8,18): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if Char.IsUpper s.[i] then\n            count <- count + 1\n    count\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_rwb79pm.fsx(8,18): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let rec count_upper_i s = \n        match s with\n        | 'a' -> 1\n        | 'b' -> 1\n        | 'c' -> 1\n        | 'd' -> 1\n        | 'e' -> 1\n        | 'f' -> 1\n        | 'g' -> 1\n        | 'h' -> 1\n        | 'i' -> 1\n        | 'j' -> 1\n        | 'k' -> 1\n        | 'l' -> 1\n        | 'm' -> 1\n        | 'n' -> 1\n        | 'o' -> 1\n        | 'p' -> 1\n        | 'q' -> 1\n        | 'r' -> 1\n        | 's' -> 1\n        | 't' -> 1\n        | 'u' -> 1\n        | 'v' -> 1\n        | 'w' -> 1\n        | 'x' -> 1\n        | 'y' -> 1\n        | 'z' -> 1\n        | _ -> 0\n    count_upper_i s\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520493,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpfs4vo4c9.fsx(39,21): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable i = 0\n    let mutable count = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n        count <- count + 1\n    count\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprx28ef_s.fsx(9,15): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if s.[i] = 'A' || s.[i] = 'E' || s.[i] = 'I' || s.[i] = 'O' || s.[i] = 'U' || s.[i] = 'Y' || s.[i] = 'Z' || s.[i] = 'a' || s.[i] = 'e' || s.[i] = 'i' || s.[i] = 'o' || s.[i] = 'u' || s.[i] = 'y' || s.[i] = 'z' || s.[i] = 'A' || s.[i] = 'E' || s.[i] = 'I' || s.[i] = 'O' || s.[i] = 'U' || s.[i] = 'Y' || s.[i] = 'Z' || s.[i] = 'a' || s.[i] = 'e' || s.[i] = 'i' || s.[i] = 'o' || s.[i] = 'u' || s.[i] = 'y' || s.[i] = 'z' then\n            count <- count + 1\n    count\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_d_jzxuj.fsx(8,18): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let rec count_upper_i s = \n        match s with\n        | 'A' -> 1\n        | 'B' -> 1\n        | 'C' -> 1\n        | 'D' -> 1\n        | 'E' -> 1\n        | 'F' -> 1\n        | 'G' -> 1\n        | 'H' -> 1\n        | 'I' -> 1\n        | 'J' -> 1\n        | 'K' -> 1\n        | 'L' -> 1\n        | 'M' -> 1\n        | 'N' -> 1\n        | 'O' -> 1\n        | 'P' -> 1\n        | 'Q' -> 1\n        | 'R' -> 1\n        | 'S' -> 1\n        | 'T' -> 1\n        | 'U' -> 1\n        | 'V' -> 1\n        | 'W' -> 1\n        | 'X' -> 1\n        | 'Y' -> 1\n        | 'Z' -> 1\n        | _ -> 0\n    count_upper_i s\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520493,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq548skhz.fsx(39,21): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let rec count_upper_i acc = \n        match s with\n        | 'a' -> acc + 1\n        | 'b' -> acc + 1\n        | 'c' -> acc + 1\n        | 'd' -> acc + 1\n        | 'e' -> acc + 1\n        | 'f' -> acc + 1\n        | 'g' -> acc + 1\n        | 'h' -> acc + 1\n        | 'i' -> acc + 1\n        | 'j' -> acc + 1\n        | 'k' -> acc + 1\n        | 'l' -> acc + 1\n        | 'm' -> acc + 1\n        | 'n' -> acc + 1\n        | 'o' -> acc + 1\n        | 'p' -> acc + 1\n        | 'q' -> acc + 1\n        | 'r' -> acc + 1\n        | 's' -> acc + 1\n        | 't' -> acc + 1\n        | 'u' -> acc + 1\n        | 'v' -> acc + 1\n        | 'w' -> acc + 1\n        | 'x' -> acc + 1\n        | 'y' -> acc + 1\n        | 'z' -> acc + 1\n        | _ -> acc\n    count_upper_i 0\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520493,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1gud5hat.fsx(39,21): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if Char.IsUpper s.[i] then\n            count <- count + 1\n    count\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_rwb79pm.fsx(8,18): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let rec count_upper_i i =\n        if i = s.Length then 0\n        else count_upper_i (i + 1)\n    count_upper_i 0\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpumajizky.fsx(8,16): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let rec count_upper_i acc = \n        match s with\n        | 'a' -> acc + 1\n        | 'b' -> acc + 1\n        | 'c' -> acc + 1\n        | 'd' -> acc + 1\n        | 'e' -> acc + 1\n        | 'f' -> acc + 1\n        | 'g' -> acc + 1\n        | 'h' -> acc + 1\n        | 'i' -> acc + 1\n        | 'j' -> acc + 1\n        | 'k' -> acc + 1\n        | 'l' -> acc + 1\n        | 'm' -> acc + 1\n        | 'n' -> acc + 1\n        | 'o' -> acc + 1\n        | 'p' -> acc + 1\n        | 'q' -> acc + 1\n        | 'r' -> acc + 1\n        | 's' -> acc + 1\n        | 't' -> acc + 1\n        | 'u' -> acc + 1\n        | 'v' -> acc + 1\n        | 'w' -> acc + 1\n        | 'x' -> acc + 1\n        | 'y' -> acc + 1\n        | 'z' -> acc + 1\n        | _ -> acc\n    count_upper_i 0\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520493,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1gud5hat.fsx(39,21): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable i = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n    i\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpliytcuz_.fsx(8,15): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable i = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n    i\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpliytcuz_.fsx(8,15): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable count = 0\n    for i = 0 to s.Length - 1 do\n        if s.[i] = 'A' || s.[i] = 'B' || s.[i] = 'C' || s.[i] = 'D' || s.[i] = 'E' || s.[i] = 'F' || s.[i] = 'G' || s.[i] = 'H' || s.[i] = 'I' || s.[i] = 'J' || s.[i] = 'K' || s.[i] = 'L' || s.[i] = 'M' || s.[i] = 'N' || s.[i] = 'O' || s.[i] = 'P' || s.[i] = 'Q' || s.[i] = 'R' || s.[i] = 'S' || s.[i] = 'T' || s.[i] = 'U' || s.[i] = 'V' || s.[i] = 'W' || s.[i] = 'X' || s.[i] = 'Y' || s.[i] = 'Z' then\n            count <- count + 1\n    count\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcckyndct.fsx(8,18): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let mutable i = 0\n    let mutable count = 0\n    while i < s.Length && Char.IsUpper s.[i] do\n        i <- i + 1\n        count <- count + 1\n    count\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprx28ef_s.fsx(9,15): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let rec count_upper_i acc i = \n        if i = 0 then acc\n        else count_upper_i (acc + 1) (i - 1)\n    count_upper_i 0 s\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520493,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpljuy36vz.fsx(13,21): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let rec count_upper_i s =\n        match s with\n        | 'a' -> 1\n        | 'b' -> 1\n        | 'c' -> 1\n        | 'd' -> 1\n        | 'e' -> 1\n        | 'f' -> 1\n        | 'g' -> 1\n        | 'h' -> 1\n        | 'i' -> 1\n        | 'j' -> 1\n        | 'k' -> 1\n        | 'l' -> 1\n        | 'm' -> 1\n        | 'n' -> 1\n        | 'o' -> 1\n        | 'p' -> 1\n        | 'q' -> 1\n        | 'r' -> 1\n        | 's' -> 1\n        | 't' -> 1\n        | 'u' -> 1\n        | 'v' -> 1\n        | 'w' -> 1\n        | 'x' -> 1\n        | 'y' -> 1\n        | 'z' -> 1\n        | _ -> 0\n    count_upper_i s\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520493,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpazfa00af.fsx(39,21): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let rec count_upper_i s i = \n        if i = 0 then 0\n        else count_upper_i s (i-1)\n    count_upper_i s 0\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520493,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a string s, count the number of uppercase vowels in even indices.\n// For example:\n// count_upper('aBCdEf') returns 1\n// count_upper('abcdefg') returns 0\n// count_upper('dBBE') returns 0\nlet count_upper s = \n    let rec count_upper_i i =\n        if i = s.Length then 0\n        else count_upper_i (i+1)\n    count_upper_i 0\nlet test() = \n  let candidate = count_upper\n  assert (candidate \"aBCdEf\" = 1)\n  assert (candidate \"abcdefg\" = 0)\n  assert (candidate \"dBBE\" = 0)\n  assert (candidate \"B\" = 0)\n  assert (candidate \"U\" = 1)\n  assert (candidate \"\" = 0)\n  assert (candidate \"EEEE\" = 2)\n  0\n\ntest()",
      "timestamp": 1675520492,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpomyanp9v.fsx(8,16): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}