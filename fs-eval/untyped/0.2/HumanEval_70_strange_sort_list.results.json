{
  "name": "HumanEval_70_strange_sort_list",
  "language": "fs",
  "prompt": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n",
  "tests": "let test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec loop acc lst = \n        match lst with \n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520635,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list lst = \n        match lst with\n        | [] -> []\n        | x::xs -> \n            let min_x = min x\n            let max_x = max x\n            let min_y = min y\n            let max_y = max y\n            if min_x < max_x && min_y < max_y then\n                let temp = min_x\n                min_x <- max_x\n                max_x <- temp\n                sort_list xs\n            elif min_y < max_y && min_x < max_x then\n                let temp = min_y\n                min_y <- max_y\n                max_y <- temp\n                sort_list xs\n            else\n                let temp = min_y\n                min_y <- max_y\n                max_y <- temp\n                sort_list xs\n    sort_list lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyui_68bq.fsx(15,29): error FS0039: The value or constructor 'y' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec loop acc lst = \n        match lst with\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520635,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list lst = \n        match lst with\n        | [] -> []\n        | x::xs -> \n            let min_val = min x\n            let max_val = max x\n            let min_val_list = sort_list xs\n            let max_val_list = sort_list xs\n            (min_val_list, max_val_list)\n    sort_list lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqe89ilj_.fsx(17,14): error FS0001: All branches of a pattern match expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type ''a list * 'a list'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list acc lst =\n        match lst with\n        | [] -> acc\n        | x::xs ->\n            let min_val = min x acc\n            let max_val = max x acc\n            let new_list = sort_list (min_val::acc) xs\n            sort_list (max_val::acc) new_list\n    sort_list [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1i65ga9b.fsx(15,39): error FS0001: Type mismatch. Expecting a\n    ''a'    \nbut given a\n    ''a list'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec loop i lst = \n        match lst with \n        | [] -> []\n        | x::xs -> \n            if i = 0 then loop (i-1) xs\n            else loop (i-1) (x::xs)\n    loop 0 lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520635,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list lst = \n        match lst with\n        | [] -> []\n        | x::xs -> \n            let min_val = min x\n            let max_val = max x\n            let new_list = \n                if min_val > max_val then\n                    [min_val, max_val]\n                else\n                    [min_val, max_val]\n            sort_list new_list\n    sort_list lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1vlwy04z.fsx(16,20): error FS0001: The type '('a -> 'a)' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec loop i lst = \n        match lst with\n        | [] -> []\n        | x::xs -> \n            if i = 0 then x::loop (i-1) xs\n            else loop (i-1) (x::xs)\n    loop 0 lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520635,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list acc lst =\n        match lst with\n        | [] -> acc\n        | x::xs ->\n            let min_val = min x acc\n            let max_val = max x acc\n            let new_list = sort_list (min_val::acc) xs\n            sort_list (max_val::acc) new_list\n    sort_list [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1i65ga9b.fsx(15,39): error FS0001: Type mismatch. Expecting a\n    ''a'    \nbut given a\n    ''a list'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec loop acc = \n        match lst with\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpaiclpmxx.fsx(12,20): error FS0001: Type mismatch. Expecting a\n    ''a -> 'b'    \nbut given a\n    ''b'    \nThe types ''a' and ''b -> 'a' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list lst = \n        match lst with\n        | [] -> []\n        | x::xs -> \n            let min_val = min x\n            let max_val = max x\n            let min_val_list = min_val::xs\n            let max_val_list = max_val::xs\n            sort_list min_val_list\n            sort_list max_val_list\n    sort_list lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp86za7lxc.fsx(15,41): error FS0001: Type mismatch. Expecting a\n    '('a -> 'a) list'    \nbut given a\n    ''a list'    \nThe types ''a' and ''a -> 'a' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec loop acc = function\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520635,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list lst = \n        match lst with \n        | [] -> []\n        | x::xs -> \n            let min_val = min x\n            let max_val = max x\n            let new_list = \n                if min_val > max_val then \n                    [min_val, max_val]\n                else\n                    [min_val, x]\n            sort_list new_list\n    sort_list lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5g267a5t.fsx(16,20): error FS0001: The type '('a -> 'a)' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list acc lst =\n        match lst with\n        | [] -> acc\n        | x::xs ->\n            let x_min, x_max = min x xs\n            let x_min_acc = sort_list (x_min::acc) xs\n            let x_max_acc = sort_list (x_max::acc) xs\n            sort_list (x_min_acc@x_max_acc) xs\n    sort_list [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkyjdubfy.fsx(13,38): error FS0001: This expression was expected to have type\n    ''a * 'b'    \nbut here has type\n    '('a * 'b) list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list lst = \n        match lst with\n        | [] -> []\n        | x::xs -> \n            let min_val = min x\n            let max_val = max x\n            let new_list = \n                if min_val > max_val then \n                    [min_val, max_val]\n                else\n                    [min_val, max_val]\n            sort_list new_list\n    sort_list lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqeymvw9n.fsx(16,20): error FS0001: The type '('a -> 'a)' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec loop acc lst = \n        match lst with\n        | [] -> acc\n        | x::xs -> loop (x::acc) xs\n    loop [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520635,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list acc lst =\n        match lst with\n        | [] -> acc\n        | x::xs -> \n            let min_val = min x acc\n            let max_val = max x acc\n            sort_list (min_val::acc) xs\n    sort_list [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp28cpg2xb.fsx(15,24): error FS0001: Type mismatch. Expecting a\n    ''a'    \nbut given a\n    ''a list'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list lst = \n        match lst with \n        | [] -> []\n        | x::xs -> \n            let min_val = min x\n            let max_val = max x\n            let new_list = \n                if min_val > max_val then \n                    [min_val]\n                else \n                    [max_val]\n            sort_list new_list\n    sort_list lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph2srkt3i.fsx(16,20): error FS0001: The type '('a -> 'a)' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list lst = \n        match lst with\n        | [] -> []\n        | x::xs -> \n            let min_x = min x\n            let max_x = max x\n            let min_y = min y\n            let max_y = max y\n            if min_x < max_x && min_y < max_y then\n                [min_x; min_y; max_x; max_y]\n            else\n                sort_list xs\n    sort_list lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1y515laj.fsx(15,29): error FS0039: The value or constructor 'y' is not defined.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given list of integers, return list in strange order.\n// Strange sorting, is when you start with the minimum value,\n// then maximum of the remaining integers, then minimum and so on.\n// Examples:\n// strange_sort_list([1, 2, 3, 4]) == [1, 4, 2, 3]\n// strange_sort_list([5, 5, 5, 5]) == [5, 5, 5, 5]\n// strange_sort_list([]) == []\nlet strange_sort_list lst = \n    let rec sort_list acc lst = \n        match lst with\n        | [] -> acc\n        | x::xs -> \n            let xs_min = min xs\n            let xs_max = max xs\n            let xs_min_max = min xs_min xs_max\n            if xs_min_max > xs_min then sort_list (xs_min_max::acc) xs\n            else sort_list (xs_min::acc) xs\n    sort_list [] lst\nlet test() = \n  let candidate = strange_sort_list\n  assert (candidate [1; 2; 3; 4] = [1; 4; 2; 3])\n  assert (candidate [5; 6; 7; 8; 9] = [5; 9; 6; 8; 7])\n  assert (candidate [1; 2; 3; 4; 5] = [1; 5; 2; 4; 3])\n  assert (candidate [5; 6; 7; 8; 9; 1] = [1; 9; 5; 8; 6; 7])\n  assert (candidate [5; 5; 5; 5] = [5; 5; 5; 5])\n  assert (candidate [] = [])\n  assert (candidate [1; 2; 3; 4; 5; 6; 7; 8] = [1; 8; 2; 7; 3; 6; 4; 5])\n  assert (candidate [0; 2; 2; 2; 5; 5; -5; -5] = [-5; 5; -5; 5; 0; 2; 2; 2])\n  assert (candidate [111111] = [111111])\n  0\n\ntest()",
      "timestamp": 1675520634,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpclmuq1n3.fsx(15,34): error FS0001: The type '('a list -> 'a list)' does not support the 'comparison' constraint. For example, it does not support the 'System.IComparable' interface\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}