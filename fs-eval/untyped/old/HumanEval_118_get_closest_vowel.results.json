{
  "name": "HumanEval_118_get_closest_vowel",
  "language": "fs",
  "prompt": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n",
  "tests": "let test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4_iyb_k6.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c) \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then \"\"\n    else vowels_in_word |> Seq.minBy (fun c -> c.Length) |> Seq.toList\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzau4tqi5.fsx(19,61): error FS0001: The type 'string' does not match the type 'char list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4_iyb_k6.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yog\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqlo_s0kg.fsx(32,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpywyt68_r.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_start = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end_start = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end_start_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end_start_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end_start_end_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'g')\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpt59y5jvp.fsx(24,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> Seq.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.reduce (fun x y -> x + \" \" + y)\n        |> fun x -> x.TrimEnd(' ')\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length) |> fun c -> c.ToUpper()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = ['A'..'Z']\n    let vowels_right = ['a'..'z']\n    let vowels_right_left = ['A'..'Z']\n    let vowels_left_right = ['A'..'Z']\n    let vowels_left_right_left = ['A'..'Z']\n    let vowels_left_right_right = ['A'..'Z']\n    let vowels_right_left = ['A'..'Z']\n    let vowels_right_right = ['A'..'Z']\n    let vowels_right_right_left = ['A'..'Z']\n    let vowels_right_right_right = ['A'..'Z']\n    let vowels_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_left = ['A'..'Z']\n    let vowels_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_left = ['A'..'Z']\n    let vowels_right_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_right_left = ['A'..'Z']\n    let vowels_right_right_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_right_right_left = ['A'..'Z']\n    let vowels_right_right_right_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_right_right_right_left = ['A'..'Z']\n    let vowels_right_right_right_right_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpiai_2od3.fsx(37,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_length = vowels.Length\n    let vowels_index = vowels.IndexOf(word)\n    if vowels_index < 0 then\n        \"\"\n    else\n        let vowel = vowels.[vowels_index]\n        let vowel_length = vowel.Length\n        if vowel_length < 2 then\n            \"\"\n        else\n            let vowel_index = vowel.IndexOf(word)\n            if vowel_index < 0 then\n                \"\"\n            else\n                let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                if vowel_index < 0 then\n                    \"\"\n                else\n                    let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                    if vowel_index < 0 then\n                        \"\"\n                    else\n                        let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                        if vowel_index < 0 then\n                            \"\"\n                        else\n                            let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                            if vowel_index < 0 then\n                                \"\"\n                            else\n                                let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                                if vowel_index < 0 then\n                                    \"\"\n                                else\n                                    let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                                    if vowel_index < 0 then\n                                        \"\"\n                                    else\n                                        let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                                        if vowel_index < 0 then\n                                            \"\"\n                                        else\n                                            let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                                            if vowel_index < 0 then\n                                                \"\"\n                                            else\n                                                let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                                                if vowel_index < 0 then\n                                                    \"\"\n                                                else\n                                                    let vowel_index = vowel.IndexOf(word, vowel_index + 1)\n                                                    if vowel_index < 0 then\n                                                        \"\"\n                                                    else\n                                                        let vowel_index = vowel\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpb0n55tkm.fsx(67,57): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    let vowels_in_word = \n        vowels\n        |> Seq.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        let closest_vowel = \n            vowels_in_word\n            |> Seq.minBy (fun c -> c.ToString())\n        if closest_vowel.Length = 0 then\n            \"\"\n        else\n            closest_vowel.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpl34czmhq.fsx(19,38): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [|\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd7u3e15g.fsx(115,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd7u3e15g.fsx(115,1): error FS0010: Unexpected keyword 'let' or 'use' in binding. Expected '|]' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n    if vowels_count = 0 then\n        \"\"\n    else\n        let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n        let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n        if vowels_count = 0 then\n            \"\"\n        else\n            let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n            let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n            if vowels_count = 0 then\n                \"\"\n            else\n                let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n                let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n                if vowels_count = 0 then\n                    \"\"\n                else\n                    let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n                    let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n                    if vowels_count = 0 then\n                        \"\"\n                    else\n                        let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n                        let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n                        if vowels_count = 0 then\n                            \"\"\n                        else\n                            let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n                            let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n                            if vowels_count = 0 then\n                                \"\"\n                            else\n                                let vowels = vowels |> Array.filter (fun v -> word.\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdugp9iju.fsx(47,83): error FS0599: Missing qualification after '.'\n\n\n\n/tmp/tmpdugp9iju.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (47:33). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['a'..'z']\n    let vowels_to_find_end = ['A'..'Z']\n    let vowels_to_find_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpt6jr9v_i.fsx(33,43): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmpt6jr9v_i.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = vowels |> List.filter (fun v -> word.Contains(v))\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        let vowels_in_word = vowels_in_word |> List.filter (fun v -> word.Contains(v))\n        if vowels_in_word.Length = 1 then\n            vowels_in_word.[0]\n        else\n            vowels_in_word.[0] + \" \" + vowels_in_word.[1]\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpv_ubuav9.fsx(13,58): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = vowels |> List.filter (fun v -> v = word.[0])\n    if vowels_to_find.Length = 0 then\n        \"\"\n    else\n        vowels_to_find |> List.map (fun v -> v.ToString()) |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpumja5fgh.fsx(13,62): error FS0752: The operator 'expr.[idx]' has been used on an object of indeterminate type based on information prior to this program point. Consider adding further type constraints\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n    if vowels_count = 0 then \"\"\n    else\n        let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n        let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n        if vowels_count = 0 then \"\"\n        else\n            let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n            let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n            if vowels_count = 0 then \"\"\n            else\n                let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n                let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n                if vowels_count = 0 then \"\"\n                else\n                    let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n                    let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n                    if vowels_count = 0 then \"\"\n                    else\n                        let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n                        let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n                        if vowels_count = 0 then \"\"\n                        else\n                            let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n                            let vowels_count = vowels |> Array.filter (fun v -> word.Contains(v)) |> Array.length\n                            if vowels_count = 0 then \"\"\n                            else\n                                let vowels = vowels |> Array.filter (fun v -> word.Contains(v))\n                                let vowels_count = vow\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp612ffsd1.fsx(41,33): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [| 'a' .. 'z' |]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzkmhtj5h.fsx(38,32): error FS0599: Missing qualification after '.'\n\n\n\n/tmp/tmpzkmhtj5h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n        |> Array.map (fun c -> c.ToString())\n    let vowels = vowels |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n    let vowels = vowels |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n    let vowels = vowels |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n    let vowels = vowels |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n    let vowels = vowels |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n    let vowels = vowels |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n    let vowels = vowels |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n    let vowels = vowels |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n    let vowels = vowels |> Array.filter (fun c -> c <> 'a' && c <> 'e\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjdjrjirq.fsx(24,68): error FS0010: Unexpected quote symbol in expression\n\n\n\n/tmp/tmpjdjrjirq.fsx(25,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = ['A'..'Z']\n    let vowels_in_word_length = List.length vowels\n    let vowels_in_word_length_in_word = List.length word\n    if vowels_in_word_length < vowels_in_word_length_in_word then\n        None\n    else\n        let vowels_in_word_in_word = List.map (fun v -> v.ToString()) word\n        let vowels_in_word_in_word_length = List.length vowels_in_word_in_word\n        if vowels_in_word_in_word_length < vowels_in_word_length_in_word then\n            None\n        else\n            let vowels_in_word_in_word_in_word = List.map (fun v -> v.ToString()) word\n            let vowels_in_word_in_word_in_word_length = List.length vowels_in_word_in_word_in_word\n            if vowels_in_word_in_word_in_word_length < vowels_in_word_in_word_length_in_word then\n                None\n            else\n                let vowels_in_word_in_word_in_word_in_word = List.map (fun v -> v.ToString()) word\n                let vowels_in_word_in_word_in_word_in_word_length = List.length vowels_in_word_in_word_in_word_in_word\n                if vowels_in_word_in_word_in_word_in_word_length < vowels_in_word_in_word_length_in_word then\n                    None\n                else\n                    let vowels_in_word_in_word_in_word_in_word_in_word = List.map (fun v -> v.ToString()) word\n                    let vowels_in_word_in_word_in_word_in_word_in_word_length = List.length vowels_in_word_in_word_in_word_in\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp40l3uli7.fsx(35,21): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    let vowels_count = vowels |> List.length\n    if vowels_count = 0 then \"\"\n    else\n        let closest_vowel = vowels |> List.minBy (fun c -> c.Length)\n        closest_vowel.ToUpper()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_left = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left\n    let vowels_left_right_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right\n    let vowels_left_right_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp9u69_vhv.fsx(23,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word.ToCharArray()\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4df3h9_2.fsx(13,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_left = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left\n    let vowels_right_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right\n    let vowels_left_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left_end\n    let vowels_right_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_end\n    let vowels_left_end_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left_end_end\n    let vowels_right_end_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_end_end_end\n    let vowels_left_end_end_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left_end_end_end_end\n    let vowels_right_end_end_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_end_end_end_end_end\n    let vowels_left_end_end_end_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left_end_end_end_end_end_end\n    let vowels_right_end_end_end_end_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_end_end_end\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjz_pjg9e.fsx(24,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd_wdteey.fsx(32,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> Char.IsVowel(c))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length) |> fun c -> c.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp289zj_zg.fsx(13,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_start = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_zdc5_q7.fsx(28,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c ->\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(41,24): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.filter (fun c -> Char.IsVowel(c)) \n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.toList\n    if vowels.Length = 0 then \"\" else\n    let mutable best = \"\"\n    let mutable i = 0\n    while i < vowels.Length && best.Length < word.Length do\n        let c = vowels.[i]\n        if c = word.[best.Length..i] then\n            best <- best + c\n            i <- i + 1\n        else\n            best <- best + c\n    best\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpiicf7ye2.fsx(14,33): error FS0039: The value, namespace, type or module 'Char' is not defined. Maybe you want one of the following:\n   char\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToCharArray() |> Array.toList)\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpu20s9626.fsx(19,20): error FS0001: The type 'string' does not match the type 'char list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    let vowels_in_word_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word_in_word = vowels_in_word then\n        \"u\"\n    else\n        \"U\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels.Length = 0 then\n        \"\"\n    else\n        vowels\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.reduce (fun s1 s2 -> s1 + s2)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray()\n    let vowels_in_word_length = vowels.Length\n    let vowels_in_word_index = vowels_in_word.GetIndex(0)\n    let vowels_in_word_index_in_vowel = vowels_in_word_index - vowels_in_word_index_in_vowel\n    let vowels_in_word_index_in_vowel_length = vowels_in_word_index_in_vowel - vowels_in_word_index_in_vowel_length\n    let vowels_in_word_index_in_vowel_length_in_vowel = vowels_in_word_index_in_vowel_length - vowels_in_word_index_in_vowel_length_in_vowel\n    let vowels_in_word_index_in_vowel_length_in_vowel_length = vowels_in_word_index_in_vowel_length - vowels_in_word_index_in_vowel_length_in_vowel_length\n    let vowels_in_word_index_in_vowel_length_in_vowel_length_in_vowel = vowels_in_word_index_in_vowel_length_in_vowel_length - vowels_in_word_index_in_vowel_length_in_vowel_length_in_vowel\n    let vowels_in_word_index_in_vowel_length_in_vowel_length_in_vowel_length = vowels_in_word_index_in_vowel_length_in_vowel_length - vowels_in_word_index_in_vowel_length_in_vowel_length_in_vowel_length\n    let vowels_in_word_index_in_vowel_length_in_vowel_length_in_vowel_length_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpx3aqygi_.fsx(23,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_index = vowels |> Array.indexOf word\n    if vowels_index = -1 then\n        \"\"\n    else\n        vowels.[vowels_index]\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphdj89ptj.fsx(13,40): error FS0039: The value, constructor, namespace or type 'indexOf' is not defined. Maybe you want one of the following:\n   indexed\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'' && c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> '\\'')\n        |> List.map (fun c -> c\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpw42zztvn.fsx(43,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpw42zztvn.fsx(43,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['A'..'Z']\n    let vowels_to_find_end = ['a'..'z']\n    let vowels_to_find_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8digujte.fsx(33,43): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmp8digujte.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgz7j916v.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.map (fun c -> c.ToString().ToLower())\n        |> Array.filter (fun c -> c.Length > 0)\n        |> Array.map (fun c -> c.ToCharArray() |> Array.map (fun c -> c.ToString().ToLower()))\n        |> Array.filter (fun c -> c.Length > 0)\n        |> Array.map (fun c -> c.ToCharArray() |> Array.map (fun c -> c.ToString().ToLower()))\n        |> Array.filter (fun c -> c.Length > 0)\n        |> Array.map (fun c -> c.ToCharArray() |> Array.map (fun c -> c.ToString().ToLower()))\n        |> Array.filter (fun c -> c.Length > 0)\n        |> Array.map (fun c -> c.ToCharArray() |> Array.map (fun c -> c.ToString().ToLower()))\n        |> Array.filter (fun c -> c.Length > 0)\n        |> Array.map (fun c -> c.ToCharArray() |> Array.map (fun c -> c.ToString().ToLower()))\n        |> Array.filter (fun c -> c.Length > 0)\n        |> Array.map (fun c -> c.ToCharArray() |> Array.map (fun c -> c.ToString().ToLower()))\n        |> Array.filter (fun c -> c.Length > 0)\n        |> Array.map (fun c -> c.ToCharArray() |> Array.map (fun c -> c.ToString().ToLower()))\n        |> Array.filter (fun c -> c.Length > 0)\n        |> Array.map (fun c -> c.ToCharArray() |> Array.map (fun c -> c.ToString().ToLower()))\n        |> Array.filter (fun c -> c.Length > 0)\n        |> Array.map (fun c -> c.ToCharArray() |> Array.map (fun c -> c.ToString().ToLower()))\n        |> Array.filter (fun c ->\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8tqo4h94.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8tqo4h94.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8tqo4h94.fsx(51,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8tqo4h94.fsx(51,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8tqo4h94.fsx(33,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = ['a'..'z']\n    let vowels_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvvy57ktq.fsx(30,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpw2xrwtz1.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgz7j916v.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length) |> fun c -> c.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray() |> Array.filter (fun c -> vowels |> Array.contains c)\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        let closest_vowel = vowels_in_word.[0]\n        let vowel_in_word = word.ToCharArray() |> Array.filter (fun c -> vowels |> Array.contains c)\n        if vowel_in_word.Length = 0 then\n            \"\"\n        else\n            let closest_vowel_in_word = vowel_in_word.[0]\n            let vowel_in_word_in_word = word.ToCharArray() |> Array.filter (fun c -> vowels |> Array.contains c)\n            if vowel_in_word_in_word.Length = 0 then\n                \"\"\n            else\n                let closest_vowel_in_word_in_word = vowel_in_word_in_word.[0]\n                let vowel_in_word_in_word_in_word = word.ToCharArray() |> Array.filter (fun c -> vowels |> Array.contains c)\n                if vowel_in_word_in_word_in_word.Length = 0 then\n                    \"\"\n                else\n                    let closest_vowel_in_word_in_word_in_word = vowel_in_word_in_word_in_word.[0]\n                    let vowel_in_word_in_word_in_word_in_word = word.ToCharArray() |> Array.filter (fun c -> vowels |> Array.contains c)\n                    if vowel_in_word_in_word_in_word_in_word.Length = 0 then\n                        \"\"\n                    else\n                        let closest_vowel_in_word_in_word_in_word_in_word = vowel_in_word_in_word_in_word_in_word_in_word.[0]\n                        let vowel_in_word_in_word_in_word_in_word_in_word_in\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1xtc2ran.fsx(39,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4_iyb_k6.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.filter (fun c -> c <> \"\")\n    if vowels.Length = 0 then\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwjpz0ix3.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (43:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpwjpz0ix3.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (43:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpwjpz0ix3.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (43:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpwjpz0ix3.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (43:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpwjpz0ix3.fsx(43,5): error FS0001: This expression was expected to have type\n    'unit'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['A'..'Z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> Seq.contains c)\n        |> Seq.map (fun c -> c.ToString())\n    let vowels_in_word_count = \n        vowels_in_word |> Seq.length\n    if vowels_in_word_count <> 0 then\n        vowels_in_word_count\n    else\n        0\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplc_9xfrk.fsx(25,32): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = vowels |> List.map (fun v -> word.ToCharArray() |> Array.find (fun c -> c = v))\n    let vowels_in_word_length = vowels_in_word.Length\n    let vowels_in_word_index = vowels_in_word_length - 1\n    let vowels_in_word_index_in_word = vowels_in_word_index |> List.findIndex (fun v -> v = word.ToCharArray() |> Array.findIndex (fun c -> c = v))\n    let vowels_in_word_index_in_word_length = vowels_in_word_index_in_word.Length\n    let vowels_in_word_index_in_word_index = vowels_in_word_index_in_word_length - 1\n    let vowels_in_word_index_in_word_index_in_word = vowels_in_word_index_in_word_index |> List.findIndex (fun v -> v = word.ToCharArray() |> Array.findIndex (fun c -> c = v))\n    let vowels_in_word_index_in_word_index_in_word_length = vowels_in_word_index_in_word_index_in_word_length - 1\n    let vowels_in_word_index_in_word_index_in_word_index = vowels_in_word_index_in_word_index_in_word_index |> List.findIndex (fun v -> v = word.ToCharArray() |> Array.findIndex (fun c -> c = v))\n    let vowels_in_word_index_in_word_index_in_word_index_in_word = vowels_in_word_index_in_word_index_in_word_index_in_word_length - 1\n    let vowels_in_word_index_in_word_index_in_word_index_in_word_index = vowels_in_word_index_in_word_index_in_word_index\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4320sed6.fsx(23,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\";\n            \"ugur\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp94fcu_5a.fsx(28,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp94fcu_5a.fsx(45,1): error FS0010: Unexpected identifier in expression. Expected 'in' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> Seq.contains c)\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Seq.map (fun c -> c.ToString())\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_to_find = \n        vowels\n        |> Array.filter (fun v -> word.Contains(v))\n        |> Array.map (fun v -> v.ToLower())\n    if vowels_to_find.Length = 0 then\n        \"\"\n    else\n        vowels_to_find\n        |> Array.map (fun v -> v.ToLower())\n        |> Array.reduce (fun acc v -> acc + v)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp976uuqow.fsx(15,12): error FS0001: Type mismatch. Expecting a\n    'string list -> 'a'    \nbut given a\n    ''b[] -> 'b[]'    \nThe type 'string list' does not match the type ''a[]'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.map (fun c -> if c = 'a' then 'e' else c)\n        |> Seq.filter (fun c -> vowels |> Seq.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then \"\"\n    else vowels_in_word |> List.reduce (fun acc elem -> acc + elem)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        let closest_vowel = vowels_in_word |> List.minBy (fun c -> c.Length)\n        closest_vowel.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c ->\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(41,24): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.reduce (fun s1 s2 -> s1 + s2)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = ['a'..'z']\n    let vowels_right = ['A'..'Z']\n    let vowels_right_left = ['A'..'Z']\n    let vowels_right_right = ['a'..'z']\n    let vowels_left_right = ['A'..'Z']\n    let vowels_left_right_left = ['A'..'Z']\n    let vowels_left_right_right = ['a'..'z']\n    let vowels_right_left = ['A'..'Z']\n    let vowels_right_right = ['a'..'z']\n    let vowels_left_right_left = ['A'..'Z']\n    let vowels_left_right_right = ['a'..'z']\n    let vowels_right_left_right = ['A'..'Z']\n    let vowels_left_right_right_left = ['a'..'z']\n    let vowels_right_left_right_right = ['A'..'Z']\n    let vowels_left_right_right_left = ['a'..'z']\n    let vowels_right_left_right_right = ['A'..'Z']\n    let vowels_left_right_right_left = ['a'..'z']\n    let vowels_right_left_right_right = ['A'..'Z']\n    let vowels_left_right_right_left = ['a'..'z']\n    let vowels_right_left_right_right = ['A'..'Z']\n    let vowels_left_right_right_left = ['a'..'z']\n    let vowels_right_left_right_right = ['A'..'Z']\n    let vowels_left_right_right_left = ['a'..'z']\n    let vowels_right_left_right_right = ['A'..'Z']\n    let vowels_left_right_right_left = ['a'..'z']\n    let vowels_right_left_right_right = ['A'\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa60c4fhr.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpa60c4fhr.fsx(39,1): error FS0010: Unexpected keyword 'let' or 'use' in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left\n    let vowels_left_right_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right\n    let vowels_left_right_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_vowel_v\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpxwo5rjc2.fsx(23,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"o\"\n            \"y\"\n            \"u\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp21_vij3w.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['A'..'Z']\n    let vowels_to_find = ['a'..'z']\n    let vowels_to_find_end = ['A'..'Z']\n    let vowels_to_find_start = ['a'..'z']\n    let vowels_to_find_end_start = ['A'..'Z']\n    let vowels_to_find_end_start_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end = ['A'..'Z']\n    let vowels_to_find_end_start_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvouz6z6x.fsx(31,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yog\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqlo_s0kg.fsx(32,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word.ToCharArray()\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Array.map (fun c -> c.ToString())\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7018alwh.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_count = vowels.Length\n    let vowels_left = vowels |> List.filter (fun c -> c <> 'a')\n    let vowels_right = vowels |> List.filter (fun c -> c <> 'z')\n    let vowels_left_count = vowels_left |> List.length\n    let vowels_right_count = vowels_right |> List.length\n    let vowels_left_left = vowels_left |> List.filter (fun c -> c <> 'a')\n    let vowels_right_left = vowels_right |> List.filter (fun c -> c <> 'z')\n    let vowels_left_right = vowels_left |> List.filter (fun c -> c <> 'a')\n    let vowels_right_right = vowels_right |> List.filter (fun c -> c <> 'z')\n    let vowels_left_right_count = vowels_left_right |> List.length\n    let vowels_right_left_count = vowels_right_left |> List.length\n    let vowels_left_right_left = vowels_left_right |> List.filter (fun c -> c <> 'a')\n    let vowels_right_left_count = vowels_right_left |> List.length\n    let vowels_left_right_right = vowels_right_left |> List.filter (fun c -> c <> 'z')\n    let vowels_right_left_right_count = vowels_right_left_right |> List.length\n    let vowels_left_right_right_left = vowels_right_left_right |> List.filter (fun c -> c <> 'a')\n    let vowels_right_left_right_right = vowels_right_left_right |> List.filter (fun c -> c <> 'z')\n    let vowels_left_right_right_right_count = vowels_right_left_right_right |> List.length\n    let vowels_right_left_right_right_left = vow\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprir04dal.fsx(31,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length = 1)\n        |> Seq.map (fun c -> c.ToCharArray() |> Array.head)\n        |> Seq.toArray\n    let vowels_in_word = \n        vowels\n        |> Seq.filter (fun c -> c.Length = 1)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toArray\n    let vowels_in_word_in_word = \n        vowels\n        |> Seq.filter (fun c -> c.Length = 1)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toArray\n    let vowels_in_word_in_word_in_word = \n        vowels\n        |> Seq.filter (fun c -> c.Length = 1)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toArray\n    let vowels_in_word_in_word_in_word = \n        vowels\n        |> Seq.filter (fun c -> c.Length = 1)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toArray\n    let vowels_in_word_in_word_in_word = \n        vowels\n        |> Seq.filter (fun c -> c.Length = 1)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toArray\n    let vowels_in_word_in_word_in_word = \n        vowels\n        |> Seq.filter (fun c -> c.Length = 1)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toArray\n    let vowels_in_word_in_word_in_word = \n        vowels\n        |> Seq.filter (fun c -> c.\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0yze0v1c.fsx(50,34): error FS0599: Missing qualification after '.'\n\n\n\n/tmp/tmp0yze0v1c.fsx(51,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (48:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = ['a'..'z'] @ vowels\n    let vowels_in_word_count = vowels_in_word.Length\n    let vowels_in_word_count_in_word = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word_count = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word_count_in_word = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word_count_in_word_count = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word_count_in_word_count_in_word = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word_count_in_word_count_in_word_count = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word_count_in_word_count_in_word_count_in_word = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word_count_in_word_count_in_word_count_in_word_count = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word_count_in_word_count_in_word_count_in_word_count_in_word = vowels_in_word.Length\n    let vowels_in_word_count_in_word_count_in_word_count_in_word_count_in_word_count_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp87thx3ao.fsx(27,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"g\"; \"o\"; \"u\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\"; \"y\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj1mhqbm5.fsx(13,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj1mhqbm5.fsx(30,1): error FS0010: Unexpected identifier in expression. Expected 'in' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['A'..'Z']\n    let vowels_left = ['a'..'z']\n    let vowels_right = ['A'..'Z']\n    let vowels_right_left = ['a'..'z']\n    let vowels_left_right = ['A'..'Z']\n    let vowels_left_right_left = ['a'..'z']\n    let vowels_left_right_right = ['A'..'Z']\n    let vowels_right_left = ['a'..'z']\n    let vowels_right_right = ['A'..'Z']\n    let vowels_right_right_left = ['a'..'z']\n    let vowels_right_right_right = ['A'..'Z']\n    let vowels_right_right_right = ['a'..'z']\n    let vowels_right_right_right_left = ['A'..'Z']\n    let vowels_right_right_right_right = ['a'..'z']\n    let vowels_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_left = ['a'..'z']\n    let vowels_right_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_right_left = ['a'..'z']\n    let vowels_right_right_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_right_right_left = ['a'..'z']\n    let vowels_right_right_right_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_right_right_right_left = ['a'..'z']\n    let vowels_right_right_right_right_right_right_right_right = ['A'..'Z']\n    let vowels_right_right_right_right_right_right_right_right_left = ['a'..'z']\n    let vowels\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp889d6wj8.fsx(37,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Seq.map (fun c -> c.ToString())\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7pghekt_.fsx(25,21): error FS0001: The type 'string' is not compatible with the type 'seq<string>'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = List.filter (fun v -> vowels |> List.contains v) vowels\n    let vowels_right = List.filter (fun v -> vowels |> List.contains v) vowels\n    let vowels_left_right = List.filter (fun v -> vowels |> List.contains v) vowels_left\n    let vowels_left_right_vowel = List.filter (fun v -> vowels |> List.contains v) vowels_right\n    let vowels_left_right_vowel_vowel = List.filter (fun v -> vowels |> List.contains v) vowels_left_right\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v) vowels_left_right_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v) vowels_left_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v) vowels_left_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v) vowels_left_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v) vowels_left_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter (fun v -> vowels |> List.contains v) vowels_left_right_vowel_vowel\n    let vowels_left_right_vowel_vowel_vowel = List.filter\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpewt9xggo.fsx(24,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['a'..'z']\n    let vowels_to_find_end = ['a'..'z']\n    let vowels_to_find_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['a\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpio0avwr9.fsx(33,43): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmpio0avwr9.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp28c_rgzi.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = ['A'..'Z']\n    let vowels_right = ['a'..'z']\n    let vowels_right_left = ['A'..'Z']\n    let vowels_right_right = ['a'..'z']\n    let vowels_left_right = ['A'..'Z']\n    let vowels_left_right_left = ['A'..'Z']\n    let vowels_left_right_right = ['a'..'z']\n    let vowels_left_right_left_left = ['A'..'Z']\n    let vowels_left_right_right_right = ['a'..'z']\n    let vowels_left_right_right_left_left = ['A'..'Z']\n    let vowels_left_right_right_right_right = ['a'..'z']\n    let vowels_left_right_right_left_left = ['A'..'Z']\n    let vowels_left_right_right_right_right = ['a'..'z']\n    let vowels_left_right_right_left_left = ['A'..'Z']\n    let vowels_left_right_right_right_right = ['a'..'z']\n    let vowels_left_right_right_left_left = ['A'..'Z']\n    let vowels_left_right_right_right_right = ['a'..'z']\n    let vowels_left_right_right_left_left = ['A'..'Z']\n    let vowels_left_right_right_right_right = ['a'..'z']\n    let vowels_left_right_right_left_left = ['A'..'Z']\n    let vowels_left_right_right_right_right = ['a'..'z']\n    let vowels_left_right_right_left_left = ['A'..'Z']\n    let vowels_left_right_right_right_right = ['a'..'z']\n    let vowels_left_right_right_left_left = ['\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpybgp7tij.fsx(36,46): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmpybgp7tij.fsx(37,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (36:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then \n        \"\"\n    else\n        vowels_in_word\n        |> List.map (fun c -> c.ToString())\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray() |> Array.filter (fun c -> vowels |> Array.contains c)\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Array.map (fun c -> c.ToString())\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_sscr_xc.fsx(13,26): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = List.filter (fun c -> vowels |> List.contains c) vowels\n    let vowels_right = List.filter (fun c -> vowels |> List.contains c) vowels\n    let vowels_left_right = List.filter (fun c -> vowels |> List.contains c) vowels_left\n    let vowels_right_left = List.filter (fun c -> vowels |> List.contains c) vowels_right\n    let vowels_left_right_right = List.filter (fun c -> vowels |> List.contains c) vowels_left_right\n    let vowels_right_left_right_right = List.filter (fun c -> vowels |> List.contains c) vowels_right_left_right\n    let vowels_left_right_right_right_right = List.filter (fun c -> vowels |> List.contains c) vowels_left_right_right_right\n    let vowels_left_right_right_right_right_right = List.filter (fun c -> vowels |> List.contains c) vowels_left_right_right_right_right\n    let vowels_left_right_right_right_right_right_right = List.filter (fun c -> vowels |> List.contains c) vowels_left_right_right_right_right_right\n    let vowels_left_right_right_right_right_right_right = List.filter (fun c -> vowels |> List.contains c) vowels_left_right_right_right_right_right\n    let vowels_left_right_right_right_right_right_right = List.filter (fun c -> vowels |> List.contains c) vowels_left_right_right_right_right_right\n    let vowels_left_right_right_right_right_right_right = List.filter (fun c -> vowels |> List.contains c) vowels_left_right_right_right_right_right\n    let vowels_left_right_right_right_right_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1n60q1v1.fsx(26,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"u\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"y\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8pl9l_6a.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then \"\"\n    else vowels_in_word |> List.minBy (fun c -> c.Length) |> fun c -> c.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length = 1)\n        |> Seq.map (fun c -> c.ToCharArray() |> Array.head)\n        |> Seq.toArray\n    let vowels_length = vowels.Length\n    if vowels_length = 0 then \"\"\n    else\n        let mutable best_vowel = \"\"\n        let mutable best_vowel_length = 0\n        for i = 0 to vowels_length - 1 do\n            let c = vowels.[i]\n            if c = 'y' then best_vowel <- best_vowel + c\n            elif c = 'o' then best_vowel <- best_vowel + c\n            elif c = 'u' then best_vowel <- best_vowel + c\n            elif c = 'a' then best_vowel <- best_vowel + c\n            elif c = 'e' then best_vowel <- best_vowel + c\n            elif c = 'i' then best_vowel <- best_vowel + c\n            elif c = 'o' then best_vowel <- best_vowel + c\n            elif c = 'u' then best_vowel <- best_vowel + c\n            elif c = 'a' then best_vowel <- best_vowel + c\n            elif c = 'e' then best_vowel <- best_vowel + c\n            elif c = 'i' then best_vowel <- best_vowel + c\n            elif c = 'o' then best_vowel <- best_vowel + c\n            elif c = 'u' then best_vowel <- best_vowel + c\n            elif c = 'a' then best_vowel <- best_vowel + c\n            elif c = 'e' then best_vowel <- best_vowel + c\n            elif c = 'i' then best_vow\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpiq9opj24.fsx(23,9): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is 'string'. This branch returns a value of type 'unit'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length) |> fun c -> c.ToUpper()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_count = vowels.Length\n    let vowels_index = vowels.IndexOf word\n    if vowels_index = -1 then\n        \"No such vowel\"\n    else\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7xe2o7ma.fsx(49,9): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy00hqmjr.fsx(32,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpw0ygyxov.fsx(45,1): error FS0010: Incomplete structured construct at or before this point in lambda expression. Expected '->' or other token.\n\n\n\n/tmp/tmpw0ygyxov.fsx(45,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"A\"; \"E\"; \"I\"; \"O\"; \"U\"]\n    let vowels_count = vowels |> List.filter (fun v -> word.Contains(v)) |> List.length\n    if vowels_count = 0 then \"\"\n    else\n        let vowels_list = vowels |> List.map (fun v -> word.Substring(0, word.IndexOf(v)))\n        let vowels_list = vowels_list |> List.filter (fun v -> word.Contains(v))\n        let vowels_list = vowels_list |> List.map (fun v -> word.Substring(word.IndexOf(v)))\n        let vowels_list = vowels_list |> List.filter (fun v -> word.Contains(v))\n        let vowels_list = vowels_list |> List.map (fun v -> word.Substring(word.IndexOf(v)))\n        let vowels_list = vowels_list |> List.filter (fun v -> word.Contains(v))\n        let vowels_list = vowels_list |> List.map (fun v -> word.Substring(word.IndexOf(v)))\n        let vowels_list = vowels_list |> List.filter (fun v -> word.Contains(v))\n        let vowels_list = vowels_list |> List.map (fun v -> word.Substring(word.IndexOf(v)))\n        let vowels_list = vowels_list |> List.filter (fun v -> word.Contains(v))\n        let vowels_list = vowels_list |> List.map (fun v -> word.Substring(word.IndexOf(v)))\n        let vowels_list = vowels_list |> List.filter (fun v -> word.Contains(v))\n        let vowels_list = vowels_list |> List.map (fun v -> word.Substring(word.IndexOf(v)))\n        let vowels_list = vowels_list |> List.filter (fun v -> word.Contains(v))\n        let vowels_list = vowels_list |> List.map (fun v\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpot4g1fm_.fsx(31,1): error FS0010: Incomplete structured construct at or before this point in lambda expression. Expected '->' or other token.\n\n\n\n/tmp/tmpot4g1fm_.fsx(31,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (30:9). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [|\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbk8btn67.fsx(115,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbk8btn67.fsx(115,1): error FS0010: Unexpected keyword 'let' or 'use' in binding. Expected '|]' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = ['a'..'z']\n    let vowels_right = ['A'..'Z']\n    let vowels_right_left = ['A'..'Z']\n    let vowels_left_right = ['a'..'z']\n    let vowels_left_right_left = ['a'..'z']\n    let vowels_left_right_right = ['A'..'Z']\n    let vowels_left_right_left_right = ['A'..'Z']\n    let vowels_left_right_right_left = ['a'..'z']\n    let vowels_left_right_right_right = ['A'..'Z']\n    let vowels_left_right_right_right_left = ['a'..'z']\n    let vowels_left_right_right_right_right = ['A'..'Z']\n    let vowels_left_right_right_right_right_left = ['a'..'z']\n    let vowels_left_right_right_right_right_right = ['A'..'Z']\n    let vowels_left_right_right_right_right_right_left = ['a'..'z']\n    let vowels_left_right_right_right_right_right_right = ['A'..'Z']\n    let vowels_left_right_right_right_right_right_right_left = ['a'..'z']\n    let vowels_left_right_right_right_right_right_right_right = ['A'..'Z']\n    let vowels_left_right_right_right_right_right_right_right_left = ['a'..'z']\n    let vowels_left_right_right_right_right_right_right_right_right = ['A'..'Z']\n    let vowels_left_right_right_right_right_right_right_right_right_left = ['a'..'z']\n    let vowels_left_right_right_right_right_right_right_right_right_right = ['A'..'Z\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpx15reu4l.fsx(33,83): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmpx15reu4l.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word.ToCharArray()\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Array.map (fun c -> c.ToString())\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuaj5z8a4.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels.Length = 0 then\n        \"\"\n    else\n        vowels\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n        |> List.min\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [|\n            'a'\n            'e'\n            'i'\n            'o'\n            'u'\n            'y'\n            'u'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            'o'\n            'o'\n            'y'\n            'y'\n            \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpn22w7lzc.fsx(115,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpn22w7lzc.fsx(115,1): error FS0010: Unexpected keyword 'let' or 'use' in binding. Expected '|]' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['a'..'z'] @ vowels\n    let vowels_to_find_end = vowels @ ['a'..'z']\n    let vowels_to_find_end_end = vowels_to_find @ vowels_to_find_end\n    let vowels_to_find_end_end_end = vowels_to_find_end @ vowels_to_find_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_end_end @ vowels_to_find_end_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_end_end @ vowels_to_find_end_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_end_end @ vowels_to_find_end_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_end_end @ vowels_to_find_end_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_end_end @ vowels_to_find_end_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_end_end @ vowels_to_find_end_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_end_end @ vowels_to_find_end_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_end_end @ vowels_to_find_end_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_end_end @ vowels_to_find_end_end_end\n    let vowels_to_find_end_end_end_end = vowels_to_find_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpfurkwjtg.fsx(26,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"ugur\"; \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpfdpv3ca_.fsx(30,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'; 'e'; 'i'; 'o'; 'u']\n    let vowels_left = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left\n    let vowels_right_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right\n    let vowels_left_start = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left\n    let vowels_right_start = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right\n    let vowels_left_end_start = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left_end\n    let vowels_right_end_start = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_end\n    let vowels_left_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left_end_end\n    let vowels_right_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_end_end\n    let vowels_left_end_start = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left_end_start\n    let vowels_right_end_start = List.filter (fun v -> vowels |> List.contains v |> not) vowels_right_end_start\n    let vowels_left_end_end = List.filter (fun v -> vowels |> List.contains v |> not) vowels_left_end_end\n    let vowels_right_end_end = List.filter (fun v -> vow\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_fmrfn_2.fsx(27,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (26:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_fmrfn_2.fsx(27,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_count = vowels.Length\n    let vowels_index = vowels.IndexOf word\n    if vowels_index = -1 then\n        \"No such vowel: \" + word\n    else\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + vowels_count\n        if vowels_index = -1 then\n            \"No such vowel: \" + word\n        else\n            let vowels_index = vowels_index + 1\n            let vowels_index = vowels_index + vowels_count\n            if vowels_index = -1 then\n                \"No such vowel: \" + word\n            else\n                let vowels_index = vowels_index + 1\n                let vowels_index = vowels_index + vowels_count\n                if vowels_index = -1 then\n                    \"No such vowel: \" + word\n                else\n                    let vowels_index = vowels_index + 1\n                    let vowels_index = vowels_index + vowels_count\n                    if vowels_index = -1 then\n                        \"No such vowel: \" + word\n                    else\n                        let vowels_index = vowels_index + 1\n                        let vowels_index = vowels_index + vowels_count\n                        if vowels_index = -1 then\n                            \"No such vowel: \" + word\n                        else\n                            let vowels_index = vowels_index + 1\n                            let vowels_index = vowels_index + vowels_count\n                            if vowels_index = -1 then\n                                \"No such vowel: \" + word\n                            else\n                                let vowels_index = vowels_index + 1\n                                let vowels_index = vowels_index + vowels_count\n                                if vowels_index = -1 then\n                                    \"No such vowel: \" + word\n                                else\n                                    let vowels_index = vowels_index + 1\n                                    let vowels_index = vowels_index + vowels_count\n                                    if vowels_index = -1 then\n                                        \"No such vowel: \" + word\n                                    else\n                                        let\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpefqgfvko.fsx(59,1): error FS0010: Incomplete structured construct at or before this point in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"quick\"; \"ab\"]\n    let vowels = vowels |> List.filter (fun v -> word.Contains(v))\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.head\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyuolhv4v.fsx(13,50): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> Seq.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Seq.minBy (fun c -> c.Length)\n        |> fun c -> c.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4je51oix.fsx(26,21): error FS0001: The type 'string' is not compatible with the type 'seq<string>'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> Seq.exists (fun v -> v = c))\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Seq.map (fun c -> c.ToString())\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> Seq.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    vowels_in_word |> List.tryFind (fun c -> c = word)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbn8z256e.fsx(21,32): error FS0001: This expression was expected to have type\n    'string option'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length) |> fun c -> c.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"o\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ugly\"; \"ug\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8kxdfw6u.fsx(33,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.ToString())\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_count = vowels.Length\n    let vowels_index = vowels.IndexOf word\n    if vowels_index = -1 then\n        \"\"\n    else\n        let vowel = vowels.[vowels_index]\n        let vowel_count = vowels.Length\n        let vowel_index = vowels.IndexOf vowel\n        if vowel_index = -1 then\n            \"\"\n        else\n            let vowel_index = vowels.IndexOf vowel\n            let vowel_index = if vowel_index = 0 then vowel_index - 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index + 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index - 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index + 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index - 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index + 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index - 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index + 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index - 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index + 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index - 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index + 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index - 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count - 1 then vowel_index + 1 else vowel_index\n            let vowel_index = if vowel_index = vowel_count -\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmjzsldpu.fsx(40,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (39:31). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpmjzsldpu.fsx(40,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (39:31). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpmjzsldpu.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (39:31). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpmjzsldpu.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (39:31). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpmjzsldpu.fsx(57,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (39:31). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpmjzsldpu.fsx(57,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['a'..'z']\n    let vowels_to_find_end = ['a'..'z']\n    let vowels_to_find_start = ['a'..'z']\n    let vowels_to_find_end_start = ['a'..'z']\n    let vowels_to_find_end_start_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_start_end_end_end_end = ['a'..'z']\n\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpco7lkicp.fsx(31,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = vowels |> List.filter (fun v -> word.Contains(v))\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> List.map (fun v -> v.ToString())\n        |> String.concat \"\"\n        |> fun s -> s.Replace(\" \", \"\")\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps5qmuej3.fsx(13,58): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk5_vw4xd.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToUpper())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToLower())\n        |> Array.filter (fun c -> c <> \"\")\n\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph0ppn8e0.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yogurt\"; \"u\"; \"yog\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqlo_s0kg.fsx(32,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\";\n            \"a\"; \"e\"; \"i\"; \"o\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbaspxnqv.fsx(46,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word.ToCharArray()\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Array.map (fun c -> c.ToString())\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuaj5z8a4.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n    if vowels_in_word.Length = 0 then \"\"\n    else vowels_in_word |> Seq.min\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4r3g5_nr.fsx(17,23): error FS0039: The type 'IEnumerable<_>' does not define the field, constructor or member 'Length'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnx4t7bfq.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [|\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbk8btn67.fsx(115,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbk8btn67.fsx(115,1): error FS0010: Unexpected keyword 'let' or 'use' in binding. Expected '|]' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_in_word = word.ToCharArray()\n    let mutable i = 0\n    while i < vowels_in_word.Length && vowels.[i] = vowels.[i-1] do\n        i <- i + 1\n    if i = vowels_in_word.Length then \"\"\n    else vowels.[i-1] + vowels.[i]\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjzmgumpa.fsx(13,26): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> Char.IsVowel(c) || Char.IsDigit(c))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.toList\n    if vowels.Length = 0 then\n        \"\"\n    else\n        let closest = vowels |> List.minBy (fun c -> c.Length)\n        closest.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkynvznmk.fsx(13,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5_mc60li.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word.ToCharArray()\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n    if vowels_in_word.Length = 0 then \"\"\n    else vowels_in_word |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0s07hp1a.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray()\n    let vowels_in_word_length = vowels.Length\n    let vowels_in_word_index = vowels_in_word.GetIndex(0)\n    let vowels_in_word_index_in_word = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_length = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_index = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_index_in_word = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_index_in_word_length = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_index_in_word_index = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_index_in_word_index_in_word = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_index_in_word_index_in_word_length = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_index_in_word_index_in_word_index_in_word = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_index_in_word_index_in_word_index_in_word_length = vowels_in_word_index.GetIndex(0)\n    let vowels_in_word_index_in_word_index_in_word_index_in_word_index_in_word_index_in_word = vowels_in_word_index.GetIndex(0)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2bjdioqz.fsx(26,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgz7j916v.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_in_word = \n        word.ToCharArray()\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Array.map (fun c -> c.ToString())\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8xqo1bsu.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [|\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbongxd8u.fsx(115,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbongxd8u.fsx(115,1): error FS0010: Unexpected keyword 'let' or 'use' in binding. Expected '|]' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8j9n6gju.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsDigit c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsWhiteSpace c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsPunctuation c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsWhiteSpace c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsDigit c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsPunctuation c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsWhiteSpace c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsDigit c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsWhiteSpace c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter c))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2tsibu0c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2tsibu0c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2tsibu0c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2tsibu0c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2tsibu0c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2tsibu0c.fsx(59,5): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2tsibu0c.fsx(59,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsVowel(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsWhiteSpace(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1z9dhq3t.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = vowels |> List.filter (fun x -> x <> 'y' && x <> 'o' && x <> 'u')\n    let vowels_to_find_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'o' && x <> 'u')\n    let vowels_to_find_start = vowels |> List.filter (fun x -> x <> 'y' && x <> 'o' && x <> 'u')\n    let vowels_to_find_end_start = vowels |> List.filter (fun x -> x <> 'y' && x <> 'o' && x <> 'u')\n    let vowels_to_find_end_start_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'o' && x <> 'u' && x <> 'y')\n    let vowels_to_find_end_start_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'o' && x <> 'u' && x <> 'y')\n    let vowels_to_find_end_start_end_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'o' && x <> 'u' && x <> 'y' && x <> 'o' && x <> 'u' && x <> 'y')\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.filter (fun x -> x <> 'y' && x <> 'o' && x <> 'u' && x <> 'y' && x <> 'o' && x <> 'u' && x <> 'y' && x <> 'o' && x <> 'u' && x <> 'y' && x <> 'o' && x <> 'u' && x <> 'y' && x <> 'o' && x <> 'u' && x\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpfgol7oy1.fsx(21,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (20:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpfgol7oy1.fsx(21,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_length = vowels.Length\n    let vowels_index = vowels.IndexOf word\n    if vowels_index < 0 then\n        \"\"\n    else\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + vowels_length\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index +\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpxoos1qgu.fsx(50,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:28). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpxoos1qgu.fsx(50,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:28). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpxoos1qgu.fsx(67,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:28). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpxoos1qgu.fsx(67,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:28). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpxoos1qgu.fsx(67,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:9). Try indenting this to",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'y' && c <> 'g')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'e' && c <> 'i')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'o' && c <> 'u')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'i' && c <> 'o')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'u' && c <> 'y')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'y' && c <> 'g')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'u' && c <> 'e')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'i' && c <> 'o')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'u' && c <> 'y')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'y' && c <> 'g')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'u' && c <> 'e')\n        |> List.map (fun c -> c.ToString\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd9wy5yey.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpd9wy5yey.fsx(39,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c ->\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(41,24): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'; 'e'; 'i'; 'o'; 'u']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then \"\"\n    else vowels_in_word |> Seq.min\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['A'..'Z']\n    let vowels_to_find_end = ['a'..'z']\n    let vowels_to_find_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8digujte.fsx(33,43): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmp8digujte.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray() |> Array.filter (fun c -> vowels |> Array.contains c)\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        let vowels_in_word = vowels_in_word |> Array.map (fun c -> c.ToString())\n        let vowels = vowels_in_word |> Array.filter (fun c -> vowels |> Array.contains c)\n        if vowels.Length = 0 then\n            \"\"\n        else\n            let closest_vowel = vowels |> Array.find (fun c -> c = 'y')\n            closest_vowel.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpv98tqrsz.fsx(13,26): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_start = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end_start = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end_start_end = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end_start_end_end = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end_start_end_end_end = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end_start_end_end_end_end_end = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end_start_end_end_end_end_end_end = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end_start_end_end_end_end_end_end = vowels |> List.filter (fun c -> c <> 'a' && c <> 'z')\n    let vowels_to_find_end_start_end_end_end_end_end_end_end = vowels |> List.filter (\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpu_qe9rlg.fsx(25,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpu_qe9rlg.fsx(25,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpu_qe9rlg.fsx(25,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpu_qe9rlg.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpu_qe9rlg.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpu_qe9rlg.fsx(42,5): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpu_qe9rlg.fsx(24,86): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    let vowels_length = vowels.Length\n    if vowels_length = 0 then \"\"\n    else\n        let closest_vowel = vowels.[0]\n        let vowel_length = closest_vowel.Length\n        if vowel_length = 1 then \"\"\n        else\n            let vowel_start = closest_vowel.IndexOf(vowel_length)\n            let vowel_end = closest_vowel.IndexOf(vowel_length, vowel_start + vowel_length)\n            if vowel_end = -1 then \"\"\n            else\n                let vowel_end_string = closest_vowel.Substring(0, vowel_end)\n                let vowel_end_string_length = vowel_end_string.Length\n                if vowel_end_string_length = 1 then \"\"\n                else\n                    let vowel_end_string_start = closest_vowel.IndexOf(vowel_end_string_length)\n                    let vowel_end_string_end = closest_vowel.IndexOf(vowel_end_string_length, vowel_end_string_start + vowel_end_string_length)\n                    if vowel_end_string_end = -1 then \"\"\n                    else\n                        let vowel_end_string_end_string = closest_vowel.Substring(0, vowel_end_string_end)\n                        let vowel_end_string_end_string_length = vowel_end_string_end_string.Length\n                        if vowel_end_string_end_string_length = 1 then \"\"\n                        else\n                            let vowel_end_string_end_string_start = closest_vowel.IndexOf(vowel_end_string_end_string_length)\n                            let vowel_end_string_end_string_end = closest_vowel.IndexOf(vowel_end_string_end_string_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzwozjbmz.fsx(43,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (42:29). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpzwozjbmz.fsx(43,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length = 1)\n        |> Seq.map (fun c -> c.ToCharArray() |> Array.head)\n        |> Seq.toArray\n    let vowels = vowels |> Array.map (fun c -> c.ToString())\n    let vowels = vowels |> Array.filter (fun c -> c.Length = 1)\n    let vowels = vowels |> Array.map (fun c -> c.ToCharArray() |> Array.head)\n    let vowels = vowels |> Array.filter (fun c -> c.Length = 1)\n    let vowels = vowels |> Array.map (fun c -> c.ToCharArray() |> Array.head)\n    let vowels = vowels |> Array.filter (fun c -> c.Length = 1)\n    let vowels = vowels |> Array.map (fun c -> c.ToCharArray() |> Array.head)\n    let vowels = vowels |> Array.filter (fun c -> c.Length = 1)\n    let vowels = vowels |> Array.map (fun c -> c.ToCharArray() |> Array.head)\n    let vowels = vowels |> Array.filter (fun c -> c.Length = 1)\n    let vowels = vowels |> Array.map (fun c -> c.ToCharArray() |> Array.head)\n    let vowels = vowels |> Array.filter (fun c -> c.Length = 1)\n    let vowels = vowels |> Array.map (fun c -> c.ToCharArray() |> Array.head)\n    let vowels = vowels |> Array.filter (fun c -> c.Length = 1)\n    let vowels = vowels |> Array.map (fun c -> c.ToCharArray() |> Array.head)\n    let vowels = vowels |> Array.filter (fun c -> c.Length = 1)\n    let vowels = vowels |> Array.map (fun c -> c.ToCharArray() |>\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7g1zrq08.fsx(35,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (34:48). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp7g1zrq08.fsx(35,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (34:48). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp7g1zrq08.fsx(52,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (34:48). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp7g1zrq08.fsx(52,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (34:48). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp7g1zrq08.fsx(34,38): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> 'a' && c <> 'z')\n        |> List.map (fun c -> c.ToString\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbmttodl3.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbmttodl3.fsx(39,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = vowels |> List.filter (fun v -> word.Contains(v))\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word |> List.map (fun v -> v.ToString()) |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3vg_e6p4.fsx(13,58): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgz7j916v.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length) |> fun c -> c.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392842,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToLower())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToLower())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbjxr_80w.fsx(38,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (37:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbjxr_80w.fsx(38,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (37:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbjxr_80w.fsx(38,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (37:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbjxr_80w.fsx(55,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (37:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbjxr_80w.fsx(55,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (37:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbjxr_80w.fsx(55,5): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (37:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbjxr_80w.fsx(37,40): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray()\n    let vowels_in_word_length = vowels.Length\n    let vowels_in_word_index = vowels_in_word.GetIndex(0)\n    let vowels_in_word_index_in_word = vowels_in_word_index + vowels_in_word_length\n    let vowel_index = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word - vowels_in_word_index\n    let vowel_index_in_word_in_word = vowels_in_word_index_in_word\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpodtefxg7.fsx(28,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp72hkl83t.fsx(15,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp72hkl83t.fsx(32,1): error FS0010: Unexpected identifier in expression. Expected 'in' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_start = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.ToString())\n    let vowels_to_find_end_start_end_end_end = vowels |> List.map (fun c -> c.To\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpr0ghbad5.fsx(28,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (27:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpr0ghbad5.fsx(28,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray()\n    let vowels_in_word_length = vowels.Length\n    let vowels_in_word_index = vowels_in_word.GetIndex(word)\n    let vowels_in_word_index_in_vowel = vowels_in_word_index + vowels_in_word_length\n    let vowels_in_word_index_in_vowel_index = vowels_in_word_index_in_vowel - vowels_in_word_length\n    let vowels_in_word_index_in_vowel_index_in_vowel = vowels_in_word_index_in_vowel_index + vowels_in_word_length\n    let vowels_in_word_index_in_vowel_index_in_vowel_index = vowels_in_word_index_in_vowel_index_in_vowel - vowels_in_word_length\n    let vowels_in_word_index_in_vowel_index_in_vowel_index_in_vowel = vowels_in_word_index_in_vowel_index_in_vowel_index + vowels_in_word_length\n    let vowels_in_word_index_in_vowel_index_in_vowel_index_in_vowel_index = vowels_in_word_index_in_vowel_index_in_vowel_index_in_vowel - vowels_in_word_length\n    let vowels_in_word_index_in_vowel_index_in_vowel_index_in_vowel_index_in_vowel_index = vowels_in_word_index_in_vowel_index_in_vowel_index_in_vowel_index_in_vowel_index + vowels_in_word_length\n    let vowels_in_word_index_in_vowel_index_in\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa_i7qixc.fsx(24,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c ->\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp9sg1bsmu.fsx(43,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp9sg1bsmu.fsx(43,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp9sg1bsmu.fsx(60,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp9sg1bsmu.fsx(60,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp9sg1bsmu.fsx(42,20): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\"; \"ugt\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdmv8m643.fsx(32,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['a'..'z']\n    let vowels_to_find_end = ['y'..'z']\n    let vowels_to_find_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y'..'z']\n    let vowels_to_find_end_end_end_end = ['y\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyiwl_pwo.fsx(33,43): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmpyiwl_pwo.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    let vowels_in_word_length = vowels_in_word.Length\n    if vowels_in_word_length = 0 then \"\"\n    else\n        let closest_vowel = vowels_in_word.[0..vowels_in_word_length-1]\n        let closest_vowel_length = closest_vowel.Length\n        if closest_vowel_length = 0 then \"\"\n        else\n            let closest_vowel_in_word = \n                closest_vowel\n                |> Seq.map (fun c -> c.ToString())\n                |> Seq.toList\n            let closest_vowel_in_word_length = closest_vowel_in_word.Length\n            if closest_vowel_in_word_length = 0 then \"\"\n            else\n                let closest_vowel_in_word = \n                    closest_vowel\n                    |> Seq.map (fun c -> c.ToString())\n                    |> Seq.toList\n                let closest_vowel_in_word_length = closest_vowel_in_word.Length\n                if closest_vowel_in_word_length = 0 then \"\"\n                else\n                    let closest_vowel_in_word = \n                        closest_vowel\n                        |> Seq.map (fun c -> c.ToString())\n                        |> Seq.toList\n                    let closest_vowel_in_word_length = closest_vowel_in_word.Length\n                    if closest_vowel_in_word_length = 0 then \"\"\n                    else\n                        let closest_vowel_in_word = \n                            closest_vowel\n                            |> Seq.map (fun c -> c.ToString())\n                            |> Seq\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1jz5y2i9.fsx(46,25): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word.ToCharArray()\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n        |> Array.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        let closest_vowel = vowels_in_word |> List.minBy (fun c -> c.Length)\n        closest_vowel.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8u3mr8n5.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> \"\")\n        |> Array\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp11a2iuiv.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    if vowels.Length = 0 then\n        \"\"\n    else\n        vowels |> List.minBy (fun c -> c.Length) |> fun c -> c.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_left = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left_vowels_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left_vowels_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left_vowels_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_left_right_vowels_vowels = List.filter (fun v -> vowels |> List.contains v |> not) vowels\n    let vowels_right_left_vowels_vow\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps77czruc.fsx(27,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['A'..'Z']\n    let vowels_to_find_end = ['a'..'z']\n    let vowels_to_find_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['a'..'z']\n    let vowels_to_find_end_end_end_end = ['A\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8digujte.fsx(33,43): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmp8digujte.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_length = vowels.Length\n    let vowels_index = vowels.IndexOf word\n    if vowels_index = -1 then\n        \"No such vowel\"\n    else\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + vowels_length\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index = vowels_index + 1\n        let vowels_index =\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpsrxm7gid.fsx(50,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpsrxm7gid.fsx(50,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpsrxm7gid.fsx(67,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpsrxm7gid.fsx(67,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpsrxm7gid.fsx(67,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (49:9). Try indenting this token f",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\"; \"o\"; \"y\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdpyqonbb.fsx(15,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpdpyqonbb.fsx(32,1): error FS0010: Unexpected identifier in expression. Expected 'in' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"U\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvdxzdsai.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 1)\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    let vowels_left = vowels |> List.filter (fun c -> c.Length > 1)\n    let vowels_right = vowels |> List.filter (fun c -> c.Length < 2)\n    if vowels_left.Length = 0 && vowels_right.Length = 0 then \"\"\n    else \n        let left = vowels_left |> List.map (fun c -> c.ToString()) |> String.concat \"\"\n        let right = vowels_right |> List.map (fun c -> c.ToString()) |> String.concat \"\"\n        left + right\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n        |> String.concat \"\"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp66lkaaiy.fsx(27,21): error FS0001: The type 'string' is not compatible with the type 'seq<string>'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word)\n        |> List.map (fun c -> c.ToString())\n        |> List.distinct\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.head\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.map (fun c -> if Char.IsVowel(c) then c else '_')\n        |> Array.filter (fun c -> not (Char.IsVowel(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetter(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetter(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsDigit(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> not\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3o1ox843.fsx(40,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3o1ox843.fsx(40,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    let vowels = vowels |> List.distinct\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length) |> fun c -> c.ToUpper()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word && c <> ' ')\n\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnx4t7bfq.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['a'..'z']\n    let vowels_to_find_end = ['A'..'Z']\n    let vowels_to_find_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A'..'Z']\n    let vowels_to_find_end_end_end_end = ['A\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpt6jr9v_i.fsx(33,43): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmpt6jr9v_i.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"quick\"; \"ab\"]\n    let vowels_in_word = \n        word.ToCharArray()\n        |> Array.filter (fun c -> vowels |> Array.contains c)\n        |> Array.map (fun c -> c.ToString())\n    if vowels_in_word.Length = 0 then \"\"\n    else vowels_in_word.[0]\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplqmz11yk.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7592202w.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_count = vowels.Length\n    let vowels_left = vowels |> List.skip 1\n    let vowels_right = vowels |> List.skip vowels_count\n    let vowels_left_count = vowels_left |> List.length\n    let vowels_right_count = vowels_right |> List.length\n    let vowels_left_count_left = vowels_left |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_right_count_right = vowels_right |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_left_count_left_left = vowels_left |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_right_count_right_right = vowels_right |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_left_count_left_left_left = vowels_left |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_right_count_right_right_right = vowels_right |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_left_count_left_left_left_left = vowels_left |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_right_count_right_right_right_right = vowels_right |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_left_count_left_left_left_left_left = vowels_left |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_right_count_right_right_right_right_right = vowels_right |> List.filter (fun v -> v <> 'a') |> List.length\n    let vowels_left_count_left_left_left\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp27zh43z1.fsx(29,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[0])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[1])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[2])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[3])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[4])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[5])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[6])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[7])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[8])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[9])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[10])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[11])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[12])\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> c <> word.[13])\n        |> List.map (fun c -> c.ToString())\n        |\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppt1qjrjd.fsx(43,9): error FS0010: Unexpected symbol '|' in binding. Expected incomplete structured construct at or before this point or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> not (c.StartsWith(\"yogurt\")))\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> not (c.StartsWith(\"FULL\")))\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> not (c.StartsWith(\"quick\")))\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> not (c.StartsWith(\"ab\")))\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq.filter (fun c -> not (c.StartsWith(\"u\")))\n        |> Seq\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392845,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwfok7yyt.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"A\"\n            \"E\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"I\"\n            \"O\"\n            \"U\"\n            \"Y\"\n            \"G\"\n            \"O\"\n            \"U\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392839,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4_iyb_k6.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    if vowels.Length = 0 then\n        \"\"\n    else\n        let best = vowels |> List.minBy (fun c -> c.Length)\n        best.ToUpper()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.Length)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk5_vw4xd.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"A\"; \"E\"; \"I\"; \"O\"; \"U\"]\n    let vowels_index = Array.findIndex (fun v -> v = word) vowels\n    if vowels_index = -1 then \"\"\n    else vowels.[vowels_index]\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpxikqdb48.fsx(13,60): error FS0001: This expression was expected to have type\n    ''a[]'    \nbut here has type\n    'string list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.filter (fun c -> c <> 'a' && c <> 'e' && c <> 'i' && c <> 'o' && c <> 'u')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> if c = 'a' then 1 else 0)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdn57tmaq.fsx(18,48): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = ['A'..'Z']\n    let vowels_in_word_end = ['a'..'z']\n    let vowels_in_word_end_end = ['A'..'Z']\n    let vowels_in_word_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['A'..'Z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['A'..'Z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['A'..'Z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['A'..'Z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['A'..'Z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['A'..'Z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['A'..'Z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['A'..'Z']\n    let vowels_in_word_end_end_end_end = ['a'..'z']\n    let vowels_in_word_end_end_end_end = ['A\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdjajbdqt.fsx(33,43): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmpdjajbdqt.fsx(34,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (33:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (List.contains c word))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c ->\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphcjfqnnd.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmphcjfqnnd.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmphcjfqnnd.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmphcjfqnnd.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmphcjfqnnd.fsx(41,24): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392843,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk5_vw4xd.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(44,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk5_vw4xd.fsx(61,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgz7j916v.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [|\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"g\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpngkmhw3l.fsx(115,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpngkmhw3l.fsx(115,1): error FS0010: Unexpected keyword 'let' or 'use' in binding. Expected '|]' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> \"\")\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else vowels |> List.minBy (fun c -> c.ToString().Length)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToUpper())\n        |> Seq.toList\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToUpper())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToLower())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToUpper())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToLower())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToUpper())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToLower())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToUpper())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToLower())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToUpper())\n    let vowels = vowels\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8ujmc0in.fsx(37,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.filter (fun c -> \n            let isVowel = \n                c \n                |> Seq.exists (fun c' -> \n                    let isVowel = \n                        c' \n                        |> Seq.exists (fun c' -> \n                            let isVowel = \n                                c' \n                                |> Seq.exists (fun c' -> \n                                    let isVowel = \n                                        c' \n                                        |> Seq.exists (fun c' -> \n                                            let isVowel = \n                                                c' \n                                                |> Seq.exists (fun c' -> \n                                                    let isVowel = \n                                                        c' \n                                                        |> Seq.exists (fun c' -> \n                                                            let isVowel = \n                                                                c' \n                                                                |> Seq.exists (fun c' -> \n                                                                    let isVowel = \n                                                                        c' \n                                                                        |> Seq.exists (fun c' -> \n                                                                            let isVowel = \n                                                                                c' \n                                                                                |> Seq.exists (fun c' -> \n                                                                                    let isVowel = \n                                                                                        c' \n                                                                                        |> Seq.exists (fun c' -> \n                                                                                            let isVowel = \n                                                                                               c' \n                                                                                               |> Seq.exists (fun c' -> \n                                                                                                   let isVowel = \n                                                                                                       c' \n                                                                                                       |> Seq.exists (fun c' -> \n                                                                                                           let isVowel = \n                                                                                                               c' \n                                                                                                               |> Seq.exists (fun c' -> \n                                                                                                                   let isVowel = \n                                                                                                                       c' \n                                                                                                                       |> Seq.exists (fun c' -> \n                                                                                                                           let isVowel = \n                                                                                                                            \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpopjsgsyi.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (57:124). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpopjsgsyi.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (57:124). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpopjsgsyi.fsx(76,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (57:124). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpopjsgsyi.fsx(76,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (57:124). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpopjsgsyi.fsx(76,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (57:124). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpopjsgsyi.fsx(57,124): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else\n        vowels\n        |> List.sortBy (fun c -> c.Length)\n        |> List.head\n        |> fun c -> c.ToString()\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c ->\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(41,24): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.filter (fun c -> c <> ' ') \n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.toList \n    if vowels.Length = 0 then \n        \"\"\n    else\n        vowels\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n        |> List.sort\n        |> List.head\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > 0)\n        |> Seq.map (fun c -> c.ToLower())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\" else\n    let vowels = vowels |> List.rev\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToLower())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List.map (fun c -> c.ToString())\n    let vowels = vowels |> List.filter (fun c -> c.Length > 0)\n    let vowels = vowels |> List\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4rn1brd7.fsx(38,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = vowels |> List.filter (fun v -> v <> 'a' && v <> 'e')\n    let vowels_to_find_end = vowels |> List.filter (fun v -> v <> 'a' && v <> 'e')\n    let vowels_to_find_start = vowels |> List.filter (fun v -> v <> 'a' && v <> 'e')\n    let vowels_to_find_end_start = vowels |> List.filter (fun v -> v <> 'a' && v <> 'e' && v <> 'i')\n    let vowels_to_find_start_end = vowels |> List.filter (fun v -> v <> 'a' && v <> 'e' && v <> 'i')\n    let vowels_to_find_end_start_end = vowels |> List.filter (fun v -> v <> 'a' && v <> 'e' && v <> 'i' && v <> 'o')\n    let vowels_to_find_end_start_end_end = vowels |> List.filter (fun v -> v <> 'a' && v <> 'e' && v <> 'i' && v <> 'o' && v <> 'u')\n    let vowels_to_find_end_start_end_end_end = vowels |> List.filter (fun v -> v <> 'a' && v <> 'e' && v <> 'i' && v <> 'o' && v <> 'u' && v <> 'y')\n    let vowels_to_find_end_start_end_end_end_end = vowels |> List.filter (fun v -> v <> 'a' && v <> 'e' && v <> 'i' && v <> 'o' && v <> 'u' && v <> 'y')\n    let vowels_to_find_end_start_end_end_end_end_end = vowels |> List.filter (fun v -> v <> 'a'\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpndw1i1_1.fsx(23,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (22:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpndw1i1_1.fsx(23,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['A'..'Z']\n    let vowels_in_word = ['a'..'z']\n    let vowels_in_word_in_word = ['A'..'Z']\n    let vowels_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['a'..'z']\n    let vowels_in_word_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_in_word_in_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpiihctm3d.fsx(30,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"]\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length <> 0 then\n        vowels_in_word\n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    else\n        []\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpsk_d4zxz.fsx(27,21): error FS0001: The type 'string' is not compatible with the type 'seq<string>'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsUpper(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLower(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsWhiteSpace(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsPunctuation(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsWhiteSpace(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter(c)))\n        |> List.map (fun c -> c.ToString())\n        \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp6z42pmdy.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsVowel(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetter(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsWhiteSpace(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsPunctuation(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsLetterOrDigit(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsConnector(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsConnector(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsConnector(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsConnector(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsConnector(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsConnector(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (Char.IsConnector(c)))\n        |> List.map (fun c -> c.ToString())\n        \nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwe97oa6b.fsx(12,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = \n        word \n        |> Seq.filter (fun c -> vowels |> List.contains c)\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels_in_word.Length = 0 then\n        \"\"\n    else\n        vowels_in_word\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.reduce (fun x y -> x + \" \" + y)\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_count = vowels.Length\n    let vowels_left = vowels |> List.skip 1\n    let vowels_right = vowels |> List.skip vowels_count\n    let vowels_right_count = vowels_right |> List.length\n    let vowels_left_count = vowels_left |> List.length\n    let vowels_left_left = vowels_left |> List.skip 1\n    let vowels_left_right = vowels_left |> List.skip vowels_right_count\n    let vowels_left_right_count = vowels_left_right |> List.length\n    let vowels_right_left = vowels_right |> List.skip 1\n    let vowels_right_right = vowels_right |> List.skip vowels_left_count\n    let vowels_right_right_count = vowels_right_right |> List.length\n    let vowels_left_right_count = vowels_left_right |> List.length\n    let vowels_left_left = vowels_left_left |> List.skip 1\n    let vowels_left_right = vowels_left_right |> List.skip vowels_right_count\n    let vowels_left_right_count = vowels_left_right |> List.length\n    let vowels_right_left = vowels_right_left |> List.skip 1\n    let vowels_right_right = vowels_right_left |> List.skip vowels_left_count\n    let vowels_right_right_count = vowels_right_right |> List.length\n    let vowels_left_right_count = vowels_left_right |> List.length\n    let vowels_left_left = vowels_left_left |> List.skip 1\n    let vowels_left_right = vowels_left_right |> List.skip vowels_right_count\n    let vowels_left_right_count = vowels_left_right |> List.length\n    let vowels_right_left = vowels_right_left |\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphvf9oj6i.fsx(35,47): error FS0010: Unexpected symbol '|' in binding. Expected incomplete structured construct at or before this point or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray()\n    let vowels_in_word_len = vowels.Length\n    let vowels_in_word_len_in_vowels = vowels_in_word.Length\n    let vowels_in_word_len_in_vowels_in_closest_vowel = vowels_in_word_len - vowels_in_word_len_in_vowels\n    let closest_vowel = \n        if vowels_in_word_len_in_vowels_in_closest_vowel = 0 then \"\"\n        else vowels.[vowels_in_word_len_in_vowels - 1]\n    if closest_vowel = word then \"\"\n    else closest_vowel\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp78ppjyks.fsx(13,26): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.map (fun c -> if c = 'y' then 'o' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'y' vowels))\n        |> Array.map (fun c -> if c = 'F' then 'u' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'F' vowels))\n        |> Array.map (fun c -> if c = 'q' then 'u' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'q' vowels))\n        |> Array.map (fun c -> if c = 'a' then 'u' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'a' vowels))\n        |> Array.map (fun c -> if c = 'e' then 'u' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'e' vowels))\n        |> Array.map (fun c -> if c = 'i' then 'u' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'i' vowels))\n        |> Array.map (fun c -> if c = 'o' then 'u' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'o' vowels))\n        |> Array.map (fun c -> if c = 'u' then 'e' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'u' vowels))\n        |> Array.map (fun c -> if c = 'e' then 'i' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'e' vowels))\n        |> Array.map (fun c -> if c = 'i' then 'o' else c)\n        |> Array.filter (fun c -> not (Array.contains c 'i' vowels))\n        |> Array.map (fun c -> if c = 'o' then\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4kr4fcd6.fsx(35,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (34:32). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp4kr4fcd6.fsx(35,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (34:32). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp4kr4fcd6.fsx(52,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (34:32). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp4kr4fcd6.fsx(52,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (34:32). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp4kr4fcd6.fsx(52,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (34:32). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp4kr4fcd6.fsx(34,22): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [ 'a' .. 'z' ]\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c -> not (word.Contains(c)))\n        |> List.map (fun c -> c.ToString())\n        |> List.filter (fun c ->\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392840,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp3vkx_j9c.fsx(41,24): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = ['A'..'Z']\n    let vowels_right = ['a'..'z']\n    let vowels_right_left = ['A'..'Z']\n    let vowels_right_left_left = ['A'..'Z']\n    let vowels_left = ['a'..'z']\n    let vowels_left_right = ['A'..'Z']\n    let vowels_left_right_left = ['A'..'Z']\n    let vowels_left_right_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['A'..'Z']\n    let vowels_left_right_left_left_left = ['\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392846,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp6w13ba2p.fsx(36,45): error FS0010: Unexpected quote symbol in expression. Expected ']' or other token.\n\n\n\n/tmp/tmp6w13ba2p.fsx(37,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (36:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = [\"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"g\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\"; \"y\"; \"i\"; \"o\"; \"u\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpu4zlkefq.fsx(13,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpu4zlkefq.fsx(30,1): error FS0010: Unexpected identifier in expression. Expected 'in' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yogurt\"; \"u\"; \"ugly\"\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"yog\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwlplcxhi.fsx(47,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word.ToCharArray()\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> 'a' &&\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392844,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(56,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (38:35). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj8hnhh1h.fsx(38,25): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n    let vowels = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzlkuonyh.fsx(31,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_count = vowels.Length\n    let vowels_left = vowels |> List.filter (fun v -> v <> 'a')\n    let vowels_right = vowels |> List.filter (fun v -> v <> 'z')\n    let vowels_left_count = vowels_left.Length\n    let vowels_right_count = vowels_right.Length\n    let vowels_left_count_left = vowels_left |> List.filter (fun v -> v <> 'a')\n    let vowels_right_count_right = vowels_right |> List.filter (fun v -> v <> 'z')\n    let vowels_left_count_left_left = vowels_left |> List.filter (fun v -> v <> 'a')\n    let vowels_right_count_right_right = vowels_right |> List.filter (fun v -> v <> 'z')\n    let vowels_left_count_left_left_left = vowels_left |> List.filter (fun v -> v <> 'a')\n    let vowels_right_count_right_right_right = vowels_right |> List.filter (fun v -> v <> 'z')\n    let vowels_left_count_left_left_left = vowels_left |> List.filter (fun v -> v <> 'a')\n    let vowels_right_count_right_right_right = vowels_right |> List.filter (fun v -> v <> 'z')\n    let vowels_left_count_left_left_left = vowels_left |> List.filter (fun v -> v <> 'a')\n    let vowels_right_count_right_right_right = vowels_right |> List.filter (fun v -> v <> 'z')\n    let vowels_left_count_left_left_left = vowels_left |> List.filter (fun v -> v <> 'a')\n    let vowels_right_count_right_right_right = vowels_right |> List.filter (fun v -> v <> '\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp92rlqlg4.fsx(29,91): error FS0010: Unexpected quote symbol in expression\n\n\n\n/tmp/tmp92rlqlg4.fsx(30,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (29:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_left = ['a'..'z']\n    let vowels_right = ['A'..'Z']\n    let vowels_left_right = ['A'..'Z']\n    let vowels_left_right_vowel = ['a'..'z']\n    let vowels_right_left = ['A'..'Z']\n    let vowels_right_left_vowel = ['a'..'z']\n    let vowels_right_right = ['A'..'Z']\n    let vowels_right_left_vowel = ['a'..'z']\n    let vowels_left_right_vowel = ['A'..'Z']\n    let vowels_left_right_vowel_vowel = ['a'..'z']\n    let vowels_right_left_vowel = ['A'..'Z']\n    let vowels_right_left_vowel_vowel = ['a'..'z']\n    let vowels_left_right_vowel_vowel = ['A'..'Z']\n    let vowels_right_left_vowel_vowel = ['a'..'z']\n    let vowels_left_right_vowel_vowel = ['A'..'Z']\n    let vowels_right_left_vowel_vowel = ['a'..'z']\n    let vowels_left_right_vowel_vowel = ['A'..'Z']\n    let vowels_right_left_vowel_vowel = ['a'..'z']\n    let vowels_left_right_vowel_vowel = ['A'..'Z']\n    let vowels_right_left_vowel_vowel = ['a'..'z']\n    let vowels_left_right_vowel_vowel = ['A'..'Z']\n    let vowels_right_left_vowel_vowel = ['a'..'z']\n    let vowels_left_right_vowel_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpi2cc7wcm.fsx(36,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"\n            \"e\"\n            \"i\"\n            \"o\"\n            \"u\"\n            \"y\"\n            \"o\"\n            \"y\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"o\"\n            \"\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392841,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgz7j916v.fsx(132,1): error FS0010: Incomplete structured construct at or before this point in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_in_word = word.ToCharArray()\n    let mutable best_vowel = \"\"\n    let mutable best_vowel_index = 0\n    for i in vowels do\n        if vowels_in_word.[i] = word.[best_vowel_index] then\n            best_vowel <- best_vowel + i.ToString()\n            best_vowel_index <- best_vowel_index + 1\n    best_vowel\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkicpdnj2.fsx(13,26): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        word \n        |> Seq.filter (fun c -> c <> 'a' && c <> 'e')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if vowels.Length = 0 then \"\"\n    else\n        let vowels' = vowels |> Seq.toList\n        let vowels'' = vowels |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels''' = vowels'' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels'''' = vowels'' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels'''' = vowels''' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels''''' = vowels'''' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels'''''' = vowels''''' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels'''''' = vowels''''''' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels'''''' = vowels''''''' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels''''''' = vowels''''''''' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels''''''''' = vowels''''''''''' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels''''''''' = vowels''''''''''' |> List.filter (fun c -> c <> 'a' && c <> 'e')\n        let vowels''''''''' = vowels''''''''''' |> List.filter\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpr10g0hqf.fsx(31,9): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = \n        [\n            \"a\"; \"e\"; \"i\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\"; \"y\"; \"o\"; \"u\";\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbjhkabfr.fsx(15,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (12:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpbjhkabfr.fsx(32,1): error FS0010: Unexpected identifier in expression. Expected 'in' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//You are given a word. Your task is to find the closest vowel that stands between \n// two consonants from the right side of the word (case sensitive).\n// Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n// find any vowel met the above condition. \n// You may assume that the given string contains English letter only.\n// Example:\n// get_closest_vowel(\"yogurt\") ==> \"u\"\n// get_closest_vowel(\"FULL\") ==> \"U\"\n// get_closest_vowel(\"quick\") ==> \"\"\n// get_closest_vowel(\"ab\") ==> \"\"\nlet get_closest_vowel word = \n    let vowels = ['a'..'z']\n    let vowels_to_find = ['A'..'Z']\n    let vowels_to_find_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_word_in_word_in_word_in_word = ['A'..'Z']\n    let vowels_to_find_in_\nlet test() = \n  let candidate = get_closest_vowel\n  assert (candidate \"yogurt\" = \"u\")\n  assert (candidate \"full\" = \"u\")\n  assert (candidate \"easy\" = \"\")\n  assert (candidate \"eAsy\" = \"\")\n  assert (candidate \"ali\" = \"\")\n  assert (candidate \"bad\" = \"a\")\n  assert (candidate \"most\" = \"o\")\n  assert (candidate \"ab\" = \"\")\n  assert (candidate \"ba\" = \"\")\n  assert (candidate \"quick\" = \"\")\n  assert (candidate \"anime\" = \"i\")\n  assert (candidate \"Asia\" = \"\")\n  assert (candidate \"Above\" = \"o\")\n  0\n\ntest()",
      "timestamp": 1675392847,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplccedzjw.fsx(30,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}