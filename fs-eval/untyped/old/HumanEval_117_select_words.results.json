{
  "name": "HumanEval_117_select_words",
  "language": "fs",
  "prompt": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n",
  "tests": "let test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) =\n        if s.Length = 0 then\n            []\n        else\n            let words = s.Split(' ')\n            if words.Length < n then\n                words\n            else\n                words |> List.filter (fun word -> word.Length <= n)\n    \n    let words = select_words' s n\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzellrbg2.fsx(19,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = s.Split(' ')\n    if words.Length < n then \n        []\n    else\n        words.[..n-1]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2o5vler8.fsx(13,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = \n            s.Split(' ')\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n        words\n        |> List.ofArray\n        |> List.filter (fun word -> word.Length > n)\n        |> List.map (fun word -> word.Trim())\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> w.Trim())\n                |> Array.filter (fun w -> w.Length > n)\n                |> Array.map (fun w -> w.Trim())\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length > n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (fun w -> w.Length <= n)\n                |> Array.map (fun w -> w.ToLower())\n                |> Array.filter (\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq1k41b2d.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpq1k41b2d.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpq1k41b2d.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpq1k41b2d.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpq1k41b2d.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this t",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) =\n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpz354qumc.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun s -> \n                    let s = s.Trim()\n                    if s.Length = n then\n                        s.Split(' ')\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Trim())\n                        |> Array.map (fun s -> s.Tr\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnffyge7z.fsx(50,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (21:21). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpnffyge7z.fsx(50,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun w -> w <> \"\")\n        |> Array.map (fun w -> w.ToLower())\n    if n = 0 then words else words |> List.filter (fun w -> w.Contains(s, n))\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpg7actuox.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length <= n)\n        |>\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpql54r3pt.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpql54r3pt.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpql54r3pt.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpql54r3pt.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpql54r3pt.fsx(13,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else\n        let words = \n            s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length < n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length < n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length < n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length < n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length < n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length < n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length < n)\n            |> Array.map (fun word -> word.To\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqtkuy6kl.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqtkuy6kl.fsx(46,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        if n = 0 then []\n        else \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> \n                    let c = word.ToLower()\n                    c.Contains(n.ToString()))\n            if words.Length = n then words else select_words' s (n-1)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmai81szu.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else\n        let words = s.Split(' ')\n        if words.Length < n then []\n        else words.[..n-1]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5kocj27q.fsx(17,14): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if n = 0 then \n            []\n        else\n            let chars = s.ToCharArray()\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c <> ' ')\n            let chars = chars |> Array.map (fun c -> c.ToString())\n            let chars = chars |> Array.filter (fun c -> c\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptfe3r4wg.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (40:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmptfe3r4wg.fsx(41,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if s.Length = 0 then \n            [], n\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then \n                [], n\n            else\n                let words = words |> Array.skip (words.Length - n)\n                words |> Array.take n, select_words_rec words (n + 1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpohac55wb.fsx(22,26): error FS0001: The type ''a list' does not match the type 'string[]'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzf04po2v.fsx(17,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) n = \n        if s.Length <= n then []\n        else \n            let words = s.ToCharArray() |> Array.skip n |> Array.toList\n            words |> List.map (fun word -> word.ToLower())\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2u4w_tqo.fsx(17,44): error FS0493: ToLower is not an instance method\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq9aop4q1.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzf04po2v.fsx(17,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy90lwrz1.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpy90lwrz1.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpy90lwrz1.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpy90lwrz1.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpy90lwrz1.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this t",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpu6jqsw6_.fsx(17,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> \n                    word.Length > n && \n                    word.StartsWith(s, StringComparison.OrdinalIgnoreCase))\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprb2fdemp.fsx(21,40): error FS0039: The value, namespace, type or module 'StringComparison' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (fun s -> s.ToLower())\n        |> Array.filter (fun s -> s.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpg_9632_w.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.Trim())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa0b99q8u.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words else select_words_rec s (n-words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgz5y8ytt.fsx(22,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq9aop4q1.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqg52yh07.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,5): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(47,30): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuac02wb1.fsx(22,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n                |> Array.map (fun s -> s.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvjfe1jdg.fsx(18,36): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n        |> Array.map (fun s -> s.Trim())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3n634xo4.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun x -> x.Length > n)\n        |> Array.map (fun x -> x.Trim())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnmlx2x6l.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with \n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if n = 0 then words\n            else words |> List.filter (fun word -> word.Length = n)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptkfaa9jk.fsx(20,27): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (words: string list) (n: int) =\n        if n = 0 then words\n        else\n            let new_words = words |> List.filter (fun word -> word.Contains(s, n))\n            if new_words.IsEmpty then words\n            else select_words' new_words (n - 1)\n    select_words' [s] n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgok7_6u_.fsx(16,63): error FS0041: No overloads match for method 'Contains'.\n\nKnown types of arguments: 'a * int\n\nAvailable overloads:\n - System.String.Contains(value: char, comparisonType: System.StringComparison) : bool // Argument 'comparisonType' doesn't match\n - System.String.Contains(value: string, comparisonType: System.StringComparison) : bool // Argument 'comparisonType' doesn't match\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_26hczt8.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = s.Split(' ')\n    if words.Length < n then []\n    else words.[..(n-1)]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpm3z9o11b.fsx(13,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj750x0mm.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> n\n        | _ -> select_words' (s.Substring(0, n)) (n + 1)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpesrr7d49.fsx(20,50): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = s.Split(' ')\n        if words.Length <> n then []\n        else words.[..(words.Length - n)]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2b6qijfz.fsx(17,14): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> \n                    let n = int word.Length\n                    n >= n)\n            if n = n then words\n            else select_words_rec s (n - 1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkty180i4.fsx(22,27): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        if n = 0 then []\n        else \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words\n            else select_words' s (n-1)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdhill4ss.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = s.Split(' ')\n    let words = words |> Array.filter (fun word -> word.Length > n)\n    words |> Array.map (fun word -> word.Trim())\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyyyfxodd.fsx(13,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s \n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c.Length > n)\n        |> Seq.toList\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        if n = 0 then []\n        else \n            let words = \n                s.ToCharArray()\n                |> Array.filter (fun c -> \n                    if c = ' ' || c = '\\t' || c = '\\n' || c = '\\r' then false\n                    else \n                        let c = int c\n                        c >= 'A' && c <= 'Z'\n                        || c >= 'a' && c <= 'z'\n                        || c >= '0' && c <= '9'\n                        || c = '_'\n                        || c = '-'\n                        || c = '+'\n                        || c = '.'\n                        || c = ','\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\n                        || c = '.'\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2p62l7j_.fsx(79,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (16:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2p62l7j_.fsx(79,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq9aop4q1.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) n = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpksvetdj4.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = \n            s.Split(' ')\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length > n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length > n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun s -> s.Length <= n)\n            |> Array.map (fun s -> s.Trim())\n            |> Array.filter (fun\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbf418czt.fsx(47,1): error FS0010: Incomplete structured construct at or before this point in lambda expression\n\n\n\n/tmp/tmpbf418czt.fsx(47,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s \n        |> Seq.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpngrs6leu.fsx(13,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.ToCharArray()\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |>\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphge_wtqk.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmphge_wtqk.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmphge_wtqk.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmphge_wtqk.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmphge_wtqk.fsx(13,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) =\n        if s.Length = 0 then\n            []\n        else\n            let words = s.ToCharArray()\n            if words.Length < n then\n                words\n            else\n                words |> List.filter (fun w -> w.Length = n)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj24f7_rr.fsx(19,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'char[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuac02wb1.fsx(22,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) n = \n        if s.Length = 0 then []\n        elif n = 0 then []\n        else \n            let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            if words.Length <> n then []\n            else words |> List.map (fun word -> word.Trim())\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1hh4mwcw.fsx(17,42): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if n = 0 then words\n            else select_words_rec words (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3zcczodg.fsx(20,27): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpw1gg8rwr.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        if n = 0 then []\n        else \n            match s with\n            | \"\" -> []\n            | _ -> \n                let words = \n                    s.Split(' ')\n                    |> Array.map (fun word -> word.Trim())\n                words |> Array.filter (fun word -> word.Length > n)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk44n8tuh.fsx(22,26): error FS0001: The type ''a list' does not match the type 'string[]'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq9aop4q1.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else\n        let words = s.Split(' ')\n        if words.Length < n then []\n        else words.[..n-1]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5kocj27q.fsx(17,14): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) n = \n        match s.Length with\n        | 0 -> []\n        | _ -> \n            let words = s.ToCharArray()\n            if words.Length = n then\n                words\n            else\n                words |> List.filter (fun c -> \n                    let c = words.[c-1]\n                    c.Contains(s.[c-1])\n                )\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnag98jd4.fsx(19,17): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'char[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (fun word -> word.Trim())\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpexqd27v_.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (fun s -> s.Trim())\n    if n = 0 then words else words |> List.filter (fun w -> n >= w.Length)\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpphg525cu.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun w -> w <> \"\")\n                |> Array.map (fun w -> w.Trim())\n            if words.Length = n then words else select_words_rec s (n-words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpi4djzh57.fsx(21,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj750x0mm.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.Trim())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa0b99q8u.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpour2012_.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) n = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.ToCharArray()\n            let mutable i = 0\n            let mutable j = 0\n            let mutable result = []\n            while i < words.Length && j < n do\n                if words.[i] = words.[j] then\n                    result <- result @ [words.[i]]\n                    i <- i + 1\n                    j <- j + 1\n                else\n                    i <- i + 1\n                    j <- j + 1\n            result\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp9fah33xj.fsx(33,51): error FS0001: This expression was expected to have type\n    'char'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        if n = 0 then []\n        else \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> \n                    let word = word.Trim()\n                    word.Length > n)\n            if words.Length = n then words else select_words_rec s (n-words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_wj60_om.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) =\n        if s.Length = 0 then\n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdk1eb7xs.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) = \n        if n = 0 then \n            s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            |> List.ofArray\n        else\n            let words = \n                s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                |> List.ofArray\n            words |> List.filter (fun word -> word.Length = n)\n    \n    let words = select_words' s n\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpneow9xlw.fsx(15,30): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.ToCharArray()\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ')\n        |> Array.map (fun c -> c.\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplhqnc5bb.fsx(44,33): error FS0599: Missing qualification after '.'\n\n\n\n/tmp/tmplhqnc5bb.fsx(45,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (13:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec loop i = \n        if i = s.Length then []\n        else \n            let word = s.[i]\n            if word.Length = n then loop (i+1)\n            else loop (i+1)\n    loop 0\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqmov3a_x.fsx(14,16): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' acc = \n        if s = \"\" then \n            acc\n        else\n            let words = s.Split(' ')\n            if words.Length < n then \n                acc\n            else\n                let words = words.[..(words.Length - n)]\n                if words.Length = n then \n                    acc\n                else\n                    select_words' (words::acc)\n    select_words' []\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkpw9efvr.fsx(29,51): error FS0001: This expression was expected to have type\n    'string[]'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzf04po2v.fsx(17,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (fun word -> word.Trim())\n    if n = 0 then words\n    else words |> List.filter (fun word -> n % word.Length = 0)\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpef8_n0wz.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> w.Trim())\n                |> Array.filter (fun w -> w.Length > n)\n                |> Array.map (fun w -> w.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpesatdfes.fsx(22,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            if words.Length <> n then\n                []\n            else\n                words |> List.map (fun w -> w.Trim())\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd46iyjsw.fsx(17,42): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if n = 0 then words else select_words_rec words (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0eqreqai.fsx(20,27): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) =\n        if s.Length = 0 then\n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words |> List.map (fun word -> word.Trim())\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq1q4ss6x.fsx(21,26): error FS0001: The type 'string[]' does not match the type ''a list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        if n = 0 then words\n        else words |> List.filter (fun w -> n = w.Length)\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyfnjjihl.fsx(15,38): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.ToCharArray()\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n    if n = 0 then words else words |> List.filter (fun c -> n = c.Length)\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0pnj1guw.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if String.length s = 0 then []\n    else \n        let words = \n            s \n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c.Length > n)\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.toList\n        words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> word.Length > n)\n            if words.Length = n then words else select_words_rec s (n-words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpf2xd3j4u.fsx(20,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqg52yh07.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,5): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(47,30): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                |> Array.map (fun word -> word.Trim())\n            if words.Length < n then \n                words\n            else\n                words |> List.filter (fun word -> word.Length <= n)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7r5qr70y.fsx(18,34): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> n\n        | _ -> select_words' s (n + 1)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyrts7nvw.fsx(20,50): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        if n = 0 then []\n        else \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if words.Length > n then words.[..n-1] else []\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpfz088jbl.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (words:string list) (n:int) =\n        if n = 0 then\n            words\n        else\n            let new_words = words |> List.filter (fun word -> word.Length > n)\n            select_words_rec new_words (n - 1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpobz9rls3.fsx(22,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7pc1sivk.fsx(21,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if String.length s = 0 then []\n    else \n        let words = \n            s \n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c ->\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8l4ek_92.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8l4ek_92.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8l4ek_92.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8l4ek_92.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8l4ek_92.fsx(57,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token f",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        if n = 0 then []\n        else \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.ToLower())\n            if words.Length = n then words else select_words' s (n - 1)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdppud34j.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = \n            s.Split(' ')\n            |> Array.filter (fun w -> w <> \"\")\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqo7y3w23.fsx(47,1): error FS0010: Incomplete structured construct at or before this point in lambda expression\n\n\n\n/tmp/tmpqo7y3w23.fsx(47,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with \n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length <= n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length <= n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length <= n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length <= n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length <= n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length <= n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length <= n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length <= n)\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length <= n)\n                |> Array.\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvsqtqexq.fsx(47,25): error FS0599: Missing qualification after '.'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> List.filter (fun w -> w.Length > n)\n                |> List.map (fun w -> w.Trim())\n            if List.isEmpty words then [] else select_words_rec words (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp56notrvr.fsx(19,20): error FS0001: The type 'string[]' does not match the type ''a list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = s.Split(' ')\n    if words.Length < n then []\n    else words.[..(n-1)]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpm3z9o11b.fsx(13,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpour2012_.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if s.Length = 0 then \n            [], n\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then \n                [], n\n            else\n                let words = words |> Array.take n\n                words |> Array.map (fun word -> word.ToLower()) |> Array.toList\n    let words, n = select_words_rec s n\n    words, n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpz41undgz.fsx(22,68): error FS0001: The type ''a list * int' does not match the type 'string list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if n = 0 then []\n        else \n            let chars = s.ToCharArray()\n            let mutable i = 0\n            let mutable res = []\n            while i < chars.Length && chars.[i] <> ' ' do\n                res <- (chars.[i] |> string) :: res\n                i <- i + 1\n            res\n    let words = select_words_rec s n\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                |> Array.map (fun word -> word.Trim())\n            if n = 0 then words else words |> List.filter (fun word -> word.Contains(n.ToString()))\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp89e3trey.fsx(18,34): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun s -> s.Trim())\n            if n = 0 then words\n            else select_words_rec words (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuy5xamns.fsx(20,27): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) = \n        if s.Length = 0 then\n            [], n\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                failwith \"The number of words in the string is not equal to the number of words in the list.\"\n            else\n                let words = words |> List.map (fun word -> word.Trim())\n                words, n\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp__4nj2yl.fsx(21,38): error FS0001: The type 'string[]' does not match the type ''a list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = \n            s.Split(' ')\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n        words\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpu38kzw2s.fsx(20,12): error FS0001: The type 'string[]' does not match the type ''a list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnvdiwjj6.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpnvdiwjj6.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpnvdiwjj6.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpnvdiwjj6.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpnvdiwjj6.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this t",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.Trim())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpc93ny7dg.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun w -> w.Length > n)\n                |> Array.map (fun w -> w.Trim())\n            if words.Length = n then words else select_words_rec s (n-words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1n52szut.fsx(21,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.ToCharArray()\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplod6daof.fsx(40,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmplod6daof.fsx(40,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (13:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if String.length s = 0 then []\n    else \n        let words = \n            s \n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c -> c.ToString())\n            |> Seq.filter (fun c -> c <> \"\")\n            |> Seq.map (fun c ->\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8l4ek_92.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8l4ek_92.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8l4ek_92.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8l4ek_92.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp8l4ek_92.fsx(57,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token f",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) n = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.ToCharArray() |> Array.map (fun c -> if c = ' ' then \" \" else c)\n            let words = words |> Array.filter (fun w -> w.Length > n)\n            words |> Array.map (fun w -> w.ToCharArray() |> Array.map (fun c -> if c = ' ' then \" \" else c))\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp6oiodhtz.fsx(17,89): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is 'string'. This branch returns a value of type 'char'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzf04po2v.fsx(17,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> w.Trim())\n            if n = 0 then words\n            else select_words_rec words (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy62icrf0.fsx(20,27): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) n = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then \n                []\n            else\n                words.[..(words.Length - n)]\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpikc6a548.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq9aop4q1.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s \n        |> Seq.map (fun c -> c.ToString()) \n        |> Seq.filter (fun c -> c.Length > n)\n        |> Seq.toList\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |>\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy_1fam88.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpy_1fam88.fsx(46,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpy_1fam88.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpy_1fam88.fsx(57,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpy_1fam88.fsx(13,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = s.Split(' ')\n    if words.Length < n then []\n    else words.[..n-1]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppnj7x20i.fsx(13,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) =\n        if s.Length = 0 then\n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdk1eb7xs.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.ToCharArray()\n            if words.Length = n then\n                words\n            else\n                words |> List.filter (fun w -> w.Length <= n)\n    \n    let words = select_words_rec s n\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpitjvzxcu.fsx(19,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'char[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (words:string list) (n:int) =\n        if words.Length = 0 then\n            words\n        else\n            let words' = words |> List.filter (fun word -> word.Length <= n)\n            if words'.Length = 0 then\n                words'\n            else\n                words' |> List.map (fun word -> word.Substring(0, n))\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphvj61_ny.fsx(25,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) n = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then \n                []\n            else\n                words.[..(words.Length - n)]\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpikc6a548.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else\n        let words = \n            s.Split(' ')\n            |> Array.filter (fun w -> w <> \"\")\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpr7asrqgn.fsx(47,1): error FS0010: Incomplete structured construct at or before this point in lambda expression. Expected '->' or other token.\n\n\n\n/tmp/tmpr7asrqgn.fsx(47,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzf04po2v.fsx(17,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = \n            s.Split(' ')\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkk6lv85r.fsx(47,1): error FS0010: Incomplete structured construct at or before this point in lambda expression\n\n\n\n/tmp/tmpkk6lv85r.fsx(47,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n            words\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array.map (fun word -> word.Trim())\n            |> Array.filter (fun word -> word.Length <= n)\n            |> Array\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1tkfm8ws.fsx(13,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> \n                    let w = w.Trim()\n                    if w.Length > n then \n                        w.Substring(0, n)\n                    else\n                        w)\n            words\n            |> List.ofArray\n            |> List.filter (fun w -> w.Length > n)\n            |> List.map (fun w -> w.Trim())\n            |> List.map (fun w -> w.ToLower())\n            |> List.map (fun w -> w.ToUpper())\n            |> List.map (fun w -> w.Trim())\n            |> List.map (fun w -> w.ToLower())\n            |> List.map (fun w -> w.ToUpper())\n            |> List.map (fun w -> w.Trim())\n            |> List.map (fun w -> w.ToLower())\n            |> List.map (fun w -> w.ToUpper())\n            |> List.map (fun w -> w.Trim())\n            |> List.map (fun w -> w.ToLower())\n            |> List.map (fun w -> w.ToUpper())\n            |> List.map (fun w -> w.Trim())\n            |> List.map (fun w -> w.ToLower())\n            |> List.map (fun w -> w.ToUpper())\n            |> List.map (fun w -> w.Trim())\n            |> List.map (fun w -> w.ToLower())\n            |> List.map (fun w -> w.ToUpper())\n            |> List.map (fun w -> w.Trim())\n            |> List.map (fun w -> w.ToLower())\n            |> List.map (fun w -> w.ToUpper())\n            |> List.map (fun w -> w.Trim())\n            |> List.map (fun w -> w.ToLower())\n            |> List.map (fun w -> w.ToUpper\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdj9yemjo.fsx(52,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpdj9yemjo.fsx(52,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.Trim())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa0b99q8u.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpnlxtus2o.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = \n            s.Split(' ')\n            |> Array.filter (fun word -> word.Length > n)\n            |> Array.map (fun word -> word.Trim())\n        words\n        |> List.filter (fun word -> word.Length > n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List.map (fun word -> word.Trim())\n        |> List.filter (fun word -> word.Length <= n)\n        |> List\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpthx9epmt.fsx(20,12): error FS0001: The type 'string[]' does not match the type ''a list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = s.Split(' ')\n    if n = 0 then words\n    else words |> List.filter (fun word -> word.Length = n)\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpt2ihe0kj.fsx(13,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                |> Array.map (fun s -> s.Trim())\n            if n = 0 then words else words @ select_words_rec s (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpi2578mkr.fsx(18,34): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.ToCharArray()\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Array.map (fun c -> c.ToString())\n        |> Array.filter (fun c -> c <> ' ' && c <\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplod6daof.fsx(40,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmplod6daof.fsx(40,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (13:5). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) n = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            if words.Length = n then \n                words\n            else\n                words |> List.filter (fun word -> word.Length < n)\n    \n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7v5idpb6.fsx(17,42): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n                |> Array.map (fun word -> word.Trim())\n            if n = words.Length then words else select_words_rec words (n-words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8k8e_dc6.fsx(18,36): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzf04po2v.fsx(17,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.Trim())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa0b99q8u.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec loop acc = function\n        | [] -> acc\n        | word :: rest -> \n            if n = 0 then loop (word :: acc) rest\n            else loop (word :: acc) rest\n    loop [] s\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmposkmz32u.fsx(21,21): error FS0001: This expression was expected to have type\n    ''a list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = \n            s.Split(' ')\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length < n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length < n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length < n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length < n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length < n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length < n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length < n)\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprrzql8mt.fsx(47,1): error FS0010: Incomplete structured construct at or before this point in lambda expression\n\n\n\n/tmp/tmprrzql8mt.fsx(47,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (15:9). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if String.length s = 0 then []\n    else \n        let words = \n            s.ToCharArray()\n            |> Array.map (fun c -> \n                if c = ' ' || c = '\\t' || c = '\\n' || c = '\\r' then \n                    c\n                else \n                    c |> char |> string)\n            |> Array.toList\n        words |> List.filter (fun w -> w.Length >= n)\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8lih1bwh.fsx(21,34): error FS0001: The type 'char' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        if words.Length < n then []\n        else words.[..n-1]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpb56i2_6e.fsx(15,38): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (words:string list) (n:int) = \n        if words.Length = 0 then \n            words\n        else\n            let first_word = words.[0]\n            let rest_words = words.[1..]\n            if first_word.Length < n then\n                rest_words\n            else\n                let rest_words = select_words_rec rest_words (n - first_word.Length)\n                rest_words @ first_word :: rest_words\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplnvjbkm1.fsx(27,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\n    |> List.ofArray\n    |> List.filter (fun word -> word.Length <= n)\n    |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmdaaqz_8.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        if n = 0 then []\n        else \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words\n            else select_words' s (n-1)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdhill4ss.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> \n                    let ws = w.Split(' ')\n                    if ws.Length < n then \n                        [], ws\n                    else\n                        let ws = ws.[0..ws.Length-1]\n                        if ws.Length < n then \n                            [], ws\n                        else\n                            let ws = ws.[0..ws.Length-1]\n                            if ws.Length < n then \n                                [], ws\n                            else\n                                let ws = ws.[0..ws.Length-1]\n                                if ws.Length < n then \n                                    [], ws\n                                else\n                                    let ws = ws.[0..ws.Length-1]\n                                    if ws.Length < n then \n                                        [], ws\n                                    else\n                                        let ws = ws.[0..ws.Length-1]\n                                        if ws.Length < n then \n                                            [], ws\n                                        else\n                                            let ws = ws.[0..ws.Length-1]\n                                            if ws.Length < n then \n                                                [], ws\n                                            else\n                                                let ws = ws.[0..ws.Length-1]\n                                                if ws.Length < n then \n                                                    [], ws\n                                                else\n                                                    let ws = ws.[0..ws.Length-1]\n                                                    if ws.Length < n then \n                                                        [], ws\n                                                    else\n                                                        let ws = ws.[0..ws.Length-1]\n                                                        if ws.Length < n then \n                                                            [], ws\n                                                        else\n                                                            let ws = ws.[0..ws.Length-1]\n                                                            if ws.Length < n then \n                                                                [], ws\n                                                            else\n                                                                let ws = ws.[0..ws.Length-1]\n                                                                if w\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzyngv2eg.fsx(66,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmpzyngv2eg.fsx(66,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) = \n        if n = 0 then \n            s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        else\n            let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            if words.Length <> n then\n                raise (ArgumentException(\"The number of words in the string is not equal to the number of words in the list\"))\n            words\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpop_yu_rd.fsx(15,30): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        if n = 0 then []\n        else \n            let words = \n                s.Split(' ') \n                |> Array.filter (fun w -> w.Length > n)\n            if words.Length = n then words else select_words_rec s (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpe7sardhz.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_26hczt8.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1g1rfyfy.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> n\n        | _ -> select_words' (s.Substring(0, n)) (n + 1)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpesrr7d49.fsx(20,50): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = \n            s.Split(' ')\n            |> Array.map (fun w -> w.Trim())\n            |> Array.filter (fun w -> w.Length > n)\n            |> Array.map (fun w -> w.Trim())\n        words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8h0tfbaf.fsx(20,9): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.ToCharArray()\n        |> Array.filter (fun c -> c <> ' ' && c <> '\\n')\n        |> Array.map (fun c -> c.ToString())\n    words |> List.filter (fun c -> c <> ' ' && c <> '\\n') |> List.map (fun c -> c.ToString())\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjup7ik2j.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj750x0mm.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            if words.Length <> n then \n                []\n            else\n                words\n                |> List.filter (fun word -> \n                    let word = word.ToLower()\n                    word.Contains(s.ToLower()) && word.Length >= n)\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.ToUpper())\n                |> List.map (fun word -> word.ToLower())\n                |> List.map (fun word -> word.\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392815,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3etl_t7b.fsx(48,46): error FS0599: Missing qualification after '.'\n\n\n\n/tmp/tmp3etl_t7b.fsx(49,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (18:13). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    if s = \"\" then []\n    else \n        let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        words |> List.filter (fun word -> word.Length = n)\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp83zsqlmt.fsx(15,38): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> w.Trim())\n                |> Array.filter (fun w -> w.Length > n)\n                |> Array.map (fun w -> w.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpesatdfes.fsx(22,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> \n                    let n = \n                        word.Length\n                        |> int\n                    n >= n\n                    && n <= n + n)\n            if words.Length = n then words else select_words_rec s (n + 1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpf2glsjrd.fsx(25,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> n\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> w.Trim())\n                |> Array.filter (fun w -> w.Length > n)\n                |> Array.map (fun w -> w.Trim())\n            select_words' s (n - words.Length)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp91qy46nt.fsx(26,50): error FS0001: This expression was expected to have type\n    'int'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if n = 0 then words else select_words_rec words (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0eqreqai.fsx(20,27): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpour2012_.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                |> Array.map (fun s -> s.Trim())\n            if n = 0 then words\n            else words |> List.filter (fun w -> w.Length = n)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplvf1qcm1.fsx(18,34): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq9aop4q1.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words else select_words_rec s (n-words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvk7vnb94.fsx(21,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length >= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length >= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0xbun6tn.fsx(17,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with \n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpn1f12mpw.fsx(21,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) =\n        if s.Length = 0 then\n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpch7tisl7.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        if n = 0 then []\n        else \n            match s with\n            | \"\" -> []\n            | _ -> \n                let words = \n                    s.Split(' ')\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length <= n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpuw9on8la.fsx(48,54): error FS0599: Missing qualification after '.'\n\n\n\n/tmp/tmpuw9on8la.fsx(49,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (19:17). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) =\n        if s.Length = 0 then\n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdk1eb7xs.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpw1gg8rwr.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) =\n        if n = 0 then\n            s\n        else\n            let c = s.[n-1]\n            if c = ' ' then\n                select_words_rec (s.Substring(0, n)) (n-1)\n            else\n                s.Substring(0, n)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4i03hqsu.fsx(25,50): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if s.Length = 0 then \n            [], n\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then \n                [], n\n            else\n                let words = words |> Array.map (fun word -> word.Trim())\n                if words.Length <> n then \n                    [], n\n                else\n                    let words = words |> Array.map (fun word -> word.Trim())\n                    if words.Length <> n then \n                        [], n\n                    else\n                        let words = words |> Array.map (fun word -> word.Trim())\n                        if words.Length <> n then \n                            [], n\n                        else\n                            select_words_rec words (n-words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp36zdve_x.fsx(33,46): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'string[]'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if n = 0 then words else select_words_rec words (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0eqreqai.fsx(20,27): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s \n        |> Seq.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.filter (fun c -> c <> ' ')\n        |> Seq.toList\n    if n = 0 then words else words |> List.filter (fun c -> n >= c.Length)\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa2iicahi.fsx(17,38): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) n = \n        if s.Length = 0 then []\n        else \n            let words = s.ToCharArray()\n            if words.Length < n then []\n            else \n                let words = words |> Array.take n\n                words |> Array.map (fun w -> w.ToString())\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkwc4qouv.fsx(20,26): error FS0001: The type ''a list' does not match the type ''b[]'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = s.Split(' ')\n    if words.Length < n then \n        []\n    else\n        words.[..n-1]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2o5vler8.fsx(13,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.filter (fun word -> word.Length > n)\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_hwldk61.fsx(13,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> w.Trim())\n                |> Array.filter (fun w -> w.Length > n)\n                |> Array.map (fun w -> w.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392813,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpesatdfes.fsx(22,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun s -> s.Length > n)\n            words\n            |> List.ofArray\n            |> select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8wih19qf.fsx(23,16): error FS0001: This expression was expected to have type\n    'string list -> 'a list'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpf340vqgy.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec loop acc = \n        match s with\n        | \"\" -> acc\n        | _ -> loop (acc @ [s])\n    loop []\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun x -> x.Length > n)\n        |> Array.map (fun x -> x.Trim())\n    words\n    |> List.ofArray\n    |> List.filter (fun x -> x.Length > n)\n    |> List.map (fun x -> x.Trim())\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpi4n2p7ck.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length <= n)\n                |> Array.map (\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392810,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqg52yh07.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(48,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,5): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(59,6): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (17:13). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpqg52yh07.fsx(47,30): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) =\n        if n = 0 then\n            s.Split(' ')\n            |> List.ofArray\n            |> List.map (fun word -> word.ToLower())\n            |> List.filter (fun word -> word.Length > n)\n            |> List.map (fun word -> word.ToLower())\n        else\n            let word = s.Substring(0, n)\n            let rest = s.Substring(n)\n            let words = select_words' rest n\n            words @ word :: words\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpz_y4irm_.fsx(21,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> \n                    word.Length > n && \n                    word.StartsWith(s, StringComparison.OrdinalIgnoreCase))\n                |> Array.toList\n            words\n            |> List.filter (fun word -> \n                word.Length > n && \n                word.StartsWith(s, StringComparison.OrdinalIgnoreCase))\n            |> List.map (fun word -> word.Substring(n))\n            |> List.filter (fun word -> \n                word.Length > n && \n                word.StartsWith(s, StringComparison.OrdinalIgnoreCase))\n            |> List.map (fun word -> word.Substring(n))\n            |> List.filter (fun word -> \n                word.Length > n && \n                word.StartsWith(s, StringComparison.OrdinalIgnoreCase))\n            |> List.map (fun word -> word.Substring(n))\n            |> List.filter (fun word -> \n                word.Length > n && \n                word.StartsWith(s, StringComparison.OrdinalIgnoreCase))\n            |> List.map (fun word -> word.Substring(n))\n            |> List.filter (fun word -> \n                word.Length > n && \n                word.StartsWith(s, StringComparison.OrdinalIgnoreCase))\n            |> List.map (fun word -> word.Substring(n))\n            |> List.filter (fun word -> \n                word.Length > n && \n                word.StartsWith(s, StringComparison.OrdinalIgnoreCase))\n            |> List.map (fun word -> word.Substring(n))\n            |> List.filter (fun word -> \n                word.Length > n && \n                word.StartsWith(s, StringComparison.OrdinalIgnoreCase))\n            |> List.map (fun word -> word.Substring(n))\n            |> List\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392816,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpn69w79gt.fsx(13,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> w.Trim())\n                |> Array.filter (fun w -> w <> \"\")\n                |> Array.map (fun w -> w.Trim())\n            if n = 0 then words else select_words_rec words (n-1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjzlcx5fo.fsx(22,27): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' acc = \n        if n = 0 then\n            acc\n        else\n            let c = s.ToCharArray() |> Array.findIndex (fun c -> c = n)\n            if c = -1 then\n                acc\n            else\n                select_words' (c::acc)\n    select_words' []\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0nk16w6l.fsx(17,21): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        if n = 0 then []\n        else\n            match s with\n            | \"\" -> []\n            | _ -> \n                let words = \n                    s.Split(' ')\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length > n)\n                    |> Array.map (fun word -> word.Trim())\n                    |> Array.filter (fun word -> word.Length\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpu88312b0.fsx(49,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (19:17). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpu88312b0.fsx(49,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmlwc4lda.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if n = words.Length then words\n            else select_words_rec words (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcgvqeedh.fsx(20,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.Trim())\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprxu_to2j.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) (n:int) = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_26hczt8.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s \n        |> Seq.filter (fun c -> c <> ' ' && c <> '\\t')\n        |> Seq.map (fun c -> c.ToString())\n        |> Seq.toList\n    if n = 0 then words else words |> List.filter (fun c -> c <> ' ' && c <> '\\t')\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3cqno5ap.fsx(18,66): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n            if words.Length <> n then\n                []\n            else\n                words |> List.map (fun word -> word.Trim())\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjec_a3r9.fsx(17,42): error FS0039: The value, namespace, type or module 'StringSplitOptions' is not defined. Maybe you want one of the following:\n   String\n   string\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n            if n = words.Length then words else select_words' words (n+1)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy549j5wl.fsx(20,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpour2012_.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        if n = 0 then []\n        else \n            let words = \n                s \n                |> Seq.filter (fun c -> c <> ' ' && c <> '\\t')\n                |> Seq.map (fun c -> c.ToString())\n                |> Seq.toList\n            if words.Length = n then words\n            else select_words_rec s (n - 1)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392818,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj750x0mm.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' s n = \n        if n = 0 then []\n        else \n            let words = \n                s.Split(' ')\n                |> Array.map (fun w -> w.Trim())\n            if words.Length = n then words\n            else select_words' s (n - 1)\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpfam5_rup.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length <= n)\n        |> Array.map (fun s -> s.Trim())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmlwc4lda.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) =\n        if s.Length = 0 then\n            []\n        else\n            let words = s.Split(' ')\n            if words.Length < n then\n                words\n            else\n                words |> List.filter (fun w -> w.Length <= n)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwpjttzhw.fsx(19,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.map (fun s -> s.Trim())\n                |> Array.filter (fun w -> w.Length > n)\n            if words.Length = n then words else select_words_rec s (n-words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq92mmw5_.fsx(21,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.Trim())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa0b99q8u.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun word -> word.Trim())\n        |> Array.filter (fun word -> word.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392811,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa0b99q8u.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = s.Split(' ')\n    if words.Length < n then [] else words.[..n-1]\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppibip41j.fsx(13,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (words:string list) (n:int) =\n        if n = 0 then\n            words\n        else\n            let words' = words |> List.filter (fun w -> w.Length > n)\n            if words'.Length = 0 then\n                words'\n            else\n                words' |> List.map (fun w -> w.Substring(0, n))\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkhre4uic.fsx(25,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec (s:string) (n:int) = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then \n                []\n            else\n                words.[..(words.Length - n)]\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392818,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp483wjz6e.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\n    |> Array.filter (fun word -> word.Length > n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length <= n)\n    |> Array.map (fun word -> word.ToLower())\n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps8sajy3b.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.Trim())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392814,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpc93ny7dg.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        if n = 0 then []\n        else \n            let words = \n                s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n                |> Array.map (fun s -> s.Trim())\n            if words.Length < n then select_words_rec s (n-words.Length)\n            else words |> List.filter (fun word -> word.Length <= n)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpu4kybu8v.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.map (fun s -> s.Trim())\n        |> Array.filter (fun s -> s.Length > n)\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj750x0mm.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split(' ')\n        |> Array.filter (fun word -> word.Length > n)\n        |> Array.map (fun word -> word.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392812,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpour2012_.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let words = \n        s.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n        |> Array.map (fun x -> x.Trim())\n        |> Array.filter (fun x -> x.Length > n)\n        |> Array.map (fun x -> x.ToLower())\n    words\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392818,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5ewifsyt.fsx(14,9): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words' (s:string) n = \n        if s.Length = 0 then \n            []\n        else\n            let words = s.Split(' ')\n            if words.Length <> n then\n                []\n            else\n                words.[..(words.Length - n)]\n    select_words' s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392818,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5sbdv9it.fsx(21,17): error FS0001: All branches of an 'if' expression must return values implicitly convertible to the type of the first branch, which here is ''a list'. This branch returns a value of type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec select_words_rec s n = \n        match s with\n        | \"\" -> []\n        | _ -> \n            let words = \n                s.Split(' ')\n                |> Array.filter (fun word -> word.Length > n)\n                |> Array.map (fun word -> word.Trim())\n            if words.Length = n then words else select_words_rec s (n - words.Length)\n    select_words_rec s n\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392817,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpz_y4irm_.fsx(21,38): error FS0001: The 'if' expression needs to have type ''a list' to satisfy context type requirements. It currently has type 'string[]'.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string s and a natural number n, you have been tasked to implement \n// a function that returns a list of all words from string s that contain exactly \n// n consonants, in order these words appear in the string s.\n// If the string s is empty then the function should return an empty list.\n// Note: you may assume the input string contains only letters and spaces.\n// Examples:\n// select_words(\"Mary had a little lamb\", 4) ==> [\"little\"]\n// select_words(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n// select_words(\"simple white space\", 2) ==> []\n// select_words(\"Hello world\", 4) ==> [\"world\"]\n// select_words(\"Uncle sam\", 3) ==> [\"Uncle\"]\nlet select_words s n = \n    let rec loop i = \n        if i = 0 then []\n        else \n            let words = \n                s.Split(' ')\n                |> Array.map (fun word -> word.Trim())\n                |> Array.filter (fun word -> word.Length > n)\n            if words.Length = n then words else loop (i - 1)\n    loop 0\nlet test() = \n  let candidate = select_words\n  assert (candidate \"Mary had a little lamb\" 4 = [\"little\"])\n  assert (candidate \"Mary had a little lamb\" 3 = [\"Mary\"; \"lamb\"])\n  assert (candidate \"simple white space\" 2 = [])\n  assert (candidate \"Hello world\" 4 = [\"world\"])\n  assert (candidate \"Uncle sam\" 3 = [\"Uncle\"])\n  assert (candidate \"\" 4 = [])\n  assert (candidate \"a b c d e f\" 1 = [\"b\"; \"c\"; \"d\"; \"f\"])\n  0\n\ntest()",
      "timestamp": 1675392818,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdiza96lt.fsx(17,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}