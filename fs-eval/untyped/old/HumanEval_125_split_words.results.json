{
  "name": "HumanEval_125_split_words",
  "language": "fs",
  "prompt": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n",
  "tests": "let test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        []\n    else\n        words\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length > 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array.filter (fun word -> word.Length % 2 = 0)\n        |> Array.map (fun word -> word.ToLower())\n        |> Array\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpya4qvjb7.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let mutable i = 0\n    let mutable j = 0\n    let mutable count = 0\n    while i < words.Length && j < words.Length do\n        if words.[i] = words.[j] then\n            count <- count + 1\n            i <- i + 1\n            j <- j + 1\n        else\n            i <- i + 1\n            j <- j + 1\n    count\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd2gt6jwq.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        []\n    else\n        words\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbaj1liv1.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower = words |> Array.map (fun x -> x.ToLower())\n    let upper = words |> Array.map (fun x -> x.ToUpper())\n    lower, upper\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7uadgvxt.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        let lowerCaseWords = words |> Array.map (fun word -> word.ToLower())\n        let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n        let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToUpper())\n        let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n        let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToLower())\n        let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n        let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToUpper())\n        let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n        let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToLower())\n        let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n        let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToUpper())\n        let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n        let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToLower())\n        let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n        let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToUpper())\n        let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n        let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToLower())\n        let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n        let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToUpper())\n        let lower\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392776,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkazamz8h.fsx(33,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp75a9m7pn.fsx(41,1): error FS0010: Incomplete structured construct at or before this point in lambda expression\n\n\n\n/tmp/tmp75a9m7pn.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowerCaseLetters = words |> Array.map (fun word -> word.ToLower())\n    let lowerCaseLetters = lowerCaseLetters |> Array.filter (fun letter -> letter <> ' ')\n    let lowerCaseLetters = lowerCaseLetters |> Array.map (fun letter -> letter.ToLower())\n    let lowerCaseLetters = lowerCaseLetters |> Array.filter (fun letter -> letter <> ' ')\n    let lowerCaseLetters = lowerCaseLetters |> Array.map (fun letter -> letter.ToLower())\n    let lowerCaseLetters = lowerCaseLetters |> Array.filter (fun letter -> letter <> ' ')\n    let lowerCaseLetters = lowerCaseLetters |> Array.map (fun letter -> letter.ToLower())\n    let lowerCaseLetters = lowerCaseLetters |> Array.filter (fun letter -> letter <> ' ')\n    let lowerCaseLetters = lowerCaseLetters |> Array.map (fun letter -> letter.ToLower())\n    let lowerCaseLetters = lowerCaseLetters |> Array.filter (fun letter -> letter <> ' ')\n    let lowerCaseLetters = lowerCaseLetters |> Array.map (fun letter -> letter.ToLower())\n    let lowerCaseLetters = lowerCaseLetters |> Array.filter (fun letter -> letter <> ' ')\n    let lowerCaseLetters = lowerCaseLetters |> Array.map (fun letter -> letter.ToLower())\n    let lowerCaseLetters = lowerCaseLetters |> Array.filter (fun letter -> letter <> ' ')\n    let lowerCaseLetters = lowerCaseLetters |> Array.map (fun letter -> letter.ToLower())\n    let lowerCaseLetters = lowerCaseLetters |> Array.filter (fun letter -> letter <> ' ')\n    let lowerCaseLetters = lowerCaseLetters |> Array.map (fun letter -> letter.ToLower())\n    let lowerCaseLetters = lowerCaseLetters |> Array.filter (fun letter -> letter <> ' ')\n    let lowerCaseLetters = lowerCaseLetters |> Array.map (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392776,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2lzv5we1.fsx(29,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (28:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2lzv5we1.fsx(29,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (28:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2lzv5we1.fsx(29,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (28:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2lzv5we1.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (28:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp2lzv5we1.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (28:5). Try indenting this token ",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpaxxa09fw.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprmszerp_.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd282_e9y.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8p7unnig.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        []\n    else\n        words\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbaj1liv1.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: input must be of length 2\"\n    words\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3x70jbac.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower = words |> Array.map (fun x -> x.ToLower())\n    let even = lower |> Array.filter (fun x -> x.Length % 2 = 0)\n    let odd = lower |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd = even |> Array.filter (fun x -> x.Length % 2 = 0)\n    let even_odd_odd = even_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd = even_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun x -> x.Length % 2 = 1)\n    let even_odd\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzbbxsv8m.fsx(26,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower()\n    let words_lower = words.ToLower()\n    let words_upper = words.ToUpper()\n    let words_upper_lower = words_upper.ToLower()\n    let words_upper_upper = words_upper.ToUpper()\n    let words_upper_upper_lower = words_upper_upper.ToLower()\n    let words_upper_upper_upper = words_upper_upper.ToUpper()\n    let words_upper_upper_upper_lower = words_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper = words_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_lower = words_upper_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper_upper = words_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_lower = words_upper_upper_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper_upper_upper = words_upper_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_upper_lower = words_upper_upper_upper_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper_upper_upper_upper = words_upper_upper_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_upper_upper = words_upper_upper_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_upper_upper_lower = words_upper_upper_upper_upper_upper_upper_upper.ToLower()\n    let words_upper_upper_upper_upper_upper_upper_upper_upper = words_upper_upper_upper_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper_upper_upper_upper_upper_upper_upper = words_upper_upper_upper_upper_upper_upper.ToUpper()\n    let words_upper_upper_upper\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp155z0_tm.fsx(29,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpsy9ax8db.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprcukagko.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph6gjrfg3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower_case_letters = words |> Array.map (fun word -> word.ToLower())\n    let ord = lower_case_letters |> Array.map (fun word -> if word.Length % 2 = 0 then ord_of_char word.[0] else ord_of_char word.[1])\n    ord\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphw_o9_tq.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let lower_case_letters = words |> Array.map (fun x -> x.ToLower())\n    let odd_order = lower_case_letters |> Array.filter (fun x -> x.[0] = ',')\n    let even_order = odd_order |> Array.filter (fun x -> x.[0] = ',')\n    let even_order_with_odd_order = even_order |> Array.filter (fun x -> x.[0] = ',')\n    let even_order_with_even_order = even_order |> Array.filter (fun x -> x.[0] = ',')\n    let even_order_with_odd_order_and_even_order = even_order |> Array.filter (fun x -> x.[0] = ',' && x.[1] = ',')\n    let even_order_with_odd_order_and_even_order_and_even_order = even_order |> Array.filter (fun x -> x.[0] = ',' && x.[1] = ',' && x.[2] = ',')\n    let even_order_with_odd_order_and_even_order_and_even_order_and_even_order = even_order |> Array.filter (fun x -> x.[0] = ',' && x.[1] = ',' && x.[2] = ',' && x.[3] = ',')\n    let even_order_with_odd_order_and_even_order_and_even_order_and_even_order_and_even_order = even_order |> Array.filter (fun x -> x.[0] = ',' && x.[1] = ',' && x.[2] = ',' && x.[3] = ',' && x.[4] = ',')\n    let even_order_with_odd_order_and_even_order_and_even_order_and_even_order_and_even_order_and_even_order = even_order |> Array.filter (fun x -> x.[0] = ',' && x.[1] = ',' && x.[2] = ',' && x.[3]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp03btoz54.fsx(20,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (19:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp03btoz54.fsx(20,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        None\n    else\n        Some(words.[0], words.[1..])\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq0tqaww3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length - 1\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp35j131xl.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph6gjrfg3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_o9tfvfd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(40,21): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprxxww9wd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprxxww9wd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprxxww9wd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprxxww9wd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprxxww9wd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token furth",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        []\n    else\n        words\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length > 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length > 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\n        |> List.map (fun word -> word.ToLower())\n        |> List.filter (fun word -> word.Length <> 0)\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpl561one1.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 =\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpleuv51_5.fsx(39,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmpleuv51_5.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph6gjrfg3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp__ybvogq.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmopk4n1e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvxibx033.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp18o33197.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.None)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphxtrgztm.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words.[0], words.Length - 1\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpb9sq1qnt.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: input must be of length 2\"\n    words\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3x70jbac.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    let lowerCaseWords = words |> Array.map (fun word -> word.ToLower())\n    let lowerCaseWords = lowerCaseWords |> Array.filter (fun word -> word.Length > 0)\n    let upperCaseWords = words |> Array.filter (fun word -> word.Length <> 0)\n    let upperCaseWords = upperCaseWords |> Array.filter (fun word -> word.Length <> 0)\n    lowerCaseWords, upperCaseWords\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvkymtrll.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: input must be of length 2\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3h76pbl6.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower()\n    let words_lower = words.ToLower()\n    let words_upper = words.ToUpper()\n    let words_upper_lower = words_upper.ToUpper()\n    let words_upper_lower_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_upper.ToUpper()\n    let words_upper_lower_upper_upper_upper_upper_upper = words_\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpg2hpxnt4.fsx(30,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower()\n    let words = words.Split(',')\n    words\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzkt8mo52.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8p7unnig.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp18o33197.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word ->\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpsk702ezd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpsk702ezd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpsk702ezd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpsk702ezd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpsk702ezd.fsx(40,20): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 =\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpleuv51_5.fsx(39,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmpleuv51_5.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp57j8qd7e.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(40,21): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower_case_letters = words |> Array.map (fun word -> word.ToLower())\n    let lower_case_letters_count = lower_case_letters |> Array.length\n    let upper_case_letters = words |> Array.map (fun word -> word.ToUpper())\n    let upper_case_letters_count = upper_case_letters |> Array.length\n    let numbers = lower_case_letters_count + upper_case_letters_count\n    let numbers_of_lower_case_letters = lower_case_letters |> Array.map (fun word -> word.ToLower())\n    let numbers_of_upper_case_letters = upper_case_letters |> Array.map (fun word -> word.ToUpper())\n    let numbers_of_upper_case_letters_count = upper_case_letters |> Array.map (fun word -> word.ToUpper())\n    let numbers_of_lower_case_letters_count = lower_case_letters |> Array.map (fun word -> word.ToLower())\n    let numbers_of_upper_case_letters_count = upper_case_letters |> Array.map (fun word -> word.ToUpper())\n    let numbers_of_upper_case_letters_count = upper_case_letters |> Array.map (fun word -> word.ToUpper())\n    let numbers_of_lower_case_letters_count = lower_case_letters |> Array.map (fun word -> word.ToLower())\n    let numbers_of_upper_case_letters_count = upper_case_letters |> Array.map (fun word -> word.ToUpper())\n    let numbers_of_upper_case_letters_count = upper_case_letters |> Array.map (fun word -> word.ToUpper())\n    let numbers_of_lower_case_letters_count = lower_case_letters |> Array.map (fun word -> word.ToLower())\n    let numbers_of_upper_case_letters_count = upper_case_letters |> Array.map (fun word -> word.ToUpper())\n    let numbers\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyv2awt33.fsx(27,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        let words = words.[0].Split([|' '|], StringSplitOptions.None)\n        if words.Length = 0 then\n            [], 0\n        else\n            words.[0].Split([|' '|], StringSplitOptions.None)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length > 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0)\n            |> Array.map (fun word -> word.ToLower())\n            |> Array.filter (fun word -> word.Length % 2 = 0\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpi2b7nn6v.fsx(42,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (14:9). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpi2b7nn6v.fsx(42,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprcukagko.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower_case_letters = words |> Array.map (fun word -> word.ToLower())\n    let even_order = lower_case_letters |> Array.filter (fun word -> word.Length % 2 = 0)\n    let odd_order = lower_case_letters |> Array.filter (fun word -> word.Length % 2 = 1)\n    even_order, odd_order\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4qgroa2g.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph6gjrfg3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: not enough words\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbhf1zeml.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words.[0], words.Length - 1\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcaxnf4eg.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let words = words |> Array.map (fun w -> w.ToLower())\n    let words = words |> Array.filter (fun w -> w.Length > 0)\n    words\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzbhzid7c.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let words = words |> Array.map (fun c -> if Char.IsUpper(c) then ord(c) else ord(' '))\n    words |> Array.map (fun c -> if Char.IsUpper(c) then ord(c) else ord(' '))\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_vnm_inf.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLowerInvariant().Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map (fun word -> word.ToLowerInvariant())\n    |> List.map\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcsxhxpxl.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 =\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpleuv51_5.fsx(39,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmpleuv51_5.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let mutable i = 0\n    let mutable res = []\n    while i < words.Length do\n        if words.[i] = ' ' then\n            res <- (words.[..i-1], words.[i+1..]) :: res\n        else\n            res <- (words.[..i-1], words.[i+1..]) :: res\n        i <- i + 1\n    res\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpitcc7nt6.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    let lowercase = words |> Array.map (fun word -> word.ToLower())\n    let even = lowercase |> Array.filter (fun word -> word % 2 = 0)\n    let odd = lowercase |> Array.filter (fun word -> word % 2 = 1)\n    even, odd\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptq4zmkf8.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word ->\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppf4g7a_q.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmppf4g7a_q.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmppf4g7a_q.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmppf4g7a_q.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmppf4g7a_q.fsx(40,21): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split(',')\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp3thswpor.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprmszerp_.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpipr89du7.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpr5yomw0y.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph6gjrfg3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words.[0], words.Length - 1\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcaxnf4eg.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpw1ray88v.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToUpper())\n    |>\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp08kytiqf.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (9:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp08kytiqf.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (9:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp08kytiqf.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (9:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp08kytiqf.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (9:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp08kytiqf.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp57j8qd7e.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(40,21): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower = words |> Array.map (fun word -> word.ToLower())\n    let even = lower |> Array.filter (fun word -> word.[0] = ' ')\n    let odd = lower |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd = even |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd = even_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd = even_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd_odd_odd_odd = even_odd_odd_odd |> Array.filter (fun word -> word.[0] = ',')\n    let even_odd\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphrmxvf8i.fsx(26,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprcukagko.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        None\n    else\n        Some(words.[0].ToLower(), words.[1..])\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1mdy_f9l.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpr5yomw0y.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvxibx033.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowercase = words |> Array.map (fun word -> word.ToLower())\n    let ord = lowercase |> Array.map (fun word -> if word.Length > 1 then ord_of_char word.[0] else ord_of_char word.[0])\n    lowercase, ord\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5hmsf7jj.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpipr89du7.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.None)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpl0zbsael.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph6gjrfg3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5tn9u5v7.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let mutable i = 0\n    let mutable res = []\n    while i < words.Length do\n        if words.[i] = ' ' then\n            res <- res @ [words.[i]]\n            i <- i + 1\n        else\n            i <- i + 1\n    res\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvdok26zu.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.None)\n    let lower_case_words = words |> Array.map (fun word -> word.ToLower())\n    let lower_case_words_count = lower_case_words |> Array.length\n    let upper_case_words = words |> Array.map (fun word -> word.ToUpper())\n    let upper_case_words_count = upper_case_words |> Array.length\n    lower_case_words_count, upper_case_words_count\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkvkhwcv0.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let words_lower = words |> Array.map (fun w -> w.ToLower())\n    let words_upper = words |> Array.map (fun w -> w.ToUpper())\n    words_upper, words_lower\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp58te6d07.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa1drr1oc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8p7unnig.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    let lowercase = words |> Seq.map (fun word -> word.ToLower()) |> Seq.toList\n    let even = words |> Seq.map (fun word -> word.ToUpper()) |> Seq.toList\n    lowercase, even\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcvpe0hcc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let words_lower = words |> Array.map (fun c -> c.ToLower())\n    let words_upper = words |> Array.map (fun c -> c.ToUpper())\n    words_upper, words_lower\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpir9e2er5.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower_case_letters = words |> Array.map (fun word -> word.ToLower())\n    let ord = lower_case_letters |> Array.map (fun word -> if word.Length % 2 = 0 then ord_of_char word.[0] else ord_of_char word.[1])\n    words |> Array.map (fun word -> word.ToLower(), ord)\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7nk9b0z3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa3yci0la.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split(',')\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptzdzrq66.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphgz5cj0r.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLowerInvariant()\n    let words = words.Split([|','|], StringSplitOptions.RemoveEmptyEntries)\n    words\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2y3fyblh.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        None\n    else\n        Some(words.[0].ToLower(), words.[1..])\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1mdy_f9l.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 =\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp7z9c10mf.fsx(39,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmp7z9c10mf.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        None\n    else\n        Some(words.[0], words.[1..])\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq0tqaww3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower_case_words = words |> Array.map (fun word -> word.ToLower())\n    let lower_case_words_count = lower_case_words |> Array.length\n    let upper_case_words = words |> Array.map (fun word -> word.ToUpper())\n    let upper_case_words_count = upper_case_words |> Array.length\n    lower_case_words_count, upper_case_words_count\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_2l7jlhi.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower_case_letters = words |> Array.map (fun x -> x.ToLower())\n    let ord_letter = lower_case_letters |> Array.tryFind (fun x -> x = ord('a'))\n    if ord_letter.IsSome then\n        let lower_case_letters_count = lower_case_letters.Length\n        let upper_case_letters_count = lower_case_letters.Length\n        let even_odd_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_upper_case_letters_count = upper_case_letters_count % 2 = 0\n        let even_odd_count_lower_case_letters_count = upper_case_letters_count % 2 = 0\n        let even_odd_count_upper_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_lower_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_upper_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_lower_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_upper_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_lower_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_upper_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_lower_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_upper_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_lower_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_upper_case_letters_count = lower_case_letters_count % 2 = 0\n        let even_odd_count_\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpt68q6b26.fsx(30,1): error FS0010: Incomplete structured construct at or before this point in binding. Expected '=' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 =\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpleuv51_5.fsx(39,1): error FS0010: Incomplete structured construct at or before this point in expression\n\n\n\n/tmp/tmpleuv51_5.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    let lowercase = words |> Array.map (fun word -> word.ToLower())\n    let even = lowercase |> Array.filter (fun word -> word.Length % 2 = 0)\n    let odd = lowercase |> Array.filter (fun word -> word.Length % 2 = 1)\n    even, odd\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpz7lhdm_q.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let words = words |> Array.map (fun c -> if Char.IsUpper(c) then ord(c) else ord('_'))\n    words |> Array.filter (fun c -> c <> ord('_'))\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpaieotgzj.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpa3yci0la.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowerCaseWords = words |> Array.map (fun word -> word.ToLower())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToUpper())\n    lowerCaseWords\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpi0g8eh3f.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_o9tfvfd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp_o9tfvfd.fsx(40,21): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpd282_e9y.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpj7fvz8j8.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpj7fvz8j8.fsx(39,1): error FS0010: Unexpected keyword 'let' or 'use' in expression\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvxibx033.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word ->\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppf4g7a_q.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmppf4g7a_q.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmppf4g7a_q.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmppf4g7a_q.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmppf4g7a_q.fsx(40,21): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvxibx033.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lower_case_letters = words |> Array.map (fun word -> word.ToLower())\n    let odd_order = lower_case_letters |> Array.filter (fun word -> word.Length % 2 = 0)\n    odd_order |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpobdisw9e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length % 2 = 0)\n\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphco1h7j2.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8p7unnig.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words, words.Length\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph6gjrfg3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8p7unnig.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprmszerp_.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgkoxtb5h.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToCharArray()\n    let lowerCaseWords = words |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = words |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = upperCaseWords |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = upperCaseWords |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = upperCaseWords |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = upperCaseWords |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = upperCaseWords |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = upperCaseWords |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = upperCaseWords |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = upperCaseWords |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun c -> c.ToLower())\n    let upperCaseWords = upperCaseWords |> Array.map (fun c -> c.ToUpper())\n    let lowerCaseWords = lowerCaseWords |> Array.map\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8au_k4we.fsx(30,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowercase = words |> Array.map (fun word -> word.ToLower())\n    let even = lowercase |> Array.filter (fun word -> word.Length % 2 = 0)\n    let odd = lowercase |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_odd = even |> Array.filter (fun word -> word.Length % 2 = 0)\n    let even_odd_odd = even_odd |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_odd_even = even_odd |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_even = even |> Array.filter (fun word -> word.Length % 2 = 0)\n    let even_even_odd = even_even |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_even_odd_odd = even_even_odd |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_odd_even = even_odd_odd |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_odd_even_odd = even_odd_even |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_even = even |> Array.filter (fun word -> word.Length % 2 = 0)\n    let even_even_odd = even_even |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_even_odd_odd = even_even_odd |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_odd_even = even_odd_odd |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_odd_even_odd = even_odd_even |> Array.filter (fun word -> word.Length % 2 = 1)\n    let even_even = even |> Array.filter (fun word -> word.Length % 2 = 0)\n    let even_even_odd = even_even |\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyr95zw5_.fsx(27,35): error FS0010: Unexpected symbol '|' in binding. Expected incomplete structured construct at or before this point or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.Length)\n    |> Array.map (fun wordLength -> wordLength % 2)\n    |> Array.map (fun wordLength -> wordLength / 2)\n    |> Array.map (fun wordLength -> wordLength)\n    |> Array.map (fun wordLength -> wordLength % 2)\n    |> Array.map (fun wordLength -> wordLength / 2)\n    |> Array.map (fun wordLength -> wordLength)\n    |> Array.map (fun wordLength -> wordLength % 2)\n    |> Array.map (fun wordLength -> wordLength / 2)\n    |> Array.map (fun wordLength -> wordLength)\n    |> Array.map (fun wordLength -> wordLength % 2)\n    |> Array.map (fun wordLength -> wordLength / 2)\n    |> Array.map (fun wordLength -> wordLength)\n    |> Array.map (fun wordLength -> wordLength % 2)\n    |> Array.map (fun wordLength -> wordLength / 2)\n    |> Array.map (fun wordLength -> wordLength)\n    |> Array.map (fun wordLength -> wordLength % 2)\n    |> Array.map (fun wordLength -> wordLength / 2)\n    |> Array.map (fun wordLength -> wordLength)\n    |> Array.map (fun wordLength -> wordLength % 2)\n    |> Array.map (fun wordLength -> wordLength / 2)\n    |> Array.map (fun wordLength -> wordLength)\n    |> Array.map (fun wordLength -> wordLength % 2)\n    |> Array.map (fun wordLength -> wordLength / 2)\n    |> Array.map (fun wordLength -> wordLength)\n    |> Array.map (fun wordLength -> wordLength % 2)\n    |> Array.map (fun wordLength -> wordLength / 2)\n    |> Array.map (fun\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp786du0k0.fsx(41,1): error FS0010: Incomplete structured construct at or before this point in lambda expression\n\n\n\n/tmp/tmp786du0k0.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowercase = words |> Array.map (fun word -> word.ToLower())\n    let ord = lowercase |> Array.map (fun word -> if word.Length > 1 then ord_of_char word.[0] else ord_of_char word.[0])\n    words, lowercase, ord\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpu38kpxfa.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToLower())\n    |> List\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392780,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp12kcpa6c.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvxibx033.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowercase = words |> Array.map (fun word -> word.ToLower())\n    let ord = lowercase |> Array.map (fun word -> if word.Length > 1 then ord_of_char word.[0] else ord_of_char word.[0])\n    ord\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392780,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8xy176ry.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        [], 0\n    else\n        words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392780,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpz9lnmsxz.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: not enough words\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbhf1zeml.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: not enough words\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbhf1zeml.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392778,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp57j8qd7e.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp57j8qd7e.fsx(40,21): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprxxww9wd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprxxww9wd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprxxww9wd.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprxxww9wd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprxxww9wd.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token furth",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToUpper())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpqirl6_ox.fsx(39,35): error FS0599: Missing qualification after '.'\n\n\n\n/tmp/tmpqirl6_ox.fsx(40,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.None)\n    let lower_case_letters = words |> Array.map (fun word -> word.ToLower())\n    let ord_a = lower_case_letters |> Array.filter (fun x -> x.Length > 0) |> Array.length\n    let ord_b = lower_case_letters |> Array.filter (fun x -> x.Length <> 0) |> Array.length\n    let ord_z = lower_case_letters |> Array.filter (fun x -> x.Length = 0) |> Array.length\n    let num_lower_case_letters = lower_case_letters |> Array.filter (fun x -> x.Length > 0) |> Array.length\n    let num_uppercase_letters = lower_case_letters |> Array.filter (fun x -> x.Length <> 0) |> Array.length\n    let num_commas = lower_case_letters |> Array.filter (fun x -> x.Length > 0) |> Array.length\n    let num_spaces = lower_case_letters |> Array.filter (fun x -> x.Length <> 0) |> Array.length\n    let num_lower_case_letters = lower_case_letters |> Array.filter (fun x -> x.Length > 0) |> Array.length\n    let num_uppercase_letters = lower_case_letters |> Array.filter (fun x -> x.Length <> 0) |> Array.length\n    let num_commas = lower_case_letters |> Array.filter (fun x -> x.Length > 0) |> Array.length\n    let num_spaces = lower_case_letters |> Array.filter (fun x -> x.Length <> 0) |> Array.length\n    let num_lower_case_letters = lower_case_letters |> Array.filter (fun x -> x.Length = 0) |> Array.length\n    let num_uppercase_letters = lower_case_letters |> Array.filter (fun x -> x.Length = 0) |> Array.length\n    let num_commas = lower_case_letters |> Array.filter (\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk06ee7gw.fsx(25,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk06ee7gw.fsx(25,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk06ee7gw.fsx(25,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk06ee7gw.fsx(37,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk06ee7gw.fsx(37,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk06ee7gw.fsx(37,5): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (24:5). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmpk06ee7gw.fsx(24,57): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.ToLower().Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        []\n    else\n        words\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392780,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbkg23400.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmopk4n1e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length > 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n    |> Array.map (fun word -> word.ToLower())\n    |> Array.filter (fun word -> word.Length % 2 = 0)\n\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprcukagko.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([| ' ' |], StringSplitOptions.RemoveEmptyEntries)\n    let lower_case_letters = words |> Array.map (fun word -> word.ToLower())\n    let even_order = lower_case_letters |> Array.filter (fun word -> word.Length % 2 = 0)\n    let odd_order = lower_case_letters |> Array.filter (fun word -> word.Length % 2 = 1)\n    even_order, odd_order\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392780,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppuy_exe9.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphfpa6qpc.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    let lowerCaseWords = words |> Array.map (fun word -> word.ToLower())\n    let lowerCaseWords = lowerCaseWords |> Array.map (fun word -> word.ToUpper())\n    lowerCaseWords\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392779,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpi0g8eh3f.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        None\n    else\n        Some(words.[0], words.[1..])\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq0tqaww3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length = 0 then\n        None\n    else\n        Some(words.[0], words.[1..])\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpq0tqaww3.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words\n    |> List.map (fun word -> word.ToLower())\n    |> List.filter (fun word -> word.Length > 0)\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word -> word.ToUpper())\n    |> List.map (fun word -> word.ToLower())\n    |> List.map (fun word ->\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392780,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprivw5oy1.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprivw5oy1.fsx(41,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprivw5oy1.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprivw5oy1.fsx(53,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (8:1). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmprivw5oy1.fsx(40,17): error FS0583: Unmatched '('\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    words |> Array.map (fun w -> w.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8p7unnig.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> Array.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplyi50uxs.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.RemoveEmptyEntries)\n    words |> List.map (fun word -> word.ToLower())\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4mplwkro.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n// should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n// alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n// Examples\n// split_words(\"Hello world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"Hello,world!\") \u00e2\u017e\u017e [\"Hello\", \"world!\"]\n// split_words(\"abcdef\") == 3\nlet split_words txt = \n    let words = txt.Split([|' '|], StringSplitOptions.None)\n    if words.Length <> 2 then failwith \"split_words: invalid input\"\n    words.[0], words.[1]\nlet test() = \n  let candidate = split_words\n  assert (candidate \"Hello world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello,world!\" = [\"Hello\"; \"world!\"])\n  assert (candidate \"Hello world,!\" = [\"Hello\"; \"world,!\"])\n  assert (candidate \"Hello,Hello,world !\" = [\"Hello,Hello,world\"; \"!\"])\n  assert (candidate \"abcdef\" = 3)\n  assert (candidate \"aaabb\" = 2)\n  assert (candidate \"aaaBb\" = 1)\n  assert (candidate \"\" = 0)\n  0\n\ntest()",
      "timestamp": 1675392777,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppkxh345e.fsx(9,17): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    }
  ]
}