{
  "name": "HumanEval_14_all_prefixes",
  "language": "fs",
  "prompt": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n",
  "tests": "let test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
  "stop_tokens": [
    "\n(*",
    "\n//",
    "\ntype",
    "\n\n"
  ],
  "results": [
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.rev\n            |> all_prefixes_rec (prefixes.Tail)\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_12u6kqx.fsx(12,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefixes' = \n                match head with\n                | 'a' -> ['a', 'a', 'a']\n                | 'b' -> ['b', 'b', 'b']\n                | 'c' -> ['c', 'c', 'c']\n                | 'd' -> ['d', 'd', 'd']\n                | 'e' -> ['e', 'e', 'e']\n                | 'f' -> ['f', 'f', 'f']\n                | 'g' -> ['g', 'g', 'g']\n                | 'h' -> ['h', 'h', 'h']\n                | 'i' -> ['i', 'i', 'i']\n                | 'j' -> ['j', 'j', 'j']\n                | 'k' -> ['k', 'k', 'k']\n                | 'l' -> ['l', 'l', 'l']\n                | 'm' -> ['m', 'm', 'm']\n                | 'n' -> ['n', 'n', 'n']\n                | 'o' -> ['o', 'o', 'o']\n                | 'p' -> ['p', 'p', 'p']\n                | 'q' -> ['q', 'q', 'q']\n                | 'r' -> ['r', 'r', 'r']\n                | 's' -> ['s', 's', 's']\n                | 't' -> ['t', 't', 't']\n                | 'u' -> ['u', 'u', 'u']\n                | 'v' -> ['v', 'v', 'v']\n                | 'w' -> ['w', 'w', 'w']\n                | 'x' -> ['x', 'x', 'x']\n                | 'y' -> ['y', 'y', 'y']\n                | 'z' -> ['z', 'z', 'z']\n                | '\\'' -> ['\\'']\n                | '\\'' -> ['\\'']\n                | '\\'' -> ['\\'']\n                | '\\'' -> ['\\'']\n                \nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449533,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkyu396wb.fsx(9,13): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            if prefix.Length > 0 then \n                prefix::all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.Trim()\n            if prefix.Length > 0 then\n                prefix::all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp44ufinma.fsx(17,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (s: string) =\n        match s with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = s.Substring(0, s.Length - 1)\n            prefixes @ [prefix]\n            |> all_prefixes' (prefixes @ [prefix])\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjyp49x3a.fsx(11,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.Trim()\n            if prefix.Length > 0 then\n                prefix::all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefixes' =\n                if head.StartsWith(string '.') then\n                    prefixes @ [head]\n                else\n                    prefixes\n            all_prefixes_rec tail\n    all_prefixes_rec []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgg6suglt.fsx(10,20): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.Substring(0,1)\n            let suffix = head.Substring(1)\n            prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.rev\n            |> all_prefixes_rec (prefixes.Tail)\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpke5k7uxj.fsx(12,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | x::xs ->\n            let prefixes' = x::prefixes\n            all_prefixes' prefixes'\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.ToLower()\n            if prefix.StartsWith(string) then\n                prefix::all_prefixes_rec tail\n            else\n                prefix::all_prefixes_rec tail\n    all_prefixes_rec (string.ToLower().Split(' '))\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmcv1yc4i.fsx(10,16): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) = \n        match str with \n        | \"\" -> prefixes\n        | _ -> \n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec acc = function\n        | [] -> acc\n        | x::xs -> \n            match x with\n            | 'a' -> all_prefixes_rec (acc @ [x]) xs\n            | 'b' -> all_prefixes_rec (acc @ [x]) xs\n            | 'c' -> all_prefixes_rec (acc @ [x]) xs\n            | _ -> failwith \"unexpected character\"\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpalyhusgd.fsx(16,21): error FS0001: This expression was expected to have type\n    'char list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            if prefix.Length = 0 then \n                all_prefixes_rec tail\n            else\n                prefix::all_prefixes_rec tail\n    all_prefixes_rec [string]\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (s:string) =\n        match s.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefix = s.Substring(0, s.Length - 1)\n            prefixes |> List.map (fun prefix -> prefix + prefix)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes |> List.filter (fun prefix -> prefix = prefix)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefixes' = \n                match head with \n                | 'a' -> [ 'a' ]\n                | 'b' -> [ 'b' ]\n                | 'c' -> [ 'c' ]\n                | 'd' -> [ 'd' ]\n                | 'e' -> [ 'e' ]\n                | 'f' -> [ 'f' ]\n                | 'g' -> [ 'g' ]\n                | 'h' -> [ 'h' ]\n                | 'i' -> [ 'i' ]\n                | 'j' -> [ 'j' ]\n                | 'k' -> [ 'k' ]\n                | 'l' -> [ 'l' ]\n                | 'm' -> [ 'm' ]\n                | 'n' -> [ 'n' ]\n                | 'o' -> [ 'o' ]\n                | 'p' -> [ 'p' ]\n                | 'q' -> [ 'q' ]\n                | 'r' -> [ 'r' ]\n                | 's' -> [ 's' ]\n                | 't' -> [ 't' ]\n                | 'u' -> [ 'u' ]\n                | 'v' -> [ 'v' ]\n                | 'w' -> [ 'w' ]\n                | 'x' -> [ 'x' ]\n                | 'y' -> [ 'y' ]\n                | 'z' -> [ 'z' ]\n                | 'A' -> [ 'A' ]\n                | 'B' -> [ 'B' ]\n                | 'C' -> [ 'C' ]\n                | 'D' -> [ 'D' ]\n                | 'E' -> [ 'E' ]\n                | 'F' -> [ 'F' ]\n                | 'G' -> [ 'G' ]\n                | 'H' -> [ 'H' ]\n                | 'I' -> [ 'I' ]\n                | 'J' -> [ 'J' ]\n                | 'K' -> [ 'K' ]\n                | 'L' -> [ 'L' ]\n                | '\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449533,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpiddnmy_z.fsx(49,19): error FS0010: Unexpected quote symbol in pattern matching\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.IndexOf('.'))\n            prefixes @ [prefix]\n            |> all_prefixes_rec (prefixes @ [prefix])\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp36ky54n3.fsx(11,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> str.Substring(prefix.Length))\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str.[0]]\n            all_prefixes' prefixes' (str.Substring(1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpp05xra86.fsx(9,41): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.TrimStart('a')\n            if prefix.Length > 0 then \n                prefixes @ [prefix]\n            else \n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | x::xs -> \n            if x = string(string(prefixes.[0])) then \n                prefixes\n            else\n                all_prefixes' xs\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdo8_pd9d.fsx(16,21): error FS0001: This expression was expected to have type\n    'string -> string'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.Trim()\n            if prefix.Length > 0 then\n                all_prefixes' tail\n            else\n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes_rec prefixes' str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.Trim()\n            if prefix.Length > 0 then\n                prefixes\n                |> List.map (fun prefix -> prefix + \" \" + all_prefixes' tail)\n                |> List.concat\n                |> List.rev\n                |> List.distinct\n                |> List.sort\n            else\n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpw1az5gtr.fsx(12,59): error FS0001: The type ''a list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes |> List.map (fun prefix -> prefix + prefix)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449535,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            if prefix.Length = 0 then \n                all_prefixes_rec tail\n            else\n                prefix::all_prefixes_rec tail\n    all_prefixes_rec (string.Split(' ') |> List.ofArray)\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449535,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpxmqg1ayk.fsx(14,23): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + \" \")\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes_rec prefixes' str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec acc = function\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'd' -> acc\n        | 'e' -> acc\n        | 'f' -> acc\n        | 'g' -> acc\n        | 'h' -> acc\n        | 'i' -> acc\n        | 'j' -> acc\n        | 'k' -> acc\n        | 'l' -> acc\n        | 'm' -> acc\n        | 'n' -> acc\n        | 'o' -> acc\n        | 'p' -> acc\n        | 'q' -> acc\n        | 'r' -> acc\n        | 's' -> acc\n        | 't' -> acc\n        | 'u' -> acc\n        | 'v' -> acc\n        | 'w' -> acc\n        | 'x' -> acc\n        | 'y' -> acc\n        | 'z' -> acc\n        | '0' -> acc\n        | '1' -> acc\n        | '2' -> acc\n        | '3' -> acc\n        | '4' -> acc\n        | '5' -> acc\n        | '6' -> acc\n        | '7' -> acc\n        | '8' -> acc\n        | '9' -> acc\n        | '.' -> acc\n        | '+' -> acc\n        | '-' -> acc\n        | '*' -> acc\n        | '/' -> acc\n        | '%' -> acc\n        | '^' -> acc\n        | '&' -> acc\n        | '|' -> acc\n        | '~' -> acc\n        | c -> all_prefixes_rec (c :: acc)\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449535,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptqz652ct.fsx(52,16): error FS0001: Type mismatch. Expecting a\n    ''a'    \nbut given a\n    'char -> 'a'    \nThe types ''a' and 'char -> 'a' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> str.Substring(prefix.Length))\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.ToLower()\n            if prefix.Length > 0 then \n                all_prefixes' tail\n            else \n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes |> List.append [prefix]\n            all_prefixes_rec prefixes (str.Substring(str.Length - 1))\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphd15vmqn.fsx(10,13): warning FS0020: The result of this expression has type 'string list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            if prefix.Length > 0 then \n                prefix::all_prefixes_rec tail\n            else\n                prefix::all_prefixes_rec tail\n    all_prefixes_rec (string.Split([|' '; '\\t'|], StringSplitOptions.RemoveEmptyEntries))\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449535,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0agddk8q.fsx(14,23): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            if prefix.Length > 0 then \n                all_prefixes' tail\n            else \n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + \" \")\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) = \n        match str with \n        | \"\" -> prefixes\n        | _ -> \n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | x::xs -> \n            let prefixes' = \n                match x with \n                | 'a' -> [x]\n                | 'b' -> [x; x]\n                | 'c' -> [x; x; x]\n                | 'd' -> [x; x; x; x]\n                | 'e' -> [x; x; x; x; x]\n                | 'f' -> [x; x; x; x; x; x]\n                | 'g' -> [x; x; x; x; x; x; x]\n                | 'h' -> [x; x; x; x; x; x; x; x]\n                | 'i' -> [x; x; x; x; x; x; x; x; x]\n                | 'j' -> [x; x; x; x; x; x; x; x; x; x]\n                | 'k' -> [x; x; x; x; x; x; x; x; x; x; x; x]\n                | 'l' -> [x; x; x; x; x; x; x; x; x; x; x; x; x]\n                | 'm' -> [x; x; x; x; x; x; x; x; x; x; x; x; x; x]\n                | 'n' -> [x; x; x; x; x; x; x; x; x; x; x; x; x; x; x]\n                | 'o' -> [x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x]\n                | 'p' -> [x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x; x\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449535,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp64uua0gj.fsx(27,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (10:17). Try indenting this token further or using standard formatting conventions.\n\n\n\n/tmp/tmp64uua0gj.fsx(27,1): error FS0010: Unexpected keyword 'let' or 'use' in expression. Expected ']' or other token.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            let prefixes = \n                if prefix.Length > 0 then \n                    prefixes @ all_prefixes' tail\n                else \n                    prefixes\n            prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefixes' = all_prefixes' tail\n            prefixes' @ [head]\n    all_prefixes' string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmzkl2njy.fsx(14,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> all_prefixes_rec (prefixes @ [prefix])\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp_3jzw2_c.fsx(11,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (s:string) =\n        if s.StartsWith(prefixes.[0]) then\n            prefixes.[0] :: all_prefixes' prefixes s.[1..]\n        else\n            prefixes\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str.[0]]\n            all_prefixes_rec prefixes (str.Substring(1))\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4gpxb93s.fsx(9,40): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ when str.StartsWith(prefixes.[0]) -> prefixes\n        | _ -> all_prefixes_rec (prefixes.Tail) str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            let prefixes = prefix::prefixes\n            all_prefixes_rec prefixes\n    all_prefixes_rec []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.map (fun prefix -> prefix + \" \" + all_prefixes' prefixes)\n            |> List.reduce (fun acc prefix -> prefix + \" \" + acc)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmph9l8bshi.fsx(11,55): error FS0001: The type 'string -> string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) = \n        match prefixes with \n        | [] -> []\n        | x::xs -> \n            let prefix = x.ToLower()\n            if prefix.Length > 0 then \n                all_prefixes' xs\n            else \n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.rev\n            |> all_prefixes_rec (prefixes @ [prefix])\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpaa2ho77p.fsx(12,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec acc = function\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'd' -> acc\n        | 'e' -> acc\n        | 'f' -> acc\n        | 'g' -> acc\n        | 'h' -> acc\n        | 'i' -> acc\n        | 'j' -> acc\n        | 'k' -> acc\n        | 'l' -> acc\n        | 'm' -> acc\n        | 'n' -> acc\n        | 'o' -> acc\n        | 'p' -> acc\n        | 'q' -> acc\n        | 'r' -> acc\n        | 's' -> acc\n        | 't' -> acc\n        | 'u' -> acc\n        | 'v' -> acc\n        | 'w' -> acc\n        | 'x' -> acc\n        | 'y' -> acc\n        | 'z' -> acc\n        | '0' -> acc\n        | '1' -> acc\n        | '2' -> acc\n        | '3' -> acc\n        | '4' -> acc\n        | '5' -> acc\n        | '6' -> acc\n        | '7' -> acc\n        | '8' -> acc\n        | '9' -> acc\n        | '.' -> acc\n        | '+' -> acc\n        | '-' -> acc\n        | '*' -> acc\n        | '/' -> acc\n        | '?' -> acc\n        | '~' -> acc\n        | '^' -> acc\n        | '_' -> acc\n        | '`' -> acc\n        | '[' -> acc\n        | ']' -> acc\n        | '{' -> acc\n        | '}' -> acc\n        | '~' -> acc\n        | '~' -> acc\n        | '|' -> acc\n        | '|' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449535,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp17q7fx0u.fsx(70,11): error FS0010: Unexpected quote symbol in pattern matching\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefixes' = \n                if head.StartsWith(string('a')) then \n                    prefixes' @ [ head ]\n                else \n                    prefixes'\n            all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpboucagwd.fsx(10,20): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.ToLower()\n            if prefix.Length > 0 then\n                all_prefixes' tail\n            else\n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes |> List.filter (fun prefix -> prefix.StartsWith(prefix))\n    \n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefixes_list = \n                match head with\n                | 'a' -> [ 'a' ]\n                | 'b' -> [ 'b' ]\n                | 'c' -> [ 'c' ]\n                | 'd' -> [ 'd' ]\n                | 'e' -> [ 'e' ]\n                | 'f' -> [ 'f' ]\n                | 'g' -> [ 'g' ]\n                | 'h' -> [ 'h' ]\n                | 'i' -> [ 'i' ]\n                | 'j' -> [ 'j' ]\n                | 'k' -> [ 'k' ]\n                | 'l' -> [ 'l' ]\n                | 'm' -> [ 'm' ]\n                | 'n' -> [ 'n' ]\n                | 'o' -> [ 'o' ]\n                | 'p' -> [ 'p' ]\n                | 'q' -> [ 'q' ]\n                | 'r' -> [ 'r' ]\n                | 's' -> [ 's' ]\n                | 't' -> [ 't' ]\n                | 'u' -> [ 'u' ]\n                | 'v' -> [ 'v' ]\n                | 'w' -> [ 'w' ]\n                | 'x' -> [ 'x' ]\n                | 'y' -> [ 'y' ]\n                | 'z' -> [ 'z' ]\n                | '\\'' -> [ '\\'' ]\n                | '`' -> [ '`' ]\n                | '\\'' -> [ '\\'' ]\n                | '\\'' -> [ '\\'' ]\n                | '\\'' -> [ '\\'' ]\n                | '\\'' -> [ '\\'' ]\n                | '\\'' -> [ '\\'' ]\n                | '\\'' -> [ '\\'' ]\n                | '\\'' -> [ '\\'' ]\n                | '\\'' -> [ '\\'' ]\n                | '\\'' -> [ '\\'' ]\n                | '\\'' -> [ '\\'' ]\n                | '\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprwyjmwsp.fsx(49,19): error FS0010: Unexpected quote symbol in pattern matching\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefixes' = prefixes @ [str]\n            all_prefixes_rec prefixes' str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + \" \")\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        if str.StartsWith(prefixes.[0]) then\n            prefixes\n        else\n            prefixes @ [str]\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (s:string) =\n        match s with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = s.Substring(0, s.Length - 1)\n            prefixes |> List.map (fun prefix -> prefix + prefix)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec acc = function\n        | [] -> acc\n        | x::xs -> \n            if x = string then\n                all_prefixes_rec (x::acc) xs\n            else\n                all_prefixes_rec (x::acc) xs\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpidt34112.fsx(12,25): error FS0001: Type mismatch. Expecting a\n    ''a list'    \nbut given a\n    ''a'    \nThe types ''a' and ''a list' cannot be unified.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            if head.StartsWith(string) then\n                all_prefixes' tail\n            else\n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpbdprbzv4.fsx(9,16): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.IndexOf('.'))\n            let suffix = str.Substring(str.IndexOf('.'))\n            prefixes @ [prefix; suffix]\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + \" \")\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefix = str.[0]\n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + prefix)\n            all_prefixes' prefixes' (str.Substring(1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.map (fun prefix -> prefix + \" \" + all_prefixes' prefixes)\n            |> List.reduce (fun acc prefix -> prefix + \" \" + acc)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp1nc860e_.fsx(11,55): error FS0001: The type 'string -> string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.ToUpper()\n            if prefix.Length > 0 then \n                all_prefixes' tail\n            else\n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefixes = head.Split('.')\n            if prefixes.Length <> 2 then\n                all_prefixes_rec tail\n            else\n                prefixes\n                |> List.map (fun prefix -> prefix + \".\" + (all_prefixes_rec tail))\n                |> List.concat\n    all_prefixes_rec string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpv4vxn0wr.fsx(14,20): error FS0001: The type 'string[]' does not match the type ''a list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.Substring(0,1).ToUpper() + head.Substring(1)\n            all_prefixes_rec tail\n    all_prefixes_rec (string.ToLower().Split(' '))\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpjes6t7gj.fsx(11,23): error FS0072: Lookup on object of indeterminate type based on information prior to this program point. A type annotation may be needed prior to this program point to constrain the type of the object. This may allow the lookup to be resolved.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (s: string) =\n        match s with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [s]\n            all_prefixes' prefixes' (s.Substring(0, 1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec acc = function\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'd' -> acc\n        | 'e' -> acc\n        | 'f' -> acc\n        | 'g' -> acc\n        | 'h' -> acc\n        | 'i' -> acc\n        | 'j' -> acc\n        | 'k' -> acc\n        | 'l' -> acc\n        | 'm' -> acc\n        | 'n' -> acc\n        | 'o' -> acc\n        | 'p' -> acc\n        | 'q' -> acc\n        | 'r' -> acc\n        | 's' -> acc\n        | 't' -> acc\n        | 'u' -> acc\n        | 'v' -> acc\n        | 'w' -> acc\n        | 'x' -> acc\n        | 'y' -> acc\n        | 'z' -> acc\n        | '0' -> acc\n        | '1' -> acc\n        | '2' -> acc\n        | '3' -> acc\n        | '4' -> acc\n        | '5' -> acc\n        | '6' -> acc\n        | '7' -> acc\n        | '8' -> acc\n        | '9' -> acc\n        | '.' -> acc\n        | '+' -> acc\n        | '*' -> acc\n        | '/' -> acc\n        | '?' -> acc\n        | '~' -> acc\n        | '@' -> acc\n        | '^' -> acc\n        | '_' -> acc\n        | '`' -> acc\n        | '{' -> acc\n        | '}' -> acc\n        | '[' -> acc\n        | ']' -> acc\n        | '(' -> acc\n        | ')' -> acc\n        | ',' -> acc\n        | '.' -> acc\n        | ',' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\n        | '.' -> acc\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp4u8s40fh.fsx(5,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.TrimStart('a')\n            if prefix.Length = 0 then\n                all_prefixes_rec tail\n            else\n                prefix::all_prefixes_rec tail\n    all_prefixes_rec string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzfadvbvf.fsx(17,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (prefix:string) =\n        match prefixes with\n        | [] -> prefix\n        | prefix :: rest ->\n            if prefix.Length = 0 then\n                prefix\n            else\n                all_prefixes_rec rest prefix\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp6xr5uwv2.fsx(16,26): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> all_prefixes' (prefixes @ [prefix])\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk_e4b257.fsx(11,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            if prefix.Length > 0 then \n                all_prefixes' tail\n            else \n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes_rec prefixes' str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.IndexOf('.'))\n            prefixes @ [prefix]\n            |> List.map (fun prefix -> prefix + \".\" + str.Substring(prefix.Length))\n            |> all_prefixes' prefixes\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpdyc4p4hz.fsx(12,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec acc = \n        function\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'd' -> acc\n        | 'e' -> acc\n        | 'f' -> acc\n        | 'g' -> acc\n        | 'h' -> acc\n        | 'i' -> acc\n        | 'j' -> acc\n        | 'k' -> acc\n        | 'l' -> acc\n        | 'm' -> acc\n        | 'n' -> acc\n        | 'o' -> acc\n        | 'p' -> acc\n        | 'q' -> acc\n        | 'r' -> acc\n        | 's' -> acc\n        | 't' -> acc\n        | 'u' -> acc\n        | 'v' -> acc\n        | 'w' -> acc\n        | 'x' -> acc\n        | 'y' -> acc\n        | 'z' -> acc\n        | 'A' -> acc\n        | 'B' -> acc\n        | 'C' -> acc\n        | 'D' -> acc\n        | 'E' -> acc\n        | 'F' -> acc\n        | 'G' -> acc\n        | 'H' -> acc\n        | 'I' -> acc\n        | 'J' -> acc\n        | 'K' -> acc\n        | 'L' -> acc\n        | 'M' -> acc\n        | 'N' -> acc\n        | 'O' -> acc\n        | 'P' -> acc\n        | 'Q' -> acc\n        | 'R' -> acc\n        | 'S' -> acc\n        | 'T' -> acc\n        | 'U' -> acc\n        | 'V' -> acc\n        | 'W' -> acc\n        | 'X' -> acc\n        | 'Y' -> acc\n        | 'Z' -> acc\n        | 'A' -> acc\n        | 'B' -> acc\n        | 'C' -> acc\n        | 'D' -> acc\n        | 'E' -> acc\n        | 'F' -> acc\n        | 'G' -> acc\n        | 'H' -> acc\n        | 'I' -> acc\n        | 'J' -> acc\n\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp6dao6z15.fsx(5,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | x::xs -> \n            let prefix = x.TrimStart('.')\n            if prefix.Length = 0 then \n                all_prefixes' xs\n            else\n                prefix::all_prefixes' xs\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | x::xs -> \n            let prefixes' = \n                match x with\n                | 'a' -> [x]\n                | 'b' -> [x; 'a']\n                | 'c' -> [x; 'b']\n                | 'd' -> [x; 'c']\n                | 'e' -> [x; 'd']\n                | 'f' -> [x; 'e']\n                | 'g' -> [x; 'f']\n                | 'h' -> [x; 'g']\n                | 'i' -> [x; 'h']\n                | 'j' -> [x; 'i']\n                | 'k' -> [x; 'j']\n                | 'l' -> [x; 'k']\n                | 'm' -> [x; 'l']\n                | 'n' -> [x; 'm']\n                | 'o' -> [x; 'n']\n                | 'p' -> [x; 'o']\n                | 'q' -> [x; 'p']\n                | 'r' -> [x; 'q']\n                | 's' -> [x; 'r']\n                | 't' -> [x; 's']\n                | 'u' -> [x; 't']\n                | 'v' -> [x; 'u']\n                | 'w' -> [x; 'v']\n                | 'x' -> [x; 'w']\n                | 'y' -> [x; 'x']\n                | 'z' -> [x; 'y']\n                | _ -> prefixes\n            all_prefixes' xs\n    all_prefixes' string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpt7luo_hk.fsx(11,19): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.map (fun prefix -> all_prefixes_rec prefixes (str.Substring(prefix.Length)))\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpg3tn8l4w.fsx(11,40): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'string list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.TrimStart('a')\n            if prefix.Length > 0 then\n                prefix::all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (prefix: string) =\n        match prefixes with\n        | [] -> prefix\n        | prefix::rest ->\n            if prefix.StartsWith(prefix) then\n                prefix\n            else\n                all_prefixes_rec rest prefix\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5dg_euus.fsx(16,26): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (prefix: string) =\n        match prefixes with\n        | [] -> prefix\n        | prefix::rest ->\n            if prefix.StartsWith(prefix) then\n                all_prefixes_rec rest prefix\n            else\n                prefix + prefix\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpb6bkp9o4.fsx(16,26): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.map (fun prefix -> all_prefixes_rec prefixes str)\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcey45z1j.fsx(11,40): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'string list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + \" \")\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefixes' = \n                match head with\n                | 'a' -> ['a', 'a', 'a']\n                | 'b' -> ['b', 'b', 'b']\n                | 'c' -> ['c', 'c', 'c']\n                | 'd' -> ['d', 'd', 'd']\n                | 'e' -> ['e', 'e', 'e']\n                | 'f' -> ['f', 'f', 'f']\n                | 'g' -> ['g', 'g', 'g']\n                | 'h' -> ['h', 'h', 'h']\n                | 'i' -> ['i', 'i', 'i']\n                | 'j' -> ['j', 'j', 'j']\n                | 'k' -> ['k', 'k', 'k']\n                | 'l' -> ['l', 'l', 'l']\n                | 'm' -> ['m', 'm', 'm']\n                | 'n' -> ['n', 'n', 'n']\n                | 'o' -> ['o', 'o', 'o']\n                | 'p' -> ['p', 'p', 'p']\n                | 'q' -> ['q', 'q', 'q']\n                | 'r' -> ['r', 'r', 'r']\n                | 's' -> ['s', 's', 's']\n                | 't' -> ['t', 't', 't']\n                | 'u' -> ['u', 'u', 'u']\n                | 'v' -> ['v', 'v', 'v']\n                | 'w' -> ['w', 'w', 'w']\n                | 'x' -> ['x', 'x', 'x']\n                | 'y' -> ['y', 'y', 'y']\n                | 'z' -> ['z', 'z', 'z']\n                | _ -> failwith \"unexpected prefix\"\n            prefixes' @ all_prefixes' tail\n    all_prefixes' string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgc3_nj5v.fsx(11,19): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + \" \")\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.rev\n            |> all_prefixes_rec (prefixes.Tail)\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpke5k7uxj.fsx(12,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.rev\n            |> all_prefixes_rec (prefixes.Tail)\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpke5k7uxj.fsx(12,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.TrimStart('a')\n            if prefix.Length > 0 then \n                prefixes@all_prefixes' tail\n            else \n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        if str.StartsWith(prefixes.[0]) then\n            prefixes\n        else\n            prefixes @ [str]\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes (str.Substring(0, str.Length - 1))\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            if head.StartsWith(string(0)) then \n                all_prefixes' tail\n            else\n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyy8zeg7y.fsx(9,16): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449535,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> str.Substring(prefix.Length))\n            all_prefixes' prefixes' str.Substring(0, str.Length - prefixes'.Length)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpatp3giej.fsx(10,37): error FS0597: Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.TrimStart('a')\n            if prefix.Length > 0 then\n                prefix::all_prefixes_rec tail\n            else\n                prefix::all_prefixes_rec tail\n    all_prefixes_rec string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp8gtyza0q.fsx(17,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes_rec prefixes' str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefixes = \n                match head with \n                | 'a' -> ['a', 'a', 'a']\n                | 'b' -> ['b', 'b', 'b']\n                | 'c' -> ['c', 'c', 'c']\n                | 'd' -> ['d', 'd', 'd']\n                | 'e' -> ['e', 'e', 'e']\n                | 'f' -> ['f', 'f', 'f']\n                | 'g' -> ['g', 'g', 'g']\n                | 'h' -> ['h', 'h', 'h']\n                | 'i' -> ['i', 'i', 'i']\n                | 'j' -> ['j', 'j', 'j']\n                | 'k' -> ['k', 'k', 'k']\n                | 'l' -> ['l', 'l', 'l']\n                | 'm' -> ['m', 'm', 'm']\n                | 'n' -> ['n', 'n', 'n']\n                | 'o' -> ['o', 'o', 'o']\n                | 'p' -> ['p', 'p', 'p']\n                | 'q' -> ['q', 'q', 'q']\n                | 'r' -> ['r', 'r', 'r']\n                | 's' -> ['s', 's', 's']\n                | 't' -> ['t', 't', 't']\n                | 'u' -> ['u', 'u', 'u']\n                | 'v' -> ['v', 'v', 'v']\n                | 'w' -> ['w', 'w', 'w']\n                | 'x' -> ['x', 'x', 'x']\n                | 'y' -> ['y', 'y', 'y']\n                | 'z' -> ['z', 'z', 'z']\n                | 'A' -> ['A', 'A', 'A']\n                | 'B' -> ['B', 'B', 'B']\n                | 'C' -> ['C', 'C\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp20va64vq.fsx(39,32): error FS0010: Unexpected quote symbol in expression\n\n\n\n/tmp/tmp20va64vq.fsx(40,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (10:17). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.ToLower()\n            if prefix.StartsWith(string) then \n                prefix::all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "\n\n/tmp/tmphzh_n5r1.fsx(10,16): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes (str.Substring(0, str.Length - 1))\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefixes' = \n                match head with\n                | 'a' -> ['a', 'a', 'a']\n                | 'b' -> ['b', 'b', 'b']\n                | 'c' -> ['c', 'c', 'c']\n                | 'd' -> ['d', 'd', 'd']\n                | 'e' -> ['e', 'e', 'e']\n                | 'f' -> ['f', 'f', 'f']\n                | 'g' -> ['g', 'g', 'g']\n                | 'h' -> ['h', 'h', 'h']\n                | 'i' -> ['i', 'i', 'i']\n                | 'j' -> ['j', 'j', 'j']\n                | 'k' -> ['k', 'k', 'k']\n                | 'l' -> ['l', 'l', 'l']\n                | 'm' -> ['m', 'm', 'm']\n                | 'n' -> ['n', 'n', 'n']\n                | 'o' -> ['o', 'o', 'o']\n                | 'p' -> ['p', 'p', 'p']\n                | 'q' -> ['q', 'q', 'q']\n                | 'r' -> ['r', 'r', 'r']\n                | 's' -> ['s', 's', 's']\n                | 't' -> ['t', 't', 't']\n                | 'u' -> ['u', 'u', 'u']\n                | 'v' -> ['v', 'v', 'v']\n                | 'w' -> ['w', 'w', 'w']\n                | 'x' -> ['x', 'x', 'x']\n                | 'y' -> ['y', 'y', 'y']\n                | 'z' -> ['z', 'z', 'z']\n                | _ -> failwith \"unreachable\"\n            prefixes' @ all_prefixes' tail\n    all_prefixes' string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449538,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpyjzngrb0.fsx(11,19): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes (str.Substring(0, str.Length - 1))\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.map (fun prefix -> all_prefixes' prefixes prefix)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps9w9sy11.fsx(11,40): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'string list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes_rec prefixes' str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (s: string) =\n        match s.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefix = s.Substring(0, s.Length - 1)\n            prefixes @ [prefix] @ all_prefixes' prefixes (s.Substring(1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> List.rev\n            |> all_prefixes_rec (prefixes.Tail)\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpke5k7uxj.fsx(12,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes' prefixes' (str.Substring(0, str.Length - prefixes.Length))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpow1oa1ww.fsx(10,27): error FS0039: The value or constructor 'prefixes'' is not defined. Maybe you want one of the following:\n   prefixes\n   all_prefixes'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | x::xs ->\n            let prefixes' = x::prefixes\n            all_prefixes' prefixes'\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> str.Substring(prefix.Length))\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (s:string) = \n        match s with\n        | \"\" -> prefixes\n        | _ -> \n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + \" \" + s)\n            all_prefixes' prefixes' s\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | x::xs -> \n            let prefixes' = x::prefixes\n            all_prefixes' prefixes'\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            let prefixes' = all_prefixes' tail\n            prefix::prefixes'\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            if head.StartsWith(string(0)) then\n                all_prefixes' tail\n            else\n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2l5z_ref.fsx(9,16): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes |> List.map (fun prefix -> prefix + prefix) |> List.concat\n            |> all_prefixes_rec (prefixes.Tail)\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "\n\n/tmp/tmppvtpwkq7.fsx(10,69): error FS0001: The type 'string list' is not compatible with the type 'seq<'a list>'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes |> List.filter (fun prefix -> prefix.StartsWith(prefix)) |> List.map (fun prefix -> prefix.Substring(prefix.Length))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.Trim()\n            if prefix.Length > 0 then\n                prefixes\n                |> List.filter (fun prefix -> prefix.StartsWith(prefix))\n                |> List.map (fun prefix -> prefix.Trim())\n                |> List.append (all_prefixes_rec tail)\n            else\n                prefixes\n    all_prefixes_rec []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefixes' = \n                match head with \n                | 'a' -> ['a', 'b', 'c']\n                | 'b' -> ['b', 'a', 'c']\n                | 'c' -> ['c', 'a', 'b']\n                | _ -> []\n            all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpmsfgsyxq.fsx(11,19): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.ToLower()\n            if prefix.Length > 0 then\n                prefixes\n                |> List.filter (fun prefix -> prefix.Length > 0 && prefix.ToLower() = head.ToLower())\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.ToLower())\n                |> List.filter (fun prefix -> prefix.\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpgsjiq5jh.fsx(38,53): error FS0599: Missing qualification after '.'\n\n\n\n/tmp/tmpgsjiq5jh.fsx(39,1): warning FS0058: Possible incorrect indentation: this token is offside of context started at position (10:13). Try indenting this token further or using standard formatting conventions.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes |> List.filter (fun prefix -> prefix = prefix)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> all_prefixes' (prefixes |> List.rev)\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprdiwrtcx.fsx(5,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (prefix: string) =\n        match prefixes with\n        | [] -> prefix\n        | prefix :: rest ->\n            let prefix_length = prefix.Length\n            if prefix_length > 1 then\n                let prefix_length_in_list = prefix_length - 1\n                let prefix_in_list = prefix.Substring(0, prefix_length_in_list)\n                all_prefixes_rec rest prefix_in_list\n            else\n                prefix\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzpmwnnbp.fsx(19,26): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes' prefixes' (str.Substring(0, str.Length - 1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpftluy61y.fsx(10,27): error FS0039: The value or constructor 'prefixes'' is not defined. Maybe you want one of the following:\n   prefixes\n   all_prefixes'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes' prefixes' (str.Substring(1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpglxifh1o.fsx(10,27): error FS0039: The value or constructor 'prefixes'' is not defined. Maybe you want one of the following:\n   prefixes\n   all_prefixes'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> all_prefixes_rec prefixes\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmps2hxx6ll.fsx(11,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) = \n        match str with\n        | \"\" -> prefixes\n        | _ -> \n            let prefixes = prefixes |> List.map (fun prefix -> str.Substring(0, prefix.Length))\n            all_prefixes' prefixes (str.Substring(prefix.Length))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpb8_29oqf.fsx(10,51): error FS0039: The value, namespace, type or module 'prefix' is not defined. Maybe you want one of the following:\n   prefixes\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.IndexOf('.'))\n            prefixes @ [prefix]\n            |> all_prefixes_rec (prefixes @ [prefix])\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp36ky54n3.fsx(11,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> str.Substring(0, prefix.Length))\n            all_prefixes' prefixes' (str.Substring(prefix.Length))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpctnhx5fx.fsx(10,52): error FS0039: The value, namespace, type or module 'prefix' is not defined. Maybe you want one of the following:\n   prefixes\n   prefixes'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            let suffix = str.Substring(str.Length - 1)\n            prefixes @ [prefix, suffix]\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpcylg3qmr.fsx(11,25): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'string * string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes (str.Substring(0, str.Length - 1))\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' (str.Substring(1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec acc = \n        function\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpffj_86r3.fsx(5,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) = \n        match str with \n        | \"\" -> prefixes\n        | _ -> \n            let prefixes' = prefixes |> List.map (fun prefix -> str.Substring(prefix.Length))\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (s: string) = \n        match s.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefix = s.Substring(0, s.Length - 1)\n            prefixes @ [prefix]\n            |> List.map (fun prefix -> prefix + s.Substring(prefix.Length))\n            |> all_prefixes' prefixes\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpvviowptv.fsx(5,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.TrimStart('a')\n            let prefixes' = all_prefixes' tail\n            prefix::prefixes'\n    all_prefixes' [string]\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.Trim()\n            if prefix.Length > 0 then\n                prefix::all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' (str.Substring(1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.IndexOf('.'))\n            prefixes @ [prefix]\n            |> all_prefixes_rec (prefixes @ [prefix])\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpln18f9br.fsx(11,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449535,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec acc = function\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | 'a' -> acc\n        | 'b' -> acc\n        | 'c' -> acc\n        | _ -> failwith \"invalid character\"\n    all_prefixes_rec (string |> Seq.toList)\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp5s0yvs05.fsx(9,11): warning FS0026: This rule will never be matched\n\n\n\n/tmp/tmp5s0yvs05.fsx(10,11): warning FS0026: This rule will never be matched\n\n\n\n/tmp/tmp5s0yvs05.fsx(11,11): warning FS0026: This rule will never be matched\n\n\n\n/tmp/tmp5s0yvs05.fsx(16,11): error FS0001: The type '(char -> 'a list)' does not support the 'equality' constraint because it is a function type\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + \" \")\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            let prefixes' = prefixes |> List.filter (fun prefix -> prefix <> prefix)\n            all_prefixes' prefixes' (str.Substring(str.Length - 1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | x::xs -> \n            if x.StartsWith(string(0)) then \n                all_prefixes_rec xs\n            else \n                prefixes @ [x]\n    all_prefixes_rec []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpz366xma_.fsx(9,16): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> all_prefixes_rec prefixes\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmprbl_ceqz.fsx(5,5): error FS0588: The block following this 'let' is unfinished. Every code block is an expression and must have a result. 'let' cannot be the final code element in a block. Consider giving this block an explicit result.\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.TrimStart('a')\n            if prefix.Length > 0 then \n                prefixes\n                |> List.filter (fun prefix -> prefix.Length > 0)\n                |> List.map (fun prefix -> prefix.TrimStart('a'))\n                |> List.append [prefix]\n            else\n                all_prefixes_rec tail\n    all_prefixes_rec []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            if prefix.Length > 0 then \n                prefix::all_prefixes_rec tail\n            else\n                prefix::all_prefixes_rec tail\n    all_prefixes_rec string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpy58lucr7.fsx(17,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> str.Substring(prefix.Length))\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            let prefix = head.TrimStart(' ')\n            if prefix.Length > 0 then\n                prefix::all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (prefix:string) =\n        if prefix.StartsWith(prefixes.[0]) then\n            prefixes.[0..prefix.Length-1]\n        else\n            prefixes\n    let prefixes = all_prefixes_rec [string(0)] string\n    prefixes\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "\n\n/tmp/tmplxfmho_3.fsx(10,49): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'int -> string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            if prefix.Length > 0 then \n                all_prefixes' tail\n            else\n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefixes' =\n                match head with\n                | 'a' -> [head]\n                | 'b' -> [head; 'a']\n                | 'c' -> [head; 'b']\n                | 'd' -> [head; 'c']\n                | 'e' -> [head; 'd']\n                | 'f' -> [head; 'e']\n                | 'g' -> [head; 'f']\n                | 'h' -> [head; 'g']\n                | 'i' -> [head; 'h']\n                | 'j' -> [head; 'i']\n                | 'k' -> [head; 'j']\n                | 'l' -> [head; 'k']\n                | 'm' -> [head; 'l']\n                | 'n' -> [head; 'm']\n                | 'o' -> [head; 'n']\n                | 'p' -> [head; 'o']\n                | 'q' -> [head; 'p']\n                | 'r' -> [head; 'q']\n                | 's' -> [head; 'r']\n                | 't' -> [head; 's']\n                | 'u' -> [head; 't']\n                | 'v' -> [head; 'u']\n                | 'w' -> [head; 'v']\n                | 'x' -> [head; 'w']\n                | 'y' -> [head; 'x']\n                | 'z' -> [head; 'y']\n                | _ -> []\n            all_prefixes' tail\n    all_prefixes' string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpephxh18c.fsx(11,19): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    'char'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            let prefixes' = prefixes @ [prefix]\n            all_prefixes' prefixes' (str.Substring(str.Length - 1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> all_prefixes_rec (prefixes @ [prefix])\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpkxktu5al.fsx(11,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | x::xs ->\n            let prefixes' = x::prefixes\n            all_prefixes_rec prefixes'\n    all_prefixes_rec string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp0nuxxq0c.fsx(14,21): error FS0001: This expression was expected to have type\n    'string list'    \nbut here has type\n    'string'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> all_prefixes' (prefixes @ [prefix])\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449537,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk_e4b257.fsx(11,16): error FS0001: The type 'string list' does not match the type 'string'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes' prefixes' (str.Substring(1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpglxifh1o.fsx(10,27): error FS0039: The value or constructor 'prefixes'' is not defined. Maybe you want one of the following:\n   prefixes\n   all_prefixes'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.TrimStart('a')\n            let prefixes' = all_prefixes' tail\n            prefix::prefixes'\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) = \n        match str.Length with\n        | 0 -> prefixes\n        | _ -> \n            let prefixes = prefixes @ [str]\n            all_prefixes_rec prefixes str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.IndexOf('.'))\n            prefixes |> List.append [prefix]\n            all_prefixes_rec (prefixes |> List.tail) (str.Substring(str.IndexOf('.')))\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpx48_3t12.fsx(10,13): warning FS0020: The result of this expression has type 'string list' and is implicitly ignored. Consider using 'ignore' to discard this value explicitly, e.g. 'expr |> ignore', or 'let' to bind the result to a name, e.g. 'let result = expr'.\n\n",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.TrimStart('a')\n            if prefix.Length > 0 then\n                prefix::all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (str:string) =\n        match str.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            let prefixes' = prefixes |> List.filter (fun prefix -> prefix.StartsWith(prefix))\n            all_prefixes_rec prefixes' str\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> str.Substring(prefix.Length))\n            all_prefixes' prefixes' str.Substring(0, str.Length - prefixes'.Length)\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpk34m35tn.fsx(10,37): error FS0597: Successive arguments should be separated by spaces or tupled, and arguments involving function or method applications should be parenthesized\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes = prefixes @ [str]\n            all_prefixes' prefixes' (str.Substring(1))\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449540,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpglxifh1o.fsx(10,27): error FS0039: The value or constructor 'prefixes'' is not defined. Maybe you want one of the following:\n   prefixes\n   all_prefixes'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefixes = head::prefixes\n            all_prefixes_rec prefixes\n    all_prefixes_rec []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes @ [prefix]\n            |> all_prefixes'\n            |> List.rev\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "\n\n/tmp/tmptoeqmir6.fsx(12,16): error FS0001: The type 'string -> string list' does not match the type ''a list'\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefix = str.Substring(0, str.Length - 1)\n            prefixes |> List.map (fun prefix -> prefix + prefix)\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with\n        | [] -> []\n        | head::tail -> \n            if head.StartsWith(string) then \n                all_prefixes' tail\n            else\n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpwev5ltqy.fsx(9,16): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.Trim()\n            if prefix.Length = 0 then\n                all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (prefix:string) =\n        match prefixes with\n        | [] -> prefix\n        | prefix::rest ->\n            let prefix_length = prefix.Length\n            if prefix_length > 1 then\n                let prefix_length = prefix_length - 1\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let prefix_length = if prefix_length = 0 then 1 else prefix_length\n                let\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449541,
      "stdout": "",
      "stderr": "\n\n/tmp/tmp2l2r_u3k.fsx(36,1): error FS0010: Incomplete structured construct at or before this point in binding\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes @ [str]\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449534,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) (str: string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> str.Substring(prefix.Length))\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449539,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.Trim()\n            if prefix.Length > 0 then \n                all_prefixes' tail\n            else \n                prefixes\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) = \n        match prefixes with \n        | [] -> []\n        | head::tail -> \n            let prefix = head.ToLower()\n            if prefix.StartsWith(string) then \n                prefix::all_prefixes' tail\n            else \n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpzik2wy_0.fsx(10,16): error FS0041: A unique overload for method 'StartsWith' could not be determined based on type information prior to this program point. A type annotation may be needed.\n\nKnown type of argument: 'a\n\nCandidates:\n - System.String.StartsWith(value: char) : bool\n - System.String.StartsWith(value: string) : bool\n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes_rec (prefixes:string list) (prefix:string) =\n        match prefixes with\n        | [] -> prefix\n        | head::tail ->\n            let prefix = head + prefix\n            all_prefixes_rec tail prefix\n    all_prefixes_rec [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "\n\n/tmp/tmpx4ft221w.fsx(14,26): error FS0001: This expression was expected to have type\n    'string'    \nbut here has type\n    ''a list'    \n\n",
      "exit_code": 1,
      "status": "Exception"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (str:string) =\n        match str with\n        | \"\" -> prefixes\n        | _ ->\n            let prefixes' = prefixes |> List.map (fun prefix -> prefix + \" \")\n            all_prefixes' prefixes' str\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449536,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes:string list) (s:string) =\n        match s.Length with\n        | 0 -> prefixes\n        | _ ->\n            let prefix = s.Substring(0,1)\n            let suffix = s.Substring(1)\n            prefixes @ [prefix; suffix]\n    all_prefixes' [] string\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449543,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    },
    {
      "program": "//Return list of all prefixes from shortest to longest of the input string\n// >>> all_prefixes('abc')\n// ['a', 'ab', 'abc']\nlet all_prefixes string = \n    let rec all_prefixes' (prefixes: string list) =\n        match prefixes with\n        | [] -> []\n        | head::tail ->\n            let prefix = head.TrimStart('a')\n            if prefix.Length > 0 then\n                prefix::all_prefixes' tail\n            else\n                prefix::all_prefixes' tail\n    all_prefixes' []\nlet test() = \n  let candidate = all_prefixes\n  assert (candidate \"\" = [])\n  assert (candidate \"asdfgh\" = [\"a\"; \"as\"; \"asd\"; \"asdf\"; \"asdfg\"; \"asdfgh\"])\n  assert (candidate \"WWW\" = [\"W\"; \"WW\"; \"WWW\"])\n  0\n\ntest()",
      "timestamp": 1675449542,
      "stdout": "",
      "stderr": "",
      "exit_code": 0,
      "status": "OK"
    }
  ]
}